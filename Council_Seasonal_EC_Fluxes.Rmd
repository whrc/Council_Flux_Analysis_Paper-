---
title: "Council EC Fluxes & Seasons" #Determining seasons, exploring the data - seasonal and annual budgets with adjusted winter methane emissions is in "Council-EC_Analysis2" 
output: html_document
date: "2024-12-02"
---

#Notes on site: Wind direction primarily blows from NW, except for Dec - Mar, when it primarily blows from SE direction. The site is largely tussock tundra but to the south there is thermokarst 


## based on Dani's Churchill CO2 Analysis code on github 

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# add root directory here for github
```

Notes:

```{r, include=FALSE}
rm(list = ls())

library(data.table)
library(ggplot2)
library(cowplot)
library(openair)
library(plotrix)
library(signal)
library(svMisc)
library(zoo)
library(stringr)
library(plyr)
library(viridis)
library(lubridate)
library(tidyverse)
library(gridExtra)
library(plotly)
library(RColorBrewer)
library(pracma)
library(dplyr)


Sys.setenv(TZ='UTC')
```

# Set working directory and then Load data

```{r}
#using the ".2" version to reflect the updated SWC used in RF - these should have seasons added already to each DOY, also includes TA_ERA5 and TS_ERA5. 

#The original without any added columns post-AMF processing, with added columns removed for reference:
# library(dplyr)
# 
# df_clean <- df %>%
#   select(-TA_ERA5, -TS_ERA5, -date, -FC_night, -FC_night_F, -year, -DOY, -season)
# 
# write.csv(x = df_clean,file = 'C:/Users/kkent/Documents/Council Data/Council BASE gapfilling/council_AMF_gapfilled_clean_2017_2023.2.csv',quote = F,row.names = F)



#HH daataset
df = fread('C:/Users/kkent/Documents/Council Data/Council BASE gapfilling/council_gapfilled_clean_2017_2023_for analysis.2.csv',na.strings = c('-9999','NA','NaN','NAN','-7999'))

#needs continuous day variable - daily avg, calculated in processing steps - using ".4" with GF temps, two WD classifications, and corrected seasonal delineations 
df_avg = fread('C:/Users/kkent/Documents/Council Data/Council BASE gapfilling/council_AVG_gapfilled_clean_2017_2023_for analysis.4.csv',na.strings = c('-9999','NA','NaN','NAN','-7999'))

```


```{r}
#quick look at the different temp profiles (all at 15 cm depth, diff locations)
sum(is.na(df$TS_1_1_1)) #60277 NA's in temp by margin pond 
sum(is.na(df$TS_2_1_1)) #48729 NA's in temp  by lichen/berries  
sum(is.na(df$TS_3_1_1)) #50445 NA's in temp by tussock 
sum(is.na(df$TS_4_1_1)) #52796 NA's in temp by foot of EC tower
sum(is.na(df$TS_5_1_1)) #new temp in latest upload with 2023 data, don't have info on what it is yet** 


#SWC also broken up by location
#  SWC_1_1_1 % Soil water content (15cm depth) – margin pond
# SWC_2_1_1 % Soil water content (15cm depth) – lichen/berries
# SWC_3_1_1 % Soil water content (15cm depth) - tussock


```

```{r}
#checking timestamp 
ggplot(data = df,aes(TIMESTAMP_END,FC_F))+
  geom_point()+
  scale_x_datetime(limits = as.POSIXct(c('2021-09-28','2021-10-05')))+
  scale_y_continuous(limits = c(-12,5))
```

#Create yearly dataframes

#Creates data frames of each year containing the daily averages of each value- useful for focusing on one year at a time
```{r}
#create dataframes for each year for the data you have so you can look at annual trends 

#map out the timestamp of the daily avg dataset
df_avg$date <- as.POSIXct(df_avg$date, format = "%Y-%m-%d") #tells R the order of the timestamp: yr-month-day 

df_avg_2017 <- df_avg %>% filter(year == "2017") 
df_avg_2018 <- df_avg %>% filter(year == "2018") 
df_avg_2019 <- df_avg %>% filter(year == "2019") 
df_avg_2020 <- df_avg %>% filter(year == "2020") 
df_avg_2021 <- df_avg %>% filter(year == "2021") 
df_avg_2022 <- df_avg %>% filter(year == "2022") 
df_avg_2023 <- df_avg %>% filter(year == "2023") 

#for HH data
df <- df %>%
  mutate(year = format(date, "%Y"))

df_2017 <- df %>% filter(year == "2017") 
df_2018 <- df %>% filter(year == "2018") 
df_2019 <- df %>% filter(year == "2019") 
df_2020 <- df %>% filter(year == "2020") 
df_2021 <- df %>% filter(year == "2021") 
df_2022 <- df %>% filter(year == "2022") 
df_2023 <- df %>% filter(year == "2023") 


```


#ERA5 air temp vs site air temp 
####Since I'll be using ERA5 air temp to supplement the missing temp gaps in the site data, need to check agreement 
```{r}
summary(lm(df$TA ~ df$TA_ERA5)) #R2 = 0.96, slope = 1

Air_temp_test= ggplot(data = df,aes(TA,TA_ERA5))+theme_bw()+
  geom_hline(yintercept = 0,lty=2)+
  geom_vline(xintercept = 0,lty=2)+
  geom_point(alpha=0.2)+
  scale_fill_viridis_c()+
  geom_abline(slope = 1,intercept = 0,col='red',lty=1)+
  scale_x_continuous('Site TA (C)')+
  scale_y_continuous('ERA5 TA (C)')+
  annotate(geom = 'text',x = 6, y = -8,label=expression(R^2~"= 0.96"),size = 3)+
  annotate(geom = 'text',x = 6,y = -15,label=expression(Slope~"= 1.0"),size = 3)+
  theme(text = element_text(size = 8)) +
  labs(title = "TA vs ERA5 TA")

Air_temp_test #great agreement, just like Kyle said 
```


#ERA5 soil temp vs site TS3 soil temp 
####Since I'll be using ERA5 air temp to supplement the missing temp gaps in the site data, need to check agreement 
```{r}
summary(lm(df$TS_3_1_1 ~ df$TS_ERA5)) #R2 = 0.87, slope = 1

Soil_temp_test= ggplot(data = df,aes(TS_3_1_1,TS_ERA5))+theme_bw()+
  geom_hline(yintercept = 0,lty=2)+
  geom_vline(xintercept = 0,lty=2)+
  geom_point(alpha=0.2)+
  scale_fill_viridis_c()+
  geom_abline(slope = 1,intercept = 0,col='red',lty=1)+
  scale_x_continuous('Site TS3 (C)')+
  scale_y_continuous('ERA5 TS (C)')+
  annotate(geom = 'text',x = 6, y = -8,label=expression(R^2~"= 0.87"),size = 3)+
  annotate(geom = 'text',x = 6,y = -15,label=expression(Slope~"= 1.0"),size = 3)+
  theme(text = element_text(size = 8)) +
  labs(title = "TA vs ERA5 TA")

Soil_temp_test 
```




#Comparing SWC and soil temp from the different locations 
```{r}
#SWC 
ggplot(data = df) +
  geom_line(aes(TIMESTAMP, SWC_1_1_1, col = 'SWC1 margin pond'))+
  geom_line(aes(TIMESTAMP, SWC_2_1_1, col = 'SWC2 lichen berries')) +
  geom_line(aes(TIMESTAMP, SWC_3_1_1, col = 'SWC3 tussock')) +
  labs(title = "Comparing SWC locations")+
  labs( x = "Timestamp",
        y = "SWC")+
  scale_y_continuous()+
  theme_minimal()


#soil temp
ggplot(data = df) +
    geom_line(aes(TIMESTAMP, TS_5_1_1, col = 'TS5 unknown')) + #putting it at front so other colored lines are not obscured by TS5
  geom_line(aes(TIMESTAMP, TS_1_1_1, col = 'TS1 margin pond'))+
  geom_line(aes(TIMESTAMP, TS_2_1_1, col = 'TS2 lichen berries')) +
  geom_line(aes(TIMESTAMP, TS_3_1_1, col = 'TS3 tussock')) +
  geom_line(aes(TIMESTAMP, TS_4_1_1, col = 'TS4 EC tower')) +
  #geom_line(aes(TIMESTAMP, TS_5_1_1, col = 'TS5 unknown')) +
  labs(title = "Comparing Soil temp among locations")+
  labs( x = "Timestamp",
        y = "Soil temp (C)")+
  scale_y_continuous()+
  theme_minimal()


```


# Timeseries plot - annual 

####Convert the data from umol or nmol C/m2/s to g C/m2/day  

** AMERIFLUX data is in micro mol/m2/s for CO2 and nano mol/m2/s for CH4 --> so here we have conversions to make the units in gC/m2/day for our timeseries figures 
** 12 = molar mass of C 
** nmol C to g C = 10^-9 * 12 & umol C to g C = 10^-6 * 12

**Using the gap-filled data for timeseries so there is continuous data, and for these we use the daily averages calculated before and multiply them by seconds -> min -> hours within a day and convert to g C 

#2017 
```{r}
#2017

annual_timeseries_2017_plot <- ggplot(data = df_avg_2017, aes(x=date))+
  theme_bw(base_size = 20)+
  geom_point(aes(y = -GPP_F*60*60*24*(1/1000000)*12, color = "GPP"))+
  geom_point(aes(y = RECO_F*60*60*24*(1/1000000)*12, color = "Respiration")) + 
  geom_line(aes(y = FC_F*60*60*24*(1/1000000)*12, color = "NEE"))+ # turbulent flux of CO2
  geom_line(aes(y = FCH4_F*60*60*24*(1/1000000000)*12*50, color = "CH4"))+ #multiply by 50 to help scale it so it shows up in the same figure as C, GPP, and Resp
  geom_hline(yintercept=0, col="black")+
  scale_y_continuous(
    name = expression('CO'[2]*' Flux (g C'~m^-2~d^-1*')'),
    limits = c(-6, 4),
  sec.axis = sec_axis(~ . / 50, name = expression('CH'[4]*' Flux (g C'~m^-2~d^-1*')')))+ #~.*1 or ~./ 50 notation in the code is used to scale the secondary axis 
  #when multiplying CH4 to scale it, make sure to do the opposite for when you scale the axis **--> example, if you multiply CH4 by 50 to get it visible on the same figure, divide the CH4 scale by 50 to take this scaling into account
  scale_color_manual(name = " ",
            values = c("GPP" = "navy", 
                      "Respiration" = "turquoise3", 
                      "NEE" = "salmon", 
                      "CH4" = "mediumorchid"),
            breaks = c("GPP", "Respiration", "NEE", "CH4"))+
  #labs(title = "GPP, Respiration, NEE, and Methane Fluxes: 2017", x = "Date") +
   labs(title = "2017", x = "Date") +
  
     theme(axis.text = element_text(size = 20, face = "bold"),
        axis.title = element_text(size = 20, face = "bold"),
        plot.title = element_text(size = 20, face = "bold", hjust = 0.5))+
  

   #2017
# vertical lines for specific events
geom_vline(xintercept = as.POSIXct("2017-05-10"))+ #end of winter, DOY 126
 geom_vline(xintercept =  as.POSIXct("2017-09-14"))+ #end of growing season, DOY 258
 geom_vline(xintercept =  as.POSIXct("2017-10-17")) + #end of Fall Senescence, DOY 289

# # Labels for each vertical line within figure
annotate("text", size = 5, x = as.POSIXct("2017-02-05"), y = -6, label = "Winter", color = "black") +
annotate("text", size = 5, x = as.POSIXct("2017-07-06"), y = -6, label = "Growing Season", color = "black") +
annotate("text", size = 5, x = as.POSIXct("2017-10-10"), y = -6, label = "Senescence", color = "black") +
annotate("text", size = 5, x = as.POSIXct("2017-12-15"), y = -6, label = "Winter", color = "black")

annual_timeseries_2017_plot

```

#2018
```{r}
annual_timeseries_2018_plot <- ggplot(data = df_avg_2018, aes(x=date))+
  theme_bw(base_size = 20)+
  geom_point(aes(y = -GPP_F*60*60*24*(1/1000000)*12, color = "GPP"))+
  geom_point(aes(y = RECO_F*60*60*24*(1/1000000)*12, color = "Respiration")) + 
  geom_line(aes(y = FC_F*60*60*24*(1/1000000)*12, color = "NEE"))+ # turbulent flux of CO2
  geom_line(aes(y = FCH4_F*60*60*24*(1/1000000000)*12*50, color = "CH4"))+ #multiply by 50 to help scale it so it shows up in the same figure as C, GPP, and Resp
  geom_hline(yintercept=0, col="black")+
  scale_y_continuous(
    name = expression('CO'[2]*' Flux (g C'~m^-2~d^-1*')'),
    limits = c(-6, 4),
  sec.axis = sec_axis(~ . / 50, name = expression('CH'[4]*' Flux (g C'~m^-2~d^-1*')')))+ #~.*1 or ~./ 50 notation in the code is used to scale the secondary axis 
  #when multiplying CH4 to scale it, make sure to do the opposite for when you scale the axis **--> example, if you multiply CH4 by 50 to get it visible on the same figure, divide the CH4 scale by 50 to take this scaling into account
  scale_color_manual(name = " ",
            values = c("GPP" = "navy", 
                      "Respiration" = "turquoise3", 
                      "NEE" = "salmon", 
                      "CH4" = "mediumorchid"),
            breaks = c("GPP", "Respiration", "NEE", "CH4"))+
  #labs(title = "GPP, Respiration, NEE, and Methane Fluxes: 2018", x = "Date") +
  labs(title = "2018", x = "Date") +
  
 theme(axis.text = element_text(size = 20, face = "bold"),
        axis.title = element_text(size = 20, face = "bold"),
        plot.title = element_text(size = 20, face = "bold", hjust = 0.5))+
  

    #2018
  geom_vline(xintercept = as.POSIXct("2018-05-30"))+ #end of winter, DOY 150*
  geom_vline(xintercept =  as.POSIXct("2018-09-13"))+ #end of growing season, DOY 256*
  geom_vline(xintercept =  as.POSIXct("2018-10-26")) + #end of Fall Senescence, DOY 299*

# Labels for each vertical line within figure
annotate("text", size = 5, x = as.POSIXct("2018-03-01"), y = -6, label = "Winter", color = "black") +
annotate("text", size = 5, x = as.POSIXct("2018-07-19"), y = -6, label = "Growing Season", color = "black") +
annotate("text", size = 5, x = as.POSIXct("2018-10-10"), y = -6, label = "Senescence", color = "black") +
annotate("text", size = 5, x = as.POSIXct("2018-12-15"), y = -6, label = "Winter", color = "black")

 annual_timeseries_2018_plot 
```


#2019
```{r}

annual_timeseries_2019_plot <- ggplot(data = df_avg_2019, aes(x=date))+
  theme_bw(base_size = 20)+
  geom_point(aes(y = -GPP_F*60*60*24*(1/1000000)*12, color = "GPP"))+
  geom_point(aes(y = RECO_F*60*60*24*(1/1000000)*12, color = "Respiration")) + 
  geom_line(aes(y = FC_F*60*60*24*(1/1000000)*12, color = "NEE"))+ # turbulent flux of CO2
  geom_line(aes(y = FCH4_F*60*60*24*(1/1000000000)*12*50, color = "CH4"))+ #multiply by 50 to help scale it so it shows up in the same figure as C, GPP, and Resp
  geom_hline(yintercept=0, col="black")+
  scale_y_continuous(
    name = expression('CO'[2]*' Flux (g C'~m^-2~d^-1*')'),
    limits = c(-6, 4),
  sec.axis = sec_axis(~ . / 50, name = expression('CH'[4]*' Flux (g C'~m^-2~d^-1*')')))+ #~.*1 or ~./ 50 notation in the code is used to scale the secondary axis 
  #when multiplying CH4 to scale it, make sure to do the opposite for when you scale the axis **--> example, if you multiply CH4 by 50 to get it visible on the same figure, divide the CH4 scale by 50 to take this scaling into account
  scale_color_manual(name = " ",
            values = c("GPP" = "navy", 
                      "Respiration" = "turquoise3", 
                      "NEE" = "salmon", 
                      "CH4" = "mediumorchid"),
            breaks = c("GPP", "Respiration", "NEE", "CH4"))+
  #labs(title = "GPP, Respiration, NEE, and Methane Fluxes: 2019", x = "Date") +
  labs(title = "2019", x = "Date") +
  
theme(axis.text = element_text(size = 20, face = "bold"),
        axis.title = element_text(size = 20, face = "bold"),
        plot.title = element_text(size = 20, face = "bold", hjust = 0.5))+
  
  #2019
 #vertical lines for specific events - 2019 - for AGU poster
  geom_vline(xintercept = as.POSIXct("2019-05-23"))+ #end of winter, DOY 143* 
  geom_vline(xintercept =  as.POSIXct("2019-08-30"))+ #end of growing season,DOY 242* 
  geom_vline(xintercept =  as.POSIXct("2019-10-10")) + #end of Fall Senescence, DOY 283*


 #Labels for each vertical line within figure
 annotate("text", size = 5, x = as.POSIXct("2019-03-05"), y = -6, label = "Winter", color = "black") +
 annotate("text", size = 5, x = as.POSIXct("2019-07-11"), y = -6, label = "Growing Season", color = "black") +
 annotate("text", size = 5, x = as.POSIXct("2019-10-01"), y = -6, label = "Senescence", color = "black") +
 annotate("text", size = 5, x = as.POSIXct("2019-12-16"), y = -6, label = "Winter", color = "black")
  
 annual_timeseries_2019_plot 
```

#2020
```{r}
annual_timeseries_2020_plot <- ggplot(data = df_avg_2020, aes(x=date))+
  theme_bw(base_size = 20)+
  geom_point(aes(y = -GPP_F*60*60*24*(1/1000000)*12, color = "GPP"))+
  geom_point(aes(y = RECO_F*60*60*24*(1/1000000)*12, color = "Respiration")) + 
  geom_line(aes(y = FC_F*60*60*24*(1/1000000)*12, color = "NEE"))+ # turbulent flux of CO2
  geom_line(aes(y = FCH4_F*60*60*24*(1/1000000000)*12*50, color = "CH4"))+ #multiply by 50 to help scale it so it shows up in the same figure as C, GPP, and Resp
  geom_hline(yintercept=0, col="black")+
  scale_y_continuous(
    name = expression('CO'[2]*' Flux (g C'~m^-2~d^-1*')'),
    limits = c(-6, 4),
  sec.axis = sec_axis(~ . / 50, name = expression('CH'[4]*' Flux (g C'~m^-2~d^-1*')')))+ #~.*1 or ~./ 50 notation in the code is used to scale the secondary axis 
  #when multiplying CH4 to scale it, make sure to do the opposite for when you scale the axis **--> example, if you multiply CH4 by 50 to get it visible on the same figure, divide the CH4 scale by 50 to take this scaling into account
  scale_color_manual(name = " ",
            values = c("GPP" = "navy", 
                      "Respiration" = "turquoise3", 
                      "NEE" = "salmon", 
                      "CH4" = "mediumorchid"),
            breaks = c("GPP", "Respiration", "NEE", "CH4"))+
  #labs(title = "GPP, Respiration, NEE, and Methane Fluxes: 2020", x = "Date") +
  labs(title = "2020", x = "Date") +
  
 theme(axis.text = element_text(size = 20, face = "bold"),
        axis.title = element_text(size = 20, face = "bold"),
        plot.title = element_text(size = 20, face = "bold", hjust = 0.5))+
  

  # #2020
  geom_vline(xintercept = as.POSIXct("2020-05-13"))+ #end of winter, DOY 134*
  geom_vline(xintercept =  as.POSIXct("2020-09-04"))+ #end of growing season, DOY 248*
  geom_vline(xintercept =  as.POSIXct("2020-10-25")) + #end of Fall Senescence, DOY 299*

 # Labels for each vertical line within figure
 annotate("text", size = 5, x = as.POSIXct("2020-03-01"), y = -6, label = "Winter", color = "black") +
 annotate("text", size = 5, x = as.POSIXct("2020-07-10"), y = -6, label = "Growing Season", color = "black") +
 annotate("text", size = 5, x = as.POSIXct("2020-10-10"), y = -6, label = "Senescence", color = "black") +
annotate("text", size = 5, x = as.POSIXct("2020-12-15"), y = -6, label = "Winter", color = "black")

 annual_timeseries_2020_plot 
```

#2021
```{r}

annual_timeseries_2021_plot <- ggplot(data = df_avg_2021, aes(x=date))+
  theme_bw(base_size = 20)+
  geom_point(aes(y = -GPP_F*60*60*24*(1/1000000)*12, color = "GPP"))+
  geom_point(aes(y = RECO_F*60*60*24*(1/1000000)*12, color = "Respiration")) + 
  geom_line(aes(y = FC_F*60*60*24*(1/1000000)*12, color = "NEE"))+ # turbulent flux of CO2
  geom_line(aes(y = FCH4_F*60*60*24*(1/1000000000)*12*50, color = "CH4"))+ #multiply by 50 to help scale it so it shows up in the same figure as C, GPP, and Resp
  geom_hline(yintercept=0, col="black")+
  scale_y_continuous(
    name = expression('CO'[2]*' Flux (g C'~m^-2~d^-1*')'),
    limits = c(-6, 4),
  sec.axis = sec_axis(~ . / 50, name = expression('CH'[4]*' Flux (g C'~m^-2~d^-1*')')))+ #~.*1 or ~./ 50 notation in the code is used to scale the secondary axis 
  #when multiplying CH4 to scale it, make sure to do the opposite for when you scale the axis **--> example, if you multiply CH4 by 50 to get it visible on the same figure, divide the CH4 scale by 50 to take this scaling into account
  scale_color_manual(name = " ",
            values = c("GPP" = "navy", 
                      "Respiration" = "turquoise3", 
                      "NEE" = "salmon", 
                      "CH4" = "mediumorchid"),
            breaks = c("GPP", "Respiration", "NEE", "CH4"))+
  #labs(title = "GPP, Respiration, NEE, and Methane Fluxes: 2021", x = "Date") +
  labs(title = "2021", x = "Date") +
  
theme(axis.text = element_text(size = 20, face = "bold"),
        axis.title = element_text(size = 20, face = "bold"),
        plot.title = element_text(size = 20, face = "bold", hjust = 0.5))+
  
   #2021
  # vertical lines for specific events
  geom_vline(xintercept = as.POSIXct("2021-05-21"))+ #end of winter, DOY 141 
  geom_vline(xintercept =  as.POSIXct("2021-09-11"))+ #end of growing season, DOY 254
  geom_vline(xintercept =  as.POSIXct("2021-10-09")) + #end of Fall Senescence, DOY 282

# Labels for each vertical line within figure
annotate("text", size = 5, x = as.POSIXct("2021-03-01"), y = -6, label = "Winter", color = "black") +
annotate("text", size = 5, x = as.POSIXct("2021-07-10"), y = -6, label = "Growing Season", color = "black") +
annotate("text", size = 5, x = as.POSIXct("2021-10-10"), y = -6, label = "Senescence", color = "black") +
annotate("text", size = 5, x = as.POSIXct("2021-12-15"), y = -6, label = "Winter", color = "black")
  
 annual_timeseries_2021_plot 
```

#2022
```{r}

annual_timeseries_2022_plot <- ggplot(data = df_avg_2022, aes(x=date))+
  theme_bw(base_size = 20)+
  geom_point(aes(y = -GPP_F*60*60*24*(1/1000000)*12, color = "GPP"))+
  geom_point(aes(y = RECO_F*60*60*24*(1/1000000)*12, color = "Respiration")) + 
  geom_line(aes(y = FC_F*60*60*24*(1/1000000)*12, color = "NEE"))+ # turbulent flux of CO2
  geom_line(aes(y = FCH4_F*60*60*24*(1/1000000000)*12*50, color = "CH4"))+ #multiply by 50 to help scale it so it shows up in the same figure as C, GPP, and Resp
  geom_hline(yintercept=0, col="black")+
  scale_y_continuous(
    name = expression('CO'[2]*' Flux (g C'~m^-2~d^-1*')'),
    limits = c(-6, 4),
  sec.axis = sec_axis(~ . / 50, name = expression('CH'[4]*' Flux (g C'~m^-2~d^-1*')')))+ #~.*1 or ~./ 50 notation in the code is used to scale the secondary axis 
  #when multiplying CH4 to scale it, make sure to do the opposite for when you scale the axis **--> example, if you multiply CH4 by 50 to get it visible on the same figure, divide the CH4 scale by 50 to take this scaling into account
  scale_color_manual(name = " ",
            values = c("GPP" = "navy", 
                      "Respiration" = "turquoise3", 
                      "NEE" = "salmon", 
                      "CH4" = "mediumorchid"),
            breaks = c("GPP", "Respiration", "NEE", "CH4"))+
 # labs(title = "GPP, Respiration, NEE, and Methane Fluxes: 2022", x = "Date") +
  labs(title = "2022", x = "Date") +
  
theme(axis.text = element_text(size = 20, face = "bold"),
        axis.title = element_text(size = 20, face = "bold"),
        plot.title = element_text(size = 20, face = "bold", hjust = 0.5))+
  
# #2022
  # vertical lines for specific events
  geom_vline(xintercept = as.POSIXct("2022-05-22"))+ #end of winter, DOY 142 
  geom_vline(xintercept =  as.POSIXct("2022-09-06"))+ #end of growing season, DOY 249
  geom_vline(xintercept =  as.POSIXct("2022-10-7")) + #end of Fall Senescence, DOY 280*

# Labels for each vertical line within figure
annotate("text", size = 5, x = as.POSIXct("2022-03-01"), y = -6, label = "Winter", color = "black") +
annotate("text", size = 5, x = as.POSIXct("2022-07-10"), y = -6, label = "Growing Season", color = "black") +
annotate("text", size = 5, x = as.POSIXct("2022-10-07"), y = -6, label = "Senescence", color = "black") +
annotate("text", size = 5, x = as.POSIXct("2022-12-15"), y = -6, label = "Winter", color = "black")

 annual_timeseries_2022_plot 
 
```

#2023 - skipping due to incomplete data 
```{r}
  annual_timeseries_2023_plot <- ggplot(data = df_avg_2023, aes(x=date))+
  theme_bw(base_size = 20)+
  geom_point(aes(y = -GPP_F*60*60*24*(1/1000000)*12, color = "GPP"))+
  geom_point(aes(y = RECO_F*60*60*24*(1/1000000)*12, color = "Respiration")) + 
  geom_line(aes(y = FC_F*60*60*24*(1/1000000)*12, color = "NEE"))+ # turbulent flux of CO2
  geom_line(aes(y = FCH4_F*60*60*24*(1/1000000000)*12*50, color = "CH4"))+ #multiply by 50 to help scale it so it shows up in the same figure as C, GPP, and Resp
  geom_hline(yintercept=0, col="black")+
  scale_y_continuous(
    name = expression('CO'[2]*' Flux (g C'~m^-2~d^-1*')'),
    limits = c(-6, 4),
  sec.axis = sec_axis(~ . / 50, name = expression('CH'[4]*' Flux (g C'~m^-2~d^-1*')')))+ #~.*1 or ~./ 50 notation in the code is used to scale the secondary axis 
  #when multiplying CH4 to scale it, make sure to do the opposite for when you scale the axis **--> example, if you multiply CH4 by 50 to get it visible on the same figure, divide the CH4 scale by 50 to take this scaling into account
  scale_color_manual(name = " ",
            values = c("GPP" = "navy", 
                      "Respiration" = "turquoise3", 
                      "NEE" = "salmon", 
                      "CH4" = "mediumorchid"),
            breaks = c("GPP", "Respiration", "NEE", "CH4"))+
  labs(title = "GPP, Respiration, NEE, and Methane Fluxes: 2023", x = "Date") +
  
     theme(axis.text = element_text(size = 12, face = "bold"),
        axis.title = element_text(size = 14, face = "bold"),
        plot.title = element_text(size = 16, face = "bold", hjust = 0.5))+
  
   #2023
  # vertical lines for specific events
  geom_vline(xintercept = as.POSIXct("2023-06-06"))+ #end of winter, DOY 157
  geom_vline(xintercept =  as.POSIXct("2023-08-24"))+ #end of growing season-->not enough to estimate (?)
  #geom_vline(xintercept =  as.POSIXct("2023-10-7")) + #end of Fall Senescence, not enough to estimate
     #geom_vline(xintercept =  as.POSIXct("2023-06-12"))+ #end of snowmelt, DOY 163

# Labels for each vertical line within figure
annotate("text", size = 5, x = as.POSIXct("2023-03-01"), y = -6, label = "Winter", color = "black") +
annotate("text", size = 5, x = as.POSIXct("2023-07-10"), y = -6, label = "Growing Season", color = "black") +
#annotate("text", size = 3, x = as.POSIXct("2023-08-24"), y = -6, label = "Senescence", color = "black") +
# annotate("text", size = 3, x = as.POSIXct("2023-12-15"), y = -6, label = "Winter", color = "black") +
 annotate("text", size = 5, x = as.POSIXct("2023-09-15"), y = -3, label = "End of Data (9/1/2023)", color = "black", angle = 90)

   
 annual_timeseries_2023_plot 

```

#save timeseries plot 
```{r}
ggsave("C:/Users/kkent/Documents/Github Flux Network/Council_Flux_Analysis_Paper/Council Figures/annual_timeseries_2022_plot.2.png", annual_timeseries_2022_plot, 
       width = 12, height = 7 , dpi = 600)


#or 

# ggsave(
#   filename = "C:/Users/kkent/Documents/Github Flux Network/Council_Flux_Analysis_Paper/Council Figures/annual_timeseries_2017_plot.2.png",  # File name and extension
#   plot = annual_timeseries_2017_plot,        # The plot to save (default is the last plot created)
#   width = 20,                 # Width in inches
#   height = 15,                # Height in inches
#   dpi = 600,                 # Resolution in dots per inch
#   units = "cm"               # Units for width and height (can be "in", "cm", or "mm")
# )

```



#Arrange timeseries figures into a grid to save as single figure
```{r}
# Install if you don't have it
 #install.packages("patchwork")
library(patchwork)

# Arrange plots in two columns (3 rows x 2 columns) 
combined_plot <- (annual_timeseries_2017_plot + annual_timeseries_2018_plot) /
                 (annual_timeseries_2019_plot + annual_timeseries_2020_plot) /
                 (annual_timeseries_2021_plot + annual_timeseries_2022_plot) +
                 plot_layout(guides = "collect") # Collects all legends into one

# Add a common title if desired
combined_plot <- combined_plot & 
  plot_annotation(
    title = "GPP, Respiration, NEE, and Methane Fluxes (2017-2022)",
    theme = theme(plot.title = element_text(size = 20, face = "bold", hjust = 0.5))
  ) &
  
  # Increase legend text size, key size, and spacing
  theme(
    #legend.title = element_text(size = 14),    # Increase legend title size
    legend.text = element_text(size = 20, face = "bold"),     # Increase legend text size
    legend.key.size = unit(2, "cm"),         # Increase the size of the legend keys/symbols - doesn't seem to work
    legend.key.width = unit(3, "cm"),        # Make keys wider for line symbols - doesn't work
    legend.key.height = unit(3, "cm"),       # Control height separately - doesnt work
    #legend.spacing = unit(0.1, "cm"),          # Add more spacing between legend items
    #legend.margin = margin(10, 10, 10, 10)     # Add margin around the legend
    legend.position = "bottom",
    legend.box = "horizontal",
  
  )

combined_plot

```

#save combined plot 
```{r}
# Then save it
ggsave("C:/Users/kkent/Documents/Github Flux Network/Council_Flux_Analysis_Paper/Council Figures/combined_annual_timeseries2.png", combined_plot, width = 20, height = 20, dpi = 600)

```




# Gap Filling vs Site Data Plot

Shows gap in flux data and compares gap filled and non-gap filled data

```{r}
#Uses Half-Hourly data - units of umol/m^2/s

#have to tell R what format the timestamp is in so it can parse out the dates 
df_2023$TIMESTAMP <- as.POSIXct(df_2023$TIMESTAMP, format="%Y-%m-%d %H:%M:%S")

#plot half-hourly FCO2 data with the gap-filled data to compare 
ggplot(data = df_2023)+
  geom_hline(yintercept = 0)+
  geom_point(aes(TIMESTAMP,FC_F,col='RF Gapfilled'))+
  geom_point(aes(TIMESTAMP,FC,col='Original'))+
  scale_y_continuous(limits=c(-10,10))+
  scale_x_datetime(limits = as.POSIXct(c('2023-01-01','2023-12-01')))+ 
  labs(#y = "CO2 Flux (umol/m2/s) ", 
       y = expression(CO[2]~Flux~(umolCO[2]~m^-2~y^-1)),
       x = "Time") +
  scale_color_manual(values=c('black','red'))+
  theme_bw()+
  #geom_vline(xintercept = as.POSIXct("2023-07-05"))+
  labs(title = "Random Forest Gapfill vs Site Data: 2023")


#plot half-hourly FCH4 data with the gap-filled data to compare 
ggplot(data = df_2023)+
  geom_hline(yintercept = 0)+
  geom_point(aes(TIMESTAMP,FCH4_F,col='RF Gapfilled'))+
  geom_point(aes(TIMESTAMP,FCH4,col='Original'))+
  #scale_y_continuous(limits=c(-10,10))+
  scale_x_datetime(limits = as.POSIXct(c('2023-01-01','2023-12-01')))+ 
  labs(#y = "FCH4 Flux (nmol/m2/s)"
        y = expression(CH[4]~Flux~(nmolCH[4]~m^-2~y^-1)),
        x = "Time") +
  scale_color_manual(values=c('black','red'))+
  theme_bw()+
  #geom_vline(xintercept = as.POSIXct("2023-07-05"))+
  labs(title = "Random Forest Gapfill vs Site Data: 2023")



#plot half-hourly FCH4 across all years 
ggplot(data = df)+
  geom_hline(yintercept = 0)+
  geom_point(aes(date,FCH4_F,col='RF Gapfilled'))+
  geom_point(aes(date,FCH4,col='Original'))+
  #scale_y_continuous(limits=c(-10,10))+
  #scale_x_datetime(limits = as.POSIXct(c('2023-01-01','2023-12-01')))+ 
  labs(#y = "FCH4 Flux (nmol/m2/s)"
        y = expression(CH[4]~Flux~(nmolCH[4]~m^-2~y^-1)),
        x = "Time") +
  scale_color_manual(values=c('black','red'))+
  theme_bw()+
  #geom_vline(xintercept = as.POSIXct("2023-07-05"))+
  labs(title = "Random Forest Gapfill vs Site Data")
    
```

# % data coverage vs missing 

# Percent of data coverage vs no coverage for methane (observed daily avg FCH4) & FC  (by year and by winter)
```{r}
# Load required libraries
library(dplyr)
library(lubridate)

# Calculate FCH4 data coverage by year
fch4_coverage <- df_avg %>%
  mutate(year = year(date)) %>%
  filter(year >= 2017 & year <= 2023) %>%
  filter(season == "Winter") %>% #comment out for whole year results 
  group_by(year) %>%
  summarise(
    total_days = n(),
    measured_days = sum(!is.na(FCH4)),
    missing_days = sum(is.na(FCH4)),
    coverage_percent = round((measured_days / total_days) * 100, 1),
    missing_percent = round((missing_days / total_days) * 100, 1),
    .groups = 'drop'
  ) %>%
  arrange(year)

# Display the results
print("FCH4 Data Coverage by Year:")
print(fch4_coverage)

# ============ FC ================================

# Calculate FC data coverage by year
fc_coverage <- df_avg %>%
  mutate(year = year(date)) %>%
  filter(year >= 2017 & year <= 2023) %>%
  filter(season == "Winter") %>% #comment out for whole year results 
  group_by(year) %>%
  summarise(
    total_days = n(),
    measured_days = sum(!is.na(FC)),
    missing_days = sum(is.na(FC)),
    coverage_percent = round((measured_days / total_days) * 100, 1),
    missing_percent = round((missing_days / total_days) * 100, 1),
    .groups = 'drop'
  ) %>%
  arrange(year)

# Display the results
print("FC Data Coverage by Year:")
print(fc_coverage)

df_winter2017_FC <- df_avg %>%
  filter(year == "2017" & season == "Winter")

```


# Annual Net C Budget - converting units and checking sums 

_no_NAs is used for other years of data where NAs are present in gapfilled data

```{r}
#checking the budgets with the sum function to double check the results of the bar plots in code chunk below 

# Net CO2 Flux - multiply by 30 to represent per half hour --> can use this with "sum" function to double check the results of the plots for the yearly budgets 
df_2023 <- df_2023 %>%
  mutate(FC_F_no_NAs = ifelse(is.na(FC_F), 0, FC_F * 60 * 30* (1/1000000) * 12))
#sum of the flux 
sum(df_2023$FC_F_no_NAs)

#Net CH4 flux --> to check results of bar plots with the sum function
df_2023 <- df_2023 %>%
  mutate(FCH4_F_no_NAs = ifelse(is.na(FCH4_F), 0, FCH4_F*60*30*(1/1000000000)*12))
#sum - yearly budget 
sum(df_2023$FCH4_F_no_NAs)



#comparing to results from prev dataset, using SWC_1 

# Net CO2 Flux - multiply by 30 to represent per half hour --> can use this with "sum" function to double check the results of the plots for the yearly budgets 
df_2017orig <- df_2017orig %>%
  mutate(FC_F_no_NAs = ifelse(is.na(FC_F), 0, FC_F * 60 * 30* (1/1000000) * 12))
#sum of the flux 
sum(df_2017orig$FC_F_no_NAs)

#Net CH4 flux --> to check results of bar plots with the sum function
df_2017orig <- df_2017orig %>%
  mutate(FCH4_F_no_NAs = ifelse(is.na(FCH4_F), 0, FCH4_F*60*30*(1/1000000000)*12))
#sum - yearly budget 
sum(df_2017orig$FCH4_F_no_NAs)
```

#### Net C Budgets: Annual bar plot
```{r}
#Creates numeric timestamp with the unit of minutes to integrate over half-hourly data

#this references the half hourly increments and takes the diff (so 30 min increments)
df_2019 <- df_2019 %>%
  mutate(time_minutes = as.numeric(difftime(TIMESTAMP, min(TIMESTAMP), units = "mins")))
df_2019$TIMESTAMP

# Units start as micro-moles of CO2/(m^2/s), converted to Grams of C/m^2/minute, integrated over minutes to get Grams of C/m^2

#creating new column of net C budget in order to make the annual budget bar plots
#net CO2 
df_2019 <- df_2019 %>%
  mutate(FC_F_no_NAs = ifelse(is.na(FC_F), 0, FC_F * 60 * (1/1000000) * 12))

#Net CO2 flux in g/m2
net_CO2 <- trapz(df_2019$time_minutes, df_2019$FC_F_no_NAs)

# Units start as nano-moles of CH4/(m^2/s), converted to Grams of C/m^2/minute, integrated over minutes to get Grams of C/m^2

#Net CH4 Flux
df_2019 <- df_2019 %>%
  mutate(FCH4_F_no_NAs = ifelse(is.na(FCH4_F), 0, FCH4_F*60*(1/1000000000)*12))


net_CH4 <- trapz(df_2019$time_minutes, df_2019$FCH4_F_no_NAs)

# Used IPCC Sixth Assessment Report (AR6) global warming potentials, 100 year time period - could use paper gwp* or delta equation for future analysis

net_CH4_CO2e <- net_CH4*27.2
sum = net_CO2+net_CH4


#Dataframe created to generate bar graph
net_wp_2019 <- data.frame(
  Category = c("CO2", "CH4", "Total"),
  Value = c(round(net_CO2, 2), round(net_CH4, 2), round(sum, 2) 
))

#Plot here

annual_Cbudget_2019 <- ggplot(net_wp_2019, aes(x = Category, y = Value)) +
  theme_bw()+
  geom_bar(stat = "identity", position = "dodge", fill = "turquoise3") +
  geom_hline(yintercept=0, colour = "black")+
  labs(
    x = "",
    #y = expression(FCH4~(gCH[4]-C/m^2/s)),
    y = expression(Net~Carbon~Flux~(gC~m^-2~y^-1))) +
  geom_label(aes(label = Value), vjust = ifelse(net_wp_2019$Value >= 0, -0.7, 1.5), colour = "black", fill ="white")+
  scale_y_continuous(
     #breaks = seq(-5, 5, 1.5),  # changing for 2019 
   # limits = c(-2, 5))+ #changing for year 2019
      breaks = seq(-80, 20, 10),  # Set limits for the primary axis - other years go up to -73
    limits = c(-80, 50))+ 
  labs(title = "Cumulative Annual Carbon Budget for 2019") +#for 2019
#labs(title = "2019")
   theme(
    axis.title.x = element_text(size = 16, face = "bold"),  # Make x-axis title larger and bold
    axis.title.y = element_text(size = 16, face = "bold"),  # Make y-axis title larger and bold
    axis.text.x = element_text(size = 14, face = "bold"),   # Make x-axis text larger and bold
    axis.text.y = element_text(size = 14, face = "bold")    # Make y-axis text larger and bold
  )# +
  
#coord_fixed(ratio = 0.6) #for making small 2019 fig 

annual_Cbudget_2019

```


#save image to maintain dimensions and resolution  
```{r}
ggsave(
  filename = "Annual_Cbudget_2019.png",  # File name and extension
  plot = annual_Cbudget_2019 ,        # The plot to save (default is the last plot created)
  width = 5,                 # Width in inches
  height = 3,                # Height in inches
  dpi = 600,                 # Resolution in dots per inch
  units = "cm"               # Units for width and height (can be "in", "cm", or "mm")
)

#ggsave("my_plot.pdf", width = 8, height = 6, dpi = 300, units = "in")
```

#Daily avg sum for each month per year - Net C budget

```{r}
#If using the daily avg data from the timeAverage daily dataframe 

#convert from umol CO2/m2/s to gCO2/m2/day
df_avg_2019 <- df_avg_2019 %>%
  mutate(FC_F_no_NAs = ifelse(is.na(FC_F), 0, FC_F * 60 * 60 * 24 * (1/1000000) * 12))

#convert from nano-mol CH4/m2/s to gCH4/m2/day
df_avg_2019 <- df_avg_2019 %>%
  mutate(FCH4_F_no_NAs = ifelse(is.na(FCH4_F), 0, FCH4_F * 60 * 60 * 24 * (1/1000000000) * 12))

# Ensure the 'date' column is in Date format if it isn't already
#df_avg_2019$date <- as.Date(df_avg_2019$date)

# Extract the year and month to create a grouping column
df_avg_2019$year_month <- format(df_avg_2019$date, "%Y-%m")

# Calculate the sum of carbon emissions (g C/m²/month) for each month - this is not working now...
monthly_CO2sum_2019 <- aggregate(FC_F_no_NAs ~ year_month, data = df_avg_2019, sum, na.rm = TRUE)
monthly_CH4sum_2019 <- aggregate(FCH4_F_no_NAs ~ year_month, data = df_avg_2019, sum, na.rm = TRUE)

# View the resulting dataframe with monthly sums
# monthly_CO2sum_2019
# monthly_CH4sum_2019

#To find monthly sum of CO2 and CH4 together 
# Calculate the sum of carbon emissions (g C/m²/month) and methane emissions (g CH4/m²/month) for each month
monthly_Cflux_sum_2019 <- aggregate(cbind(FC_F_no_NAs, FCH4_F_no_NAs) ~ year_month, data = df_avg_2019, sum, na.rm = TRUE)

# View the resulting dataframe with monthly sums
monthly_Cflux_sum_2019

#save table of monthly C flux budgets per year 
#write.csv(monthly_Cflux_sum_2019, file = "monthly_Cflux_sum_2019.csv", row.names = FALSE)

#double check the monthly sums 
#extract month
df_avg_2019$month <- as.numeric(format(df_avg_2019$date, "%m"))
 
#filter out by month - October = 10
sum_october_2019 <- df_avg_2019[month == 10, .(monthly_sum = sum(FC_F_no_NAs, na.rm = TRUE))]

# Print the result
sum_october_2019

#sum - check sum to match yearly budget 
sum(df_avg_2019$FC_F_no_NAs)
sum(df_avg_2019$FCH4_F_no_NAs)

```


#### Net C Budgets per month bar plot 
```{r}
# Load necessary libraries for reshaping datasets 
library(ggplot2)
library(tidyr)
library(dplyr)

#CH4 warming potential --> Used IPCC Sixth Assessment Report (AR6) global warming potentials of CH4 compared to CO2, 100 year time period 
# monthly_Cflux_sum_2022 <- monthly_Cflux_sum_2022 %>%
#   mutate(CH4_CO2e = FCH4_F_no_NAs*27.2) 


# Extract the month name from the year_month column
monthly_Cflux_sum_2019$month_name <- format(as.Date(paste0(monthly_Cflux_sum_2019$year_month, "-01")), "%B")

#sum of CO2 and CH4 fluxes
monthly_Cflux_sum_2019 <- monthly_Cflux_sum_2019 %>%
  mutate(total_Cflux = FC_F_no_NAs + FCH4_F_no_NAs)

#reshape the df into a long format so you can plot CO2, CH4, and the sum per month on the same figure 
# # Reshape the data to a long format
# monthly_Cflux_sum_2019_long <- monthly_Cflux_sum_2019 %>%
#   pivot_longer(cols = c(FC_F_no_NAs, FCH4_F_no_NAs, total_Cflux), 
#                names_to = "Flux_Type", 
#                values_to = "Flux_Sum")

# Bar graph --> methane very small here so see code below for a scaled fig 
# ggplot(monthly_Cflux_sum_2019_long, aes(x = factor(month_name, levels = month.name), y = Flux_Sum, fill = Flux_Type)) +
#   geom_bar(stat = "identity", position = "dodge") +
#   scale_fill_manual(values = c("FC_F_no_NAs" = "turquoise", "FCH4_F_no_NAs" = "salmon", "total_Cflux" = "grey")) +
#   labs(x = "Month", y = "C Flux (g/m²/month)", 
#        title = "Monthly CO2 and CH4 Flux Sums for 2019",
#        fill = "C flux") +
#   theme_minimal() +
#   theme(axis.text.x = element_text(angle = 45, hjust = 1))


#Methane is very small compared to CO2, so make a scaling factor and new fig with a secondary axis 
# Scale the methane values (FCH4_F_no_NAs) by a factor, e.g., 100
scaling_factor <- 30
monthly_Cflux_sum_2019$FCH4_scaled <- monthly_Cflux_sum_2019$FCH4_F_no_NAs * scaling_factor

# Reshape the data to a long format
monthly_Cflux_sum_2019_long <- monthly_Cflux_sum_2019 %>%
  select(-FCH4_F_no_NAs) %>% # Exclude the unwanted column
  pivot_longer(cols = c(FC_F_no_NAs, total_Cflux, FCH4_scaled), 
               names_to = "Flux_Type", 
               values_to = "Flux_Sum")

# Create the bar graph with a scaled FCH4_F_N_no_NAs
monthlyC_2019_barplot <- ggplot(monthly_Cflux_sum_2019_long, aes(x = factor(month_name, levels = month.name), y = Flux_Sum, fill = Flux_Type)) +
  geom_bar(stat = "identity", position = "dodge") +
  scale_fill_manual(
    values = c("FC_F_no_NAs" = "turquoise", "FCH4_scaled" = "salmon", "total_Cflux" = "grey"),
    labels = c("FC_F_no_NAs" = "CO2 Flux",
               "FCH4_scaled" = "CH4 Flux",
               "total_Cflux" = "Total C Flux"))+
    # Primary y-axis for CO2 and scaled methane on the secondary axis
  scale_y_continuous(
    #name = "CO2 Flux (g C/m²/month)", 
    name = expression(CO[2]~Flux~(gC~m^-2~month^-1)),
       breaks = seq(-50, 30, 5),  # Set limits for the primary axis
    limits = c(-50, 30),  # Explicitly set limits for the primary axis
    sec.axis = sec_axis(~ . / scaling_factor, name = expression(Methane~Flux~(gC~m^-2~month^-1)),breaks = seq(-1, 1, 0.25))
  ) +
    #y = expression(CH[4]~Flux~(nmolCH[4]~m^-2~y^-1)),
  labs(x = "Month", y = "C Flux (g/m²/month)", 
       title = "Monthly C Fluxes for 2019",
       #title = "Monthly CO2 and CH4 Flux Sums for 2019",
       fill = "C flux") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        axis.text = element_text(size = 10, face = "bold"),
        axis.title = element_text(size = 14, face = "bold"),
        plot.title = element_text(size = 16, face = "bold", hjust = 0.5))

monthlyC_2019_barplot 

```


#save image to maintain dimensions 
```{r}
#save image
ggsave("C:/Users/kkent/Documents/Github Flux Network/Council_Flux_Analysis_Paper/Council Figures/monthlyC_2019_barplot .png", monthlyC_2019_barplot, 
       width = 10, height = 7, dpi = 600)


#Other way to save if more metrics are required
ggsave(
  filename = "monthlyC_2019_barplot .png",  # File name and extension
  plot = monthlyC_2019_barplot ,        # The plot to save (default is the last plot created)
  width = 20,                 # Width in inches
  height = 15,                # Height in inches
  dpi = 600,                 # Resolution in dots per inch
  units = "cm"               # Units for width and height (can be "in", "cm", or "mm")
)

#ggsave("my_plot.pdf", width = 8, height = 6, dpi = 300, units = "in")
```



#Comparing gapfilled to non-gapfilled with boxplot

```{r}
# Create the boxplot from HH data plotting FC_no NAs and FC_F_no NAs to compare original to gap-filled data 

#create a new d_long df so it can plot the FC and FC_F_no NA variables side by side 
# Reshape the data to long format with columns for datatype (FC vs FC_F_no NAs)
df_2017long <- df_2017 %>%
  pivot_longer(cols = c(FC_no_NAs, FC_F_no_NAs), names_to = "DataType", values_to = "CO2flux")

df_2017long2 <- df_2017 %>%
  pivot_longer(cols = c(FCH4_no_NAs, FCH4_F_no_NAs), names_to = "DataType", values_to = "CH4emissions")
 

# Create the boxplot for CO2
ggplot(df_2017long, aes(x = as.factor(month), y = CO2flux, fill = DataType)) +
  geom_boxplot(position = position_dodge(width = 0.8)) +
  labs(x = "Month", y = "HH FC (g C"~m^-2~HH^-1*")", 
       title = "HH FC_no NAs vs FC_F_no NAs Carbon Emissions (2017)", 
       fill = "Data Type") +
  theme_minimal()

# Create the boxplot for FCH4 vs FCH4_F no NAs --> won't work, won't do FCH4 no NAs ** review code
ggplot(df_2017long, aes(x = as.factor(month), y = CH4emissions, fill = DataType)) +
  geom_boxplot(position = position_dodge(width = 0.8)) +
  labs(x = "Month", y = "HH FCH4 (g C"~m^-2~HH^-1*")", 
       title = "HH FCH4_no NAs vs FCH4_F_no NAs Carbon Emissions (2017)", 
       fill = "Data Type") +
  theme_minimal()

#boxplot for just FCH4_F_no NAs
ggplot(df_2017, aes(x = as.factor(month), y = FCH4_F_no_NAs)) +
  geom_boxplot(position = position_dodge(width = 0.8)) +
  labs(x = "Month", y = "HH FCH4_F_no NAs (g C"~m^-2~HH^-1*")", 
       title = "HH FCH4_no NAs vs FCH4_F_no NAs Carbon Emissions (2017)", 
       fill = "Data Type") +
  theme_minimal()

```


#Boxplot of daily avg (df_avg) C per month for every year 

```{r}
#Creating boxplot from daily avg -- only need to convert if you haven't yet already for the daily averages - if yes, skip down to extracting the month as a numeric value

#convert CO2 data from umolC/m2/s to gC/m2/day 
#net CO2 flux - gapfilled
df_avg_2023 <- df_avg_2023 %>%
  mutate(FC_F_no_NAs = ifelse(is.na(FC_F), 0, FC_F * 60 * 60 * 24* (1/1000000) * 12))
#net CO2 flux not gapfilled
df_avg_2023 <- df_avg_2023 %>%
  mutate(FC_no_NAs = ifelse(is.na(FC), 0, FC * 60 * 60 * 24 * (1/1000000) * 12))


# CH4 Units start as nano-moles of CH4/(m^2/s), converted to gC/m^2/day
#Net CH4 Flux - gapfilled
df_avg_2023 <- df_avg_2023 %>%
  mutate(FCH4_F_no_NAs = ifelse(is.na(FCH4_F), 0, FCH4_F * 60 * 60 * 24 * (1/1000000000) * 12))
#net CH4 flux not gapfilled
df_avg_2023 <- df_avg_2023 %>%
  mutate(FCH4_no_NAs = ifelse(is.na(FCH4), 0, FCH4 * 60 * 60 * 24* (1/1000000000) * 12))

###############################################

# Extract the month as a numeric value
df_avg_2023$month <- format(df_avg_2023$date, "%m") 


# Create the boxplot from gapfilled data - CO2
ggplot(df_avg_2023, aes(x = as.factor(month), y = FC_F_no_NAs)) +
  geom_boxplot() +
  labs(x = "Month", y = "FC_F_no NAs (g C"~m^-2~d^-1*")", title = "Avg daily FC_F Emissions per Month (2023)") +
  theme_minimal()+
  geom_hline(yintercept=0)


# Create the boxplot from gapfilled data - CH4
ggplot(df_avg_2023, aes(x = as.factor(month), y = FCH4_F_no_NAs)) +
  geom_boxplot() +
  labs(x = "Month", y = "FCH4_F_no NAs (g C"~m^-2~d^-1*")", title = "Avg daily CH4_F Emissions per Month (2023)") +
  theme_minimal()+
  geom_hline(yintercept=0)

#just checking sums here 
# Filter the dataframe for October 2023 and calculate the sum of FC_F_no NAs
sum_october_2023 <- sum(df_avg_2023$FC_F_no_NAs[format(df_avg_2023$date, "%Y-%m") == "2023-10"], na.rm = TRUE)
# Print the result
sum_october_2023

#find avg daily emission of g C by month
avg_dec_2023 <- mean(df_avg_2023$FC_F_no_NAs[format(df_avg_2023$date, "%Y-%m") == "2023-12"], na.rm = TRUE)
avg_dec_2023

```



#Dailv avg boxplot of gapfilled vs not gapfilled
```{r}
# Create the boxplot plotting FC_no NAs and FC_F_no NAs to compare original to gap-filled data 

#create a new d_long df so it can plot the FC and FC_F_no NA variables side by side 
# Reshape the data to long format with columns for datatype (FC vs FC_F_no NAs)
df_avg_2017long <- df_avg_2017 %>%
  pivot_longer(cols = c(FC_no_NAs, FC_F_no_NAs), names_to = "DataType", values_to = "CO2flux")

df_avg_2017long2 <- df_avg_2017 %>%
  pivot_longer(cols = c(FCH4_no_NAs, FCH4_F_no_NAs), names_to = "DataType", values_to = "CH4emissions")


# Create the boxplot for CO2 - gapfilled vs not 
ggplot(df_avg_2017long, aes(x = as.factor(month), y = CO2flux, fill = DataType)) +
  geom_boxplot(position = position_dodge(width = 0.8)) +
  labs(x = "Month", y = "HH FC (g C"~m^-2~d^-1*")", 
       title = "FC_no NAs vs FC_F_no NAs Carbon Emissions (2017)", 
       fill = "Data Type") +
  theme_minimal()

# Create the boxplot for FCH4 vs FCH4_F no NAs --> won't work, won't do FCH4 no NAs ** review code
ggplot(df_avg_2017long, aes(x = as.factor(month), y = CH4emissions, fill = DataType)) +
  geom_boxplot(position = position_dodge(width = 0.8)) +
  labs(x = "Month", y = "HH FCH4 (g C"~m^-2~d^-1*")", 
       title = "HH FCH4_no NAs vs FCH4_F_no NAs Carbon Emissions (2017)", 
       fill = "Data Type") +
  theme_minimal()

#boxplot for just FCH4_F_no NAs
ggplot(df_avg_2017, aes(x = as.factor(month), y = FCH4_F_no_NAs)) +
  geom_boxplot(position = position_dodge(width = 0.8)) +
  labs(x = "Month", y = "HH FCH4_F_no NAs (g C"~m^-2~d^-1*")", 
       title = "HH FCH4_no NAs vs FCH4_F_no NAs Carbon Emissions (2017)", 
       fill = "Data Type") +
  theme_minimal()
```



# TO DO: Seasonal Correlations

correlation between variables in growing season

```{r}

df_growing_avg_2023 <- filter(df_avg_2023, season == "Growing Season")

cor(df_growing_avg_2023$FC_F, df_growing_avg_2023$TA)


```




# Seasonal Budgets

Use half-hourly data to calculate net co2 budgets by season Average rate per day

## NEE************************

Finds the net CO2 exchange of each season as defined above

```{r}
seasonal_integrals <- function(df_2022) {
  
  # Calculate integral (sum) for each season
  integrals <- df_2022 %>%
    group_by(season) %>%
    summarise(integral_value = sum(FC_F, na.rm = TRUE)) %>%
    ungroup() %>%
    arrange(season)
  
  
  # Changes units from  Micromoles of CO2/((m^2)s) to Grams of C/m^2, and rounds
    integrals$integral_value = 
      round(integrals$integral_value*60*30*(1/1000000)*12, 2)
  
  return(integrals)
}

seasonal_integrals_2022 <- seasonal_integrals(df_2022)

#reorders seasons to timeline order
seasonal_integrals_2022$season <- factor(seasonal_integrals_2022$season, levels = c("Growing Season", "Fall Senescence", "Winter"))

seasonal_2022 <-ggplot(seasonal_integrals_2022, aes(x = season, y = integral_value)) +
  theme_bw()+
  geom_hline(yintercept=0, colour="black")+
  geom_bar(stat = "identity", position = "dodge", fill = "turquoise3") +
  labs(
    x = " ",
    y = expression("Net CO"[2] * " Flux (g C m"^-2*")"),
    title = expression("Net CO"[2] * " Flux by Season: 2022")
  ) +
  geom_label(aes(label = integral_value), vjust = ifelse(seasonal_integrals_2022$integral_value >= 0, -0.7, 1.5), colour = "black", fill ="white")+
  scale_y_continuous(limits=c(-200, 200)) +
  theme(
    axis.title.x = element_text(size = 16, face = "bold"),  # Make x-axis title larger and bold
    axis.title.y = element_text(size = 16, face = "bold"),  # Make y-axis title larger and bold
    axis.text.x = element_text(size = 14, face = "bold"),   # Make x-axis text larger and bold
    axis.text.y = element_text(size = 14, face = "bold")    # Make y-axis text larger and bold
  )

seasonal_2022
```


#save image to maintain dimensions 
```{r}
ggsave(
  filename = "SeasonalCO2_Trends_2022.png",  # File name and extension
  plot = seasonal_2022,        # The plot to save (default is the last plot created)
  width = 15,                 # Width in inches
  height = 10,                # Height in inches
  dpi = 600,                 # Resolution in dots per inch
  units = "cm"               # Units for width and height (can be "in", "cm", or "mm")
)

#ggsave("my_plot.pdf", width = 8, height = 6, dpi = 300, units = "in")
```


#TO DO 


## GPP

Finds the net GPP of each season

```{r}
# Bar graph showing growing season vs. year round analysis
# Change GPP to negative to show dynamics in budget


seasonal_integrals <- function(df) {
  
  # Calculate integral (sum) for each season
  integrals <- df %>%
    group_by(season) %>% 
    summarise(integral_value = sum(GPP_F, na.rm = TRUE)) %>%
    ungroup() %>%
    arrange(season)
  
    
# Changes units from  Micromoles of CO2/(m^2s) to Grams of C/m^2, makes GPP a negative value, and rounds
  
    integrals$integral_value = 
      round(integrals$integral_value*-60*30*(1/1000000)*12, 2)
  
  return(integrals)
}

seasonal_integrals_2022 <- seasonal_integrals(df_2022)

ggplot(seasonal_integrals_2022, aes(x = season, y = integral_value)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(
    x = "Season",
    y = "Net GPP (Grams of Carbon/m^2)",
    title = "2022 GPP by season"
  ) +
  theme_minimal()+
  geom_text(aes(label = integral_value), vjust = 1, colour = "orange")


```

## RECO

```{r}

seasonal_integrals <- function(df) {
  
  # Calculate integral (sum) for each season
  integrals <- df %>%
    group_by(season) %>%
    summarise(integral_value = sum(RECO, na.rm = TRUE)) %>%
    ungroup() %>%
    arrange(season)
  
    
  # Changes units from  Micromoles of CO2/(m^2s) to Grams of C/m^2, and rounds
    integrals$integral_value = 
      round(integrals$integral_value*60*30*(1/1000000)*12, 2)
  
  return(integrals)
}

seasonal_integrals_2022 <- seasonal_integrals(df_2022)

ggplot(seasonal_integrals_2022, aes(x = season, y = integral_value)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(
    x = "Season",
    y = "Net ER (Grams of Carbon/m^2)",
    title = "2022 Ecosystem Respiration by season"
  ) +
  theme_minimal()+
  geom_text(aes(label = integral_value), vjust = 1, colour = "orange")



# Bar graph showing growing season vs. year round analysis



```

## Methane *****************


```{r}
seasonal_integrals <- function(df_2022) {
  
  # Calculate integral (sum) for each season
  integrals <- df_2022 %>%
    group_by(season) %>%
    summarise(integral_value = sum(FCH4_F, na.rm = TRUE)) %>%
    ungroup() %>%
    arrange(season)
  
    
  # Changes units from mmol of CH4/(m^2s) to grams of C/m^2, and rounds
    integrals$integral_value = 
      round(integrals$integral_value*60*30*(1/1000000000)*12, 2)
  
  return(integrals)
}

seasonal_integrals_2022 <- seasonal_integrals(df_2022)

#reorders seasons to timeline order
seasonal_integrals_2022$season <- factor(seasonal_integrals_2022$season, levels = c("Growing Season", "Fall Senescence", "Winter"))

seasonalCH4_2022 <- ggplot(seasonal_integrals_2022, aes(x = season, y = integral_value)) +
  theme_bw()+
  geom_hline(yintercept=0, colour="black")+
  geom_bar(stat = "identity", position = "dodge", fill = "turquoise3") +
  labs(
    x = "",
    y = expression("Net CH"[4] * " Flux (g C m"^-2*")"),
    title = expression("Net CH"[4] * " Flux by Season: 2022")
  ) +
  geom_label(aes(label = integral_value), vjust = ifelse(seasonal_integrals_2022$integral_value >= 0, -0.7, 1.5), colour = "black", fill ="white")+
  scale_y_continuous(limits=c(0, 6)) +
   theme(
    axis.title.x = element_text(size = 16, face = "bold"),  # Make x-axis title larger and bold
    axis.title.y = element_text(size = 16, face = "bold"),  # Make y-axis title larger and bold
    axis.text.x = element_text(size = 14, face = "bold"),   # Make x-axis text larger and bold
    axis.text.y = element_text(size = 14, face = "bold")    # Make y-axis text larger and bold
  )
seasonalCH4_2022 

```


#save image to maintain dimensions 
```{r}
ggsave(
  filename = "SeasonalCH4_Trends_2020.png",  # File name and extension
  plot = seasonalCH4_2020 ,        # The plot to save (default is the last plot created)
  width = 60,                 # Width in inches
  height = 17,                # Height in inches
  dpi = 600,                 # Resolution in dots per inch
  units = "cm"               # Units for width and height (can be "in", "cm", or "mm")
)

#ggsave("my_plot.pdf", width = 8, height = 6, dpi = 300, units = "in")
```













