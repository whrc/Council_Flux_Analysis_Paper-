---
title: "Council_Comparing Met trends"
output: html_document
date: "2025-01-13"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, include=FALSE}
rm(list = ls())

library(data.table)
library(ggplot2)
library(cowplot)
library(openair)
library(plotrix)
library(signal)
library(svMisc)
library(zoo)
library(stringr)
library(plyr)
library(viridis)
library(lubridate)
library(tidyverse)
library(gridExtra)
library(plotly)
library(RColorBrewer)
library(pracma)
library(dplyr)

install.packages("writexl")
library(writexl)


Sys.setenv(TZ='UTC')
```

# Set working directory and then Load data


```{r}
#changed to "council_gapfilled_clean_2017_2023_for analysis.2.csv" --> .2 indicates updated dataset with SWC_3 tussock; ".3" indicates columns for ERA5.mod-gapfilled air and soil temp  

# #half-hourly dataframe --> gapfilled 
# df = fread('C:/Users/kkent/Documents/Council Data/Council BASE gapfilling/council_gapfilled_clean_2017_2023_for analysis.2.csv',na.strings = c('-9999','NA','NaN','NAN','-7999'))
# 
# 
# #daily avg dataframe --> gapfilled 
# df_avg = fread('C:/Users/kkent/Documents/Council Data/Council BASE gapfilling/council_AVG_gapfilled_clean_2017_2023_for analysis.2.csv',na.strings = c('-9999','NA','NaN','NAN','-7999'))


#with gapfilled soil and air temp columns 

# #half-hourly dataframe --> gapfilled - but doesn't have corrected seasons, need to correct 
df2 = fread('C:/Users/kkent/Documents/Council Data/Council BASE gapfilling/council_gapfilled_clean_2017_2023_for analysis.3.csv',na.strings = c('-9999','NA','NaN','NAN','-7999'))


#daily avg dataframe --> gapfilled - updated seasons 10.6.'25
df_avg2 = fread('C:/Users/kkent/Documents/Council Data/Council BASE gapfilling/council_AVG_gapfilled_clean_2017_2023_for analysis.4.csv',na.strings = c('-9999','NA','NaN','NAN','-7999'))

#Add corrected seasonal delineations to df2 with the temp gf columns 
df2 <- df2 %>%
  mutate(
    season = case_when(
      # 2017 seasons
      year == "2017" & (DOY >= 258 & DOY <= 290) ~ 'Fall Senescence',
      year == "2017" & (DOY >= 131 & DOY <= 257) ~ 'Growing Season',
      year == "2017" & (DOY >= 291 | DOY <= 130) ~ 'Winter',
      
      # 2018 seasons
      year == "2018" &  (DOY >= 257 & DOY <= 299) ~ 'Fall Senescence',
      year == "2018" & (DOY >= 151 & DOY <= 256) ~ 'Growing Season',
      year == "2018" & (DOY >= 300 | DOY <= 150) ~ 'Winter',
      
      # 2019 seasons
      year == "2019" & (DOY >= 243 & DOY <= 283) ~ 'Fall Senescence',
      year == "2019" & (DOY >= 144 & DOY <= 242) ~ 'Growing Season',
      year == "2019" & (DOY >= 284 | DOY <= 143) ~ 'Winter',
      
      # 2020 seasons
      year == "2020" & (DOY >= 249 & DOY <= 299) ~ 'Fall Senescence',
      year == "2020" & (DOY >= 135 & DOY <= 248) ~ 'Growing Season',
      year == "2020" & (DOY >= 300 | DOY <= 134) ~ 'Winter',
      
      # 2021 seasons
      year == "2021" & (DOY >= 255 & DOY <= 281) ~ 'Fall Senescence',
      year == "2021" &(DOY >= 142 & DOY <= 254) ~ 'Growing Season',
      year == "2021" &(DOY >= 282 | DOY <= 141) ~ 'Winter',
      
      # 2022 seasons
      year == "2022" & (DOY >= 250 & DOY <= 280) ~ 'Fall Senescence',
      year == "2022" & (DOY >= 143 & DOY <= 249) ~ 'Growing Season',
      year == "2022" & (DOY >= 281 | DOY <= 142) ~ 'Winter',
      
      # not doing one for 2023 ** incomplete year 
      TRUE ~ NA_character_
    )
  )


df_2022 <- df2 %>%
  filter(year == "2022")

```


#Annual Avg air temp (based on all years, 2017 - 2022, excluding the incomplete 2023*)
```{r}
library(dplyr)
library(lubridate)

annual_temps <- df_avg2 %>%
  mutate(year = year(date)) %>%      # extract the calendar year
  filter(year >= 2017, year <= 2022) %>%  
  group_by(year) %>%                 
  summarise(
    obs_airtemp    = mean(TA, na.rm = TRUE),  # observed
    obs_airtemp_se   = sd(TA, na.rm = TRUE)/sqrt(sum(!is.na(TA))),   # annual standard deviation
    era5_airtemp   = mean(TA_ERA5,   na.rm = TRUE),   # modeled air temp 
    era5_airtemp_se   = sd(TA_ERA5, na.rm = TRUE)/sqrt(sum(!is.na(TA_ERA5))),
    obs_soiltemp = mean(TS_3_1_1, na.rm = TRUE), #observed soil temp at TS3
    obs_soiltemp_se = sd(TS_3_1_1, na.rm = TRUE)/sqrt(sum(!is.na(TS_3_1_1))),
    era5_soiltemp = mean(TS_ERA5, na.rm = TRUE), #modeled soil temp 
    era5_soiltemp_se = sd(TS_ERA5, na.rm = TRUE /sqrt(sum(!is.na(TS_ERA5))))
    )
#sd(FC, na.rm = TRUE)/sqrt(sum(!is.na(FC)))
print(annual_temps)

```

#Era5.mod-gapfilled Annual Avg air & soil (TS_3) temp (based on all years, 2017 - 2022, excluding the incomplete 2023*)
```{r}
library(dplyr)
library(lubridate)

annual_temps2 <- df_avg2 %>%
  mutate(year = year(date)) %>%      
  filter(year >= 2017, year <= 2022) %>%  
  group_by(year) %>%                 
  summarise(
    TA_gapfilled_avg   = mean(TA_gapfilled, na.rm = TRUE),  
   TA_gapfilled_se   = sd(TA_gapfilled, na.rm = TRUE)/sqrt(sum(!is.na(TA_gapfilled))), 
    TS_3_gapfilled_avg = mean(TS_3_gapfilled, na.rm = TRUE), 
    TS_3_gapfilled_se = sd(TS_3_gapfilled, na.rm = TRUE)/sqrt(sum(!is.na(TS_3_gapfilled)))
    )


#sd(FC, na.rm = TRUE)/sqrt(sum(!is.na(FC)))
print(annual_temps2)


```

# % gapfilled vs observed for TS3 and TA

```{r}
# Calculate percentages for Air Temperature (TA)
#HH - year, season 
TA_summaryHH <- df2 %>%
   filter( year != 2023) %>%
  group_by(year, season) %>%
  summarise(
    total_records = n(),
    observed_count = sum(TA_gapfilled_flag == "observed", na.rm = TRUE),
    gapfilled_count = sum(TA_gapfilled_flag == "gapfilled", na.rm = TRUE),
    missing_count = sum(is.na(TA_gapfilled)),
    observed_percent = round((observed_count / total_records) * 100, 1),
    gapfilled_percent = round((gapfilled_count / total_records) * 100, 1),
    missing_percent = round((missing_count / total_records) * 100, 1)
  ) %>%
  mutate(variable = "Air_Temperature")

#daily avg - year, season
TA_summary <- df_avg2 %>%
   filter( year != 2023) %>%
  group_by(year, season) %>%
  summarise(
    total_records = n(),
    observed_count = sum(TA_gapfilled_flag == "observed", na.rm = TRUE),
    gapfilled_count = sum(TA_gapfilled_flag == "gapfilled", na.rm = TRUE),
    missing_count = sum(is.na(TA_gapfilled)),
    observed_percent = round((observed_count / total_records) * 100, 1),
    gapfilled_percent = round((gapfilled_count / total_records) * 100, 1),
    missing_percent = round((missing_count / total_records) * 100, 1)
  ) %>%
  mutate(variable = "Air_Temperature")
TA_summary

#HH - year only 
TA_summaryHH_annual <- df2 %>%
   filter( year != 2023) %>%
  group_by(year) %>%
  summarise(
    total_records = n(),
    observed_count = sum(TA_gapfilled_flag == "observed", na.rm = TRUE),
    gapfilled_count = sum(TA_gapfilled_flag == "gapfilled", na.rm = TRUE),
    missing_count = sum(is.na(TA_gapfilled)),
    observed_percent = round((observed_count / total_records) * 100, 1),
    gapfilled_percent = round((gapfilled_count / total_records) * 100, 1),
    missing_percent = round((missing_count / total_records) * 100, 1)
  ) %>%
  mutate(variable = "Air_Temperature")

#daily avg - year only
TA_summary_annual <- df_avg2 %>%
   filter( year != 2023) %>%
  group_by(year) %>%
  summarise(
    total_records = n(),
    observed_count = sum(TA_gapfilled_flag == "observed", na.rm = TRUE),
    gapfilled_count = sum(TA_gapfilled_flag == "gapfilled", na.rm = TRUE),
    missing_count = sum(is.na(TA_gapfilled)),
    observed_percent = round((observed_count / total_records) * 100, 1),
    gapfilled_percent = round((gapfilled_count / total_records) * 100, 1),
    missing_percent = round((missing_count / total_records) * 100, 1)
  ) %>%
  mutate(variable = "Air_Temperature")


# Calculate percentages for Soil Temperature (TS_3_1_1)

#HH - year, season 
TS_summaryHH <- df2 %>%
  filter( year != 2023) %>%
  group_by(year, season) %>%
  summarise(
    total_records = n(),
    observed_count = sum(TS_3_gapfilled_flag == "observed", na.rm = TRUE),
    gapfilled_count = sum(TS_3_gapfilled_flag == "gapfilled", na.rm = TRUE),
    missing_count = sum(is.na(TS_3_gapfilled)),
    observed_percent = round((observed_count / total_records) * 100, 1),
    gapfilled_percent = round((gapfilled_count / total_records) * 100, 1),
    missing_percent = round((missing_count / total_records) * 100, 1)
  ) %>%
  mutate(variable = "Soil_Temperature")


#daily avg - year, season 
TS_summary <- df_avg2 %>%
   filter( year != 2023) %>%
  group_by(year, season ) %>%
  summarise(
    total_records = n(),
    observed_count = sum(TS_3_gapfilled_flag == "observed", na.rm = TRUE),
    gapfilled_count = sum(TS_3_gapfilled_flag == "gapfilled", na.rm = TRUE),
    missing_count = sum(is.na(TS_3_gapfilled)),
    observed_percent = round((observed_count / total_records) * 100, 1),
    gapfilled_percent = round((gapfilled_count / total_records) * 100, 1),
    missing_percent = round((missing_count / total_records) * 100, 1)
  ) %>%
  mutate(variable = "Soil_Temperature")

#HH - year only 
TS_summaryHH_annual <- df2 %>%
  filter( year != 2023) %>%
  group_by(year) %>%
  summarise(
    total_records = n(),
    observed_count = sum(TS_3_gapfilled_flag == "observed", na.rm = TRUE),
    gapfilled_count = sum(TS_3_gapfilled_flag == "gapfilled", na.rm = TRUE),
    missing_count = sum(is.na(TS_3_gapfilled)),
    observed_percent = round((observed_count / total_records) * 100, 1),
    gapfilled_percent = round((gapfilled_count / total_records) * 100, 1),
    missing_percent = round((missing_count / total_records) * 100, 1)
  ) %>%
  mutate(variable = "Soil_Temperature")


#daily avg - year only 
TS_summary_annual <- df_avg2 %>%
   filter( year != 2023) %>%
  group_by(year, season ) %>%
  summarise(
    total_records = n(),
    observed_count = sum(TS_3_gapfilled_flag == "observed", na.rm = TRUE),
    gapfilled_count = sum(TS_3_gapfilled_flag == "gapfilled", na.rm = TRUE),
    missing_count = sum(is.na(TS_3_gapfilled)),
    observed_percent = round((observed_count / total_records) * 100, 1),
    gapfilled_percent = round((gapfilled_count / total_records) * 100, 1),
    missing_percent = round((missing_count / total_records) * 100, 1)
  ) %>%
  mutate(variable = "Soil_Temperature")

```

#Table: seasonal and annual total C budget & met variable tables 
```{r}
# Load necessary packages
library(dplyr)
library(lubridate)

#Annual and seasonal summaries with SE 

#no SE for CO2 and CH4 fluxes as these are sums **** then we calc averages with SE for the met variables 

# Annual summaries with standard errors
# Annual summaries with total C budget
annual_budgets <- df_avg2 %>%
  group_by(year = year(date)) %>%
  filter(year != 2023) %>% #removing 2023 due to incomplete year data 
  summarize(
    CO2_budget = sum(FC_F * (60*60*24*(1/1000000)*12), na.rm = TRUE),
    CH4_budget = sum(FCH4_F * (60*60*24*(1/1000000000)*12), na.rm = TRUE),
    total_C_budget = CO2_budget + CH4_budget,  # Adding total C budget
    mean_soil_temp = mean(TS_3_1_1, na.rm = TRUE),
    se_soil_temp = sd(TS_3_1_1, na.rm = TRUE)/sqrt(sum(!is.na(TS_3_1_1))),
    mean_TS_ERA5 = mean(TS_ERA5, na.rm = TRUE),
    se_TS_ERA5 = sd(TS_ERA5, na.rm = TRUE)/sqrt(sum(!is.na(TS_ERA5))),
    mean_soil_moisture = mean(SWC_3_1_1, na.rm = TRUE),
    se_soil_moisture = sd(SWC_3_1_1, na.rm = TRUE)/sqrt(sum(!is.na(SWC_3_1_1))),
    mean_TA = mean(TA, na.rm = TRUE),
    se_TA = sd(TA, na.rm = TRUE)/sqrt(sum(!is.na(TA))),
    mean_TA_ERA5 = mean(TA_ERA5, na.rm = TRUE),
    se_TA_ERA5 = sd(TA_ERA5, na.rm = TRUE)/sqrt(sum(!is.na(TA_ERA5))),
    mean_TA_gapfilled   = mean(TA_gapfilled, na.rm = TRUE),  
   se_TA_gapfilled   = sd(TA_gapfilled, na.rm = TRUE)/sqrt(sum(!is.na(TA_gapfilled))), 
    mean_TS_3_gapfilled = mean(TS_3_gapfilled, na.rm = TRUE), 
    se_TS_3_gapfilled = sd(TS_3_gapfilled, na.rm = TRUE /sqrt(sum(!is.na(TS_3_gapfilled))))
      )

# Seasonal summaries with total C budget
seasonal_budgets <- df_avg2 %>%
  group_by(year = year(date), season) %>%
  filter(year != 2023) %>% #removing 2023 due to incomplete year data 
  summarize(
    CO2_budget = sum(FC_F * (60*60*24*(1/1000000)*12), na.rm = TRUE),
    CH4_budget = sum(FCH4_F * (60*60*24*(1/1000000000)*12), na.rm = TRUE),
    total_C_budget = CO2_budget + CH4_budget,  # Adding total C budget
    mean_soil_temp = mean(TS_3_1_1, na.rm = TRUE),
    se_soil_temp = sd(TS_3_1_1, na.rm = TRUE)/sqrt(sum(!is.na(TS_3_1_1))),
    mean_TS_ERA5 = mean(TS_ERA5, na.rm = TRUE),
    se_TS_ERA5 = sd(TS_ERA5, na.rm = TRUE)/sqrt(sum(!is.na(TS_ERA5))),
    mean_soil_moisture = mean(SWC_3_1_1, na.rm = TRUE),
    se_soil_moisture = sd(SWC_3_1_1, na.rm = TRUE)/sqrt(sum(!is.na(SWC_3_1_1))),
    mean_TA = mean(TA, na.rm = TRUE),
    se_TA = sd(TA, na.rm = TRUE)/sqrt(sum(!is.na(TA))),
    mean_TA_ERA5 = mean(TA_ERA5, na.rm = TRUE),
    se_TA_ERA5 = sd(TA_ERA5, na.rm = TRUE)/sqrt(sum(!is.na(TA_ERA5))),
    mean_TA_gapfilled   = mean(TA_gapfilled, na.rm = TRUE),  
    se_TA_gapfilled   = sd(TA_gapfilled, na.rm = TRUE)/sqrt(sum(!is.na(TA_gapfilled))), 
    mean_TS_3_gapfilled = mean(TS_3_gapfilled, na.rm = TRUE), 
    se_TS_3_gapfilled = sd(TS_3_gapfilled, na.rm = TRUE /sqrt(sum(!is.na(TS_3_gapfilled)))),
    days = n()
  )

print(annual_budgets)
print(seasonal_budgets)


```



#Save table of annual and/or seasonal budgets 
```{r}

#Seasonal budgets 

#Write table to Excel file:
# First install if needed:
install.packages("writexl")
library(writexl)

write_xlsx(seasonal_budgets, "C:/Users/kkent/Documents/Github Flux Network/Council_Flux_Analysis_Paper/Council Figures/seasonal_budgets2.xlsx")

#Write table to CSV
# base R, no additional packages needed)
# write.csv(seasonal_budgets, "seasonal_budgets.csv", row.names = FALSE)


# Create a new table with combined mean ± SE format
seasonal_budgets_formatted <- seasonal_budgets %>%
  mutate(
    soil_temp = sprintf("%.2f ± %.2f", mean_soil_temp, se_soil_temp),
    soil_moisture = sprintf("%.2f ± %.2f", mean_soil_moisture, se_soil_moisture),
    air_temp = sprintf("%.2f ± %.2f", mean_TA, se_TA),
    TS_ERA5 = sprintf("%.2f ± %.2f", mean_TS_ERA5, se_TS_ERA5),
    TA_ERA5 = sprintf("%.2f ± %.2f", mean_TA_ERA5, se_TA_ERA5),
    TA_GF = sprintf("%.2f ± %.2f", mean_TA_gapfilled, se_TA_gapfilled),
    TS3_GF = sprintf("%.2f ± %.2f", mean_TS_3_gapfilled, se_TS_3_gapfilled),
  ) %>%
  select(year, season, CO2_budget, CH4_budget, total_C_budget, soil_temp, soil_moisture, air_temp, TS_ERA5, TA_ERA5, TA_GF, TS3_GF, days)

seasonal_budgets_formatted

# Save to Excel
write_xlsx(seasonal_budgets_formatted, "C:/Users/kkent/Documents/Github Flux Network/Council_Flux_Analysis_Paper/Council Figures/seasonal_budgets_formatted3.xlsx")

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#Annual budgets 
# Create a new table with combined mean ± SE format
annual_budgets_formatted <- annual_budgets %>%
  mutate(
    soil_temp = sprintf("%.2f ± %.2f", mean_soil_temp, se_soil_temp),
    soil_moisture = sprintf("%.2f ± %.2f", mean_soil_moisture, se_soil_moisture),
    air_temp = sprintf("%.2f ± %.2f", mean_TA, se_TA),
    TS_ERA5 = sprintf("%.2f ± %.2f", mean_TS_ERA5, se_TS_ERA5),
    TA_ERA5 = sprintf("%.2f ± %.2f", mean_TA_ERA5, se_TA_ERA5),
    TA_GF = sprintf("%.2f ± %.2f", mean_TA_gapfilled, se_TA_gapfilled),
    TS3_GF = sprintf("%.2f ± %.2f", mean_TS_3_gapfilled, se_TS_3_gapfilled),
  ) %>%
  select(year, CO2_budget, CH4_budget, total_C_budget, soil_temp, soil_moisture, air_temp, TS_ERA5, TA_ERA5, TA_GF, TS3_GF)

annual_budgets_formatted

# Save to Excel
write_xlsx(annual_budgets_formatted, "C:/Users/kkent/Documents/Github Flux Network/Council_Flux_Analysis_Paper/Council Figures/annual_budgets_formatted2.xlsx")

```

#Add % gapfilled (from HH datasets) to seasonal and annual averages table 

```{r}
# Join the season, year datasets, adding only the gapfilled_percent column 
seasonal_budgets_with_gapfill <- seasonal_budgets %>%
  left_join(TA_summaryHH %>% select(year, season, TA_gapfill_percent = gapfilled_percent), 
            by = c("year", "season")) %>%
   left_join(TS_summaryHH %>% select(year, season, TS3_gapfill_percent = gapfilled_percent), 
            by = c("year", "season"))

# Check the result
print(seasonal_budgets_with_gapfill)


# Join the annual datasets, adding only the gapfilled_percent column
annual_budgets_with_gapfill <- seasonal_budgets %>%
  left_join(TA_summaryHH_annual %>% select(year, TA_gapfill_percent = gapfilled_percent), 
            by = c("year")) %>%
   left_join(TS_summaryHH_annual %>% select(year, TS3_gapfill_percent = gapfilled_percent), 
            by = c("year"))

# Check the result
print(annual_budgets_with_gapfill)


# ~~~~~~~~~~~~~Add to formatted tables ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#Annual 
# Join the annual datasets, adding only the gapfilled_percent column
annual_budgets_formatted2 <- annual_budgets_formatted %>%
  left_join(TA_summaryHH_annual %>% select(year, TA_gapfill_percent = gapfilled_percent), 
            by = c("year")) %>%
   left_join(TS_summaryHH_annual %>% select(year, TS3_gapfill_percent = gapfilled_percent), 
             by = c("year"))

# Check the result
print(annual_budgets_formatted2)


#Seasonal 

# Join the seasonal datasets, adding only the gapfilled_percent column
seasonal_budgets_formatted2 <- seasonal_budgets_formatted %>%
  left_join(TA_summaryHH %>% select(year, season, TA_gapfill_percent = gapfilled_percent), 
            by = c("year", "season")) %>%
   left_join(TS_summaryHH %>% select(year, season, TS3_gapfill_percent = gapfilled_percent), 
            by = c("year", "season"))

# Check the result
print(seasonal_budgets_formatted2)

```

# Save to Excel
```{r}
#annual 
write_xlsx(annual_budgets_formatted2, "C:/Users/kkent/Documents/Github Flux Network/Council_Flux_Analysis_Paper/Council Figures/annual_budgets_formatted2.xlsx")

#seasonal 
write_xlsx(seasonal_budgets_formatted2, "C:/Users/kkent/Documents/Github Flux Network/Council_Flux_Analysis_Paper/Council Figures/seasonal_budgets_formatted3.xlsx")



```


#Yearly summaries of key variables 
```{r}
# Create yearly summaries of key variables
yearly_summary <- df_avg2 %>%
  mutate(year = format(date, "%Y")) %>%
  group_by(year) %>%
  summarise(
    # Temperature metrics
    mean_ta = mean(TA, na.rm = TRUE), #air temp 
    mean_ts3 = mean(TS_3_1_1, na.rm = TRUE),  # Tussock soil temp
    
      #ERA5 air temp
    mean_ERA.ta = mean(TA_ERA5, na.rm = TRUE), #ERA5 air temp 
    mean_ERA.ts = mean(TS_ERA5, na.rm = TRUE),  # ERA5 soil temp 
    
    # Moisture metrics
    mean_swc3 = mean(SWC_3_1_1, na.rm = TRUE),  # Tussock moisture
    mean_vpd = mean(VPD, na.rm = TRUE),
    mean_rh = mean(RH, na.rm = TRUE),
    
    # Energy metrics
    mean_netrad = mean(NETRAD, na.rm = TRUE),
    mean_le = mean(LE, na.rm = TRUE),
    
    # Sample sizes
    n_total = n(),
    n_fch4 = sum(!is.na(FCH4))
  )

# Create visualization
library(tidyr)

# Reshape data for plotting
yearly_long <- yearly_summary %>%
  select(-n_total, -n_fch4) %>%
  pivot_longer(-year, 
               names_to = "variable", 
               values_to = "value")

# Plot
ggplot(yearly_long, aes(x = year, y = value, group = 1)) +
  geom_line() +
  geom_point() +
  facet_wrap(~variable, scales = "free_y") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(title = "Environmental Variables Across Years",
       y = "Value",
       x = "Year")

#Results of total annual avg:
#not all very accurate because some years have lots of missing data, so though this makes a quick and easy visual of annual averages, for this Council dataset with lots of missing data, a lot of the trends are probably wrong / misleading 
```


#Create yearly dataframes 
```{r}
#create dataframes for each year for the data you have so you can look at annual trends -

#Daily avg

df_avg_2017 <- df_avg2 %>%
  filter(year(date) == 2017)

df_avg_2018 <- df_avg2 %>%
  filter(year(date) == 2018)

df_avg_2019 <- df_avg2 %>%
  filter(year(date) == 2019)

df_avg_2020 <- df_avg2 %>%
  filter(year(date) == 2020)

df_avg_2021 <- df_avg2 %>%
  filter(year(date) == 2021)

df_avg_2022 <- df_avg2 %>%
  filter(year(date) == 2022)



# HH 

df_2017 <- df2 %>%
  filter(year(date) == 2017)

df_2018 <- df2 %>%
  filter(year(date) == 2018)

df_2019 <- df2 %>%
  filter(year(date) == 2019)

df_2020 <- df2 %>%
  filter(year(date) == 2020)

df_2021 <- df2 %>%
  filter(year(date) == 2021)

df_2022 <- df2 %>%
  filter(year(date) == 2022)




```

#Seasonal dataframes 
```{r}
#Across all years
#This will exclude 2023 because it does not have assigned seasons 

#Daily avg 
df_avg_winter <- df_avg %>%
  filter(season == "Winter")

df_avg_growing <- df_avg %>%
  filter(season == "Growing Season")

df_avg_fall <- df_avg %>%
  filter(season == "Fall Senescence")


#HH data 
df_winter <- df %>%
  filter(season == "Winter")

df_growing <- df %>%
  filter(season == "Growing Season")

df_fall <- df %>%
  filter(season == "Fall Senescence")




#Within each year 

#** TO DO

#Daily avg



sum(is.na(df_avg_fall$season))
```




#Creating timeseries for each year, with seasonal delineations 
```{r}
#Below code sets it up as a function so all you have to do it change the years at the bottom, and re-run, and it'll adjust the figure with associated seasonal delineations (code from Claude)

library(ggplot2)
library(dplyr)
library(lubridate)

#TO DO: NEED TO FIX THESE DOYs, they're outdated - 10.14.2025 -- 
# Create seasonal boundaries dataframe
season_boundaries <- data.frame(
  year = rep(2017:2022, each = 3),  # now each year has 3 dates
  DOY = c(
    # 2017
    131, 258, 291,  # Growing season start, Fall start, Winter start
    # 2018
    152, 257, 301,  # Growing season start, Fall start, Winter start
    # 2019
    145, 246, 285,  # Growing season start, Fall start, Winter start
    # 2020
    136, 252, 300,  # Growing season start, Fall start, Winter start
    # 2021
    142, 260, 284,  # Growing season start, Fall start, Winter start
    # 2022
    144, 245, 282   # Growing season start, Fall start, Winter start
  )
)

# Function to create seasonal flux plots
create_seasonal_plot <- function(df_avg, year_to_plot) {
  # Filter data for specified year
  yearly_data <- df_avg %>%
    filter(year(date) == year_to_plot)
  
  # Get the seasonal boundaries for this year and calculate mid-points for labels
  year_boundaries <- season_boundaries %>%
    filter(year == year_to_plot) %>%
    mutate(date = as.Date(paste(year, DOY), format="%Y %j"))

  # Calculate midpoints for season labels
  year_start <- as.Date(paste0(year_to_plot, "-01-01"))
  year_end <- as.Date(paste0(year_to_plot, "-12-31"))
  
  label_dates <- data.frame(
    season = c("Winter", "Growing Season", "Fall Senescence", "Winter"),
    date = c(
      year_start + (year_boundaries$date[1] - year_start)/2,  # Winter to Growing
      year_boundaries$date[1] + (year_boundaries$date[2] - year_boundaries$date[1])/2,  # Growing to Fall
      year_boundaries$date[2] + (year_boundaries$date[3] - year_boundaries$date[2])/2,  # Fall to Winter
      year_boundaries$date[3] + (year_end - year_boundaries$date[3])/2  # End of year Winter
    )
  )
  
  # Create plot a (Temperature and NEE)
  p1 <- ggplot(yearly_data) +
    # Add air temperature with scaling
    geom_line(aes(x = date, y = TA/15, color = "Air Temperature"), size = 0.5) +
    # Add soil temperature with same scaling - TS3 = tussock location 
    geom_line(aes(x = date, y = TS_2_1_1/15, color = "Soil Temperature"), size = 0.5) + 
    #Add air temp ERA5 
    geom_line(aes(x = date, y = TA_ERA5/15, colour = "ERA5 Air Temperature"), linetype = "dashed")+
    # Add NEE points
    geom_point(aes(x = date, y = FC_F * 60 * 60 * 24 * (1/1000000) * 12, color = "NEE"), alpha = 0.6, size = 1) +
       #add dark line at y=0
    geom_hline(yintercept=0, col="black")+
    # Create secondary y-axis for temperature with correct scaling
    scale_y_continuous(
      name = expression(NEE~(gC~m^-2~d^-1)),
      limits = c(-4, 3),
      sec.axis = sec_axis(~ . * 15, name = expression("Temperature ("*degree*"C)"))
    ) +
    # Add season divisions using geom_vline with year-specific dates
    geom_vline(data = year_boundaries,
               aes(xintercept = date),
               linetype = "solid", color = "black") +
    # Customize colors
    scale_color_manual(
      values = c("Air Temperature" = "salmon", 
                "Soil Temperature" = "navy",
                "ERA5 Air Temperature" = "darkgreen",
                "NEE" = "turquoise"),
      name = ""
    ) +
    # Add season labels
    geom_text(data = label_dates,
              aes(x = date, y = -3.8, label = season),
              size = 3, angle = 0) +
    theme_bw() +
    theme(
      legend.position = "bottom",
      panel.grid.minor = element_blank(),
      axis.title.y.right = element_text(color = "black"),
      axis.text.y.right = element_text(color = "black")
    ) +
    labs(x = "Date", title = paste("Seasonal Trends:", year_to_plot))
  
  # Create plot b (GPP, RECO, NEE, and CH4)
  p2 <- ggplot(yearly_data) +
    # Add GPP points (negative for uptake)
    geom_point(aes(x = date, y = -GPP_F * 60 * 60 * 24 * (1/1000000) * 12, color = "GPP"), alpha = 0.6, size = 1) +
    # Add RECO points
    geom_point(aes(x = date, y = RECO_F * 60 * 60 * 24 * (1/1000000) * 12, color = "Respiration"), alpha = 0.6, size = 1) +
    # Add NEE line
    geom_line(aes(x = date, y = FC_F * 60 * 60 * 24 * (1/1000000) * 12, color = "NEE"), size = 0.5) +
    # Add CH4 line (scaled for visibility)
    geom_line(aes(x = date, y = FCH4_F * 60 * 60 * 24 * (1/1000000000) * 12 * 33, color = "CH4"), size = 0.5) +
    #add dark line at y=0
    geom_hline(yintercept=0, col="black")+
    # Create secondary y-axis for CH4
    scale_y_continuous(
      name = expression(Flux~(gC~m^-2~d^-1)),
      limits = c(-5, 3),
      sec.axis = sec_axis(~ . / 33, name = expression('CH'[4]*' Flux (g C'~m^-2~d^-1*')'))
    ) +
    # Add season divisions using geom_vline with year-specific dates
    geom_vline(data = year_boundaries,
               aes(xintercept = date),
               linetype = "solid", color = "black") +
    # Customize colors
    scale_color_manual(
      values = c("GPP" = "navy",
                "Respiration" = "turquoise",
                "NEE" = "coral",
                "CH4" = "purple"),
      name = ""
    ) +
    # Add season labels
    geom_text(data = label_dates,
              aes(x = date, y = -5, label = season),
              size = 3, angle = 0) +
    theme_bw() +
    theme(
      legend.position = "bottom",
      panel.grid.minor = element_blank(),
      axis.title.y.right = element_text(color = "black"),
      axis.text.y.right = element_text(color = "black")
    ) +
     labs(x = "Date", title = paste("Seasonal Trends:", year_to_plot))
  
  return(list(temp_nee = p1, fluxes = p2))
}

# Usage example:
plots_2020 <- create_seasonal_plot(df_avg, 2020)
plots_2020$temp_nee  # Display temperature and NEE plot
plots_2020$fluxes    # Display GPP, RECO, NEE, and CH4 plot




```


#Comparison plots 


##Mapping monthly avg of enviromental variables for each year - creates table with avg, SE, and also plots the means (should plot SE but the error bars are not showing up on the fig)

#####error bars only for months where there is sufficient data - Claude help, not working - will have to revisit 



```{r}
# Load required libraries
library(ggplot2)
library(dplyr)
library(lubridate)
library(tidyr)

# Prepare the data with error bars
monthly_env_data <- df_avg2 %>%
  # Extract year and month from date
  mutate(
    year = year(date),
    month = month(date, label = TRUE, abbr = TRUE)  # Creates abbreviated month names (Jan, Feb, etc.)
  ) %>%
  # Filter for your years of interest
  filter(year >= 2017 & year <= 2023) %>%

  # Group by year and month to calculate monthly averages and standard errors
  group_by(year, month) %>%
  summarise(
    Air_Temperature_mean = mean(TA, na.rm = TRUE),
    Air_Temperature_se = sd(TA, na.rm = TRUE) / sqrt(sum(!is.na(TA))),
    Soil_Temperature_mean = mean(TS_3_1_1, na.rm = TRUE),
    Soil_Temperature_se = sd(TS_3_1_1, na.rm = TRUE) / sqrt(sum(!is.na(TS_3_1_1))),
    Air_TemperatureGF_mean = mean(TA_gapfilled, na.rm = TRUE),
    Air_TemperatureGF_se = sd(TA_gapfilled, na.rm = TRUE) / sqrt(sum(!is.na(TA_gapfilled))),
    Soil_TemperatureGF_mean = mean(TS_3_gapfilled, na.rm = TRUE),
    Soil_TemperatureGF_se = sd(TS_3_gapfilled, na.rm = TRUE) / sqrt(sum(!is.na(TS_3_gapfilled))),
    Soil_Moisture_mean = mean(SWC_3_1_1, na.rm = TRUE),
    Soil_Moisture_se = sd(SWC_3_1_1, na.rm = TRUE) / sqrt(sum(!is.na(SWC_3_1_1))),
    VPD_mean = mean(VPD, na.rm = TRUE),
    VPD_se = sd(VPD, na.rm = TRUE) / sqrt(sum(!is.na(VPD))),
    Net_Radiation_mean = mean(NETRAD, na.rm = TRUE),
    Net_Radiation_se = sd(NETRAD, na.rm = TRUE) / sqrt(sum(!is.na(NETRAD))),
    Wind_Speed_mean = mean(WS, na.rm = TRUE),
    Wind_Speed_se = sd(WS, na.rm = TRUE) / sqrt(sum(!is.na(WS))),
    PAR_mean = mean(PPFD_IN, na.rm = TRUE),
    PAR_se = sd(PPFD_IN, na.rm = TRUE) / sqrt(sum(!is.na(PPFD_IN))),
    H_mean = mean(H, na.rm = TRUE),
    H_se = sd(H, na.rm = TRUE) / sqrt(sum(!is.na(H))),
    LE_mean = mean(LE, na.rm = TRUE),
    LE_se = sd(LE, na.rm = TRUE) / sqrt(sum(!is.na(LE))),
    SWC_mean = mean(SWC_3_1_1, na.rm = TRUE),
    SWC_se = sd(SWC_3_1_1, na.rm = TRUE) / sqrt(sum(!is.na(SWC_3_1_1))),
    RH_mean = mean(RH, na.rm = TRUE),
    RH_se = sd(RH, na.rm = TRUE) / sqrt(sum(!is.na(RH))),
    G_mean = mean(G_1_1_1, na.rm = TRUE),
    G_se = sd(G_1_1_1, na.rm = TRUE) / sqrt(sum(!is.na(G_1_1_1))),
    
    .groups = 'drop'
  ) %>%
  # Convert to long format for faceting
  pivot_longer(
    cols = contains("_mean"),
    names_to = "Variable",
    values_to = "Value",
    names_pattern = "(.*)_mean"
  ) %>%
  # Add corresponding standard errors
  mutate(
    SE = case_when(
      Variable == "Air_Temperature" ~ Air_Temperature_se,
      Variable == "Soil_Temperature" ~ Soil_Temperature_se,
      Variable == "Air_TemperatureGF" ~ Air_TemperatureGF_se,
      Variable == "Soil_TemperatureGF" ~ Soil_TemperatureGF_se,
      Variable == "Soil_Moisture" ~ Soil_Moisture_se,
      Variable == "VPD" ~ VPD_se,
      Variable == "Net_Radiation" ~ Net_Radiation_se,
      Variable == "Wind_Speed" ~ Wind_Speed_se,
      Variable == "PAR" ~ PAR_se,
      Variable == "H" ~ H_se,
      Variable == "LE" ~ LE_se,
      Variable == "SWC" ~ SWC_se,
      Variable == "RH" ~ RH_se,
      Variable == "G" ~ G_se
    )
  ) %>%
  # Create proper labels and units for each variable
  mutate(
    Variable_Label = case_when(
      Variable == "Air_Temperature" ~ "Air Temperature (°C)",
      Variable == "Soil_Temperature" ~ "Soil Temperature to 15cm (°C)", 
      Variable == "Air_TemperatureGF" ~ "Air Temperature ERA5-GF  (°C)",
      Variable == "Soil_TemperatureGF" ~ "Soil Temperature to 15cm ERA5-GF (°C)", 
      Variable == "Soil_Moisture" ~ "Soil Moisture (%)",
      Variable == "VPD" ~ "VPD (hPa)",
      Variable == "Net_Radiation" ~ "Net Radiation (W m⁻²)",
      Variable == "Wind_Speed" ~ "Wind Speed (m s⁻¹)",
      Variable == "PAR" ~ "PAR In (μmol m⁻² s⁻¹)",
      Variable == "H" ~ "Sensible Heat Flux (W m⁻²)",
      Variable == "LE" ~ "Latent Heat Flux (W m⁻²)",
      Variable == "SWC" ~ "SWC to 15cm (%)",
      Variable == "RH" ~ "Relative Humidity (%)",
      Variable == "G" ~ "Soil Heat Flux (W m⁻²)",
    ),
    year = as.factor(year)  # Convert year to factor for better color mapping
  ) %>%
  # Remove the individual SE columns we don't need anymore
  select(-ends_with("_se"))

# Create the plot with error bars
monthly_plot <- ggplot(monthly_env_data, aes(x = month, y = Value, color = year, group = year)) +
  geom_line(size = 1.2) +
  geom_point(size = 2) +
  geom_errorbar(aes(ymin = Value - SE, ymax = Value + SE), 
                width = 0.2, alpha = 0.7) +
  facet_wrap(~ Variable_Label, scales = "free_y", ncol = 3, 
             labeller = labeller(Variable_Label = label_wrap_gen(width = 15))) +
  scale_color_manual(
    values = c("2017" = "#1f77b4", "2018" = "#ff7f0e", "2019" = "#2ca02c", 
               "2020" = "#d62728", "2021" = "#9467bd", "2022" = "#8c564b", 
               "2023" = "#e377c2")
  ) +
  theme_bw() +  # Changed to light theme for better label visibility
  theme(
    strip.text = element_text(size = 11, face = "bold"),
    strip.background = element_rect(fill = "gray90"),
    axis.text.x = element_text(angle = 45, hjust = 1, size = 9),
    axis.text.y = element_text(size = 9),
    axis.title = element_text(face = "bold", size = 12),
    legend.title = element_text(face = "bold", size = 12),
    legend.text = element_text(size = 10),
    panel.grid.minor = element_blank(),
    panel.grid.major = element_line(color = "gray90", size = 0.5),
    plot.title = element_text(size = 14, face = "bold", hjust = 0.5)
  ) +
  labs(
    x = "Month",
    y = "",
    color = "Year",
    title = "Monthly Averages of Environmental Variables (2017-2022)"
  )

# Display the plot
print(monthly_plot)


# Alternative version with white background 
monthly_plot_light <- ggplot(monthly_env_data, aes(x = month, y = Value, color = year, group = year)) +
  geom_line(size = 1.2) +
  geom_point(size = 2) +
  facet_wrap(~ Variable_Label, scales = "free_y", ncol = 3) +
  scale_color_manual(
    values = c("2017" = "#1f77b4", "2018" = "#ff7f0e", "2019" = "#2ca02c", 
               "2020" = "#d62728", "2021" = "#9467bd", "2022" = "#8c564b", 
               "2023" = "#e377c2")
  ) +
  theme_bw() +
  theme(
    strip.text = element_text(size = 12, face = "bold"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.title = element_text(face = "bold"),
    legend.title = element_text(face = "bold"),
    panel.grid.minor = element_blank()
  ) +
  labs(
    x = "Month",
    y = "",
    color = "Year",
    title = "Monthly Averages of Environmental Variables (2017- 2022)"
  )


 print(monthly_plot_light)

```
#save figure 
```{r}
 #Save figure 
 
ggsave("C:/Users/kkent/Documents/Github Flux Network/Council_Flux_Analysis_Paper/Council Figures/monthly_MeanMet_vars_plot.png", monthly_plot_light, 
        width = 12, height = 7, dpi = 600)
```


#seasonal delineations - shows start and end date of each season within the year, and # days within each season for that year - Claude streamlined code 
```{r}
create_seasonal_subsets <- function(year_data, year_num) {
  # Create seasonal datasets
  winter <- year_data %>%
    filter(season == "Winter")
  
  growing <- year_data %>%
    filter(season == "Growing Season")
  
  fall <- year_data %>%
    filter(season == "Fall Senescence")
  
  # Print summary information
  cat(paste("\nSeasonal Summary for", year_num, ":\n"))
  cat("------------------------\n")
  
  cat("Winter dates:\n")
  print(range(winter$date))
  cat(paste("Number of winter days:", nrow(winter), "\n\n"))
  
  cat("Growing Season dates:\n")
  print(range(growing$date))
  cat(paste("Number of growing days:", nrow(growing), "\n\n"))
  
  cat("Fall Senescence dates:\n")
  print(range(fall$date))
  cat(paste("Number of fall days:", nrow(fall), "\n\n"))
  
  # Return the datasets as a list
  return(list(
    winter = winter,
    growing = growing,
    fall = fall
  ))
}


# print results for each year 
seasons_2018 <- create_seasonal_subsets(df_avg_2018, 2018)
seasons_2019 <- create_seasonal_subsets(df_avg_2019, 2019)
seasons_2020 <- create_seasonal_subsets(df_avg_2020, 2020)
seasons_2021 <- create_seasonal_subsets(df_avg_2021, 2021)
seasons_2022 <- create_seasonal_subsets(df_avg_2022, 2022)

# Access individual seasonal datasets if needed:
winter_2017 <- seasons_2017$winter
growing_2017 <- seasons_2017$growing
fall_2017 <- seasons_2017$fall


```


#Met data per season - prints summaries for each season within each year with average, min, max (range) --> Claude streamlined code 
```{r}
create_seasonal_subsets <- function(year_data, year_num) {
  # Create seasonal datasets
  winter <- year_data %>%
    filter(season == "Winter")
  
  growing <- year_data %>%
    filter(season == "Growing Season")
  
  fall <- year_data %>%
    filter(season == "Fall Senescence")
  
  # Function to calculate seasonal statistics
  get_season_stats <- function(data) {
    list(
      # Measured Air Temperature statistics
      mean_air_temp = mean(data$TA, na.rm = TRUE),
      max_air_temp = max(data$TA, na.rm = TRUE),
      min_air_temp = min(data$TA, na.rm = TRUE),
      
      # ERA5 Air Temperature statistics
      mean_era5_temp = mean(data$TA_ERA5, na.rm = TRUE),
      max_era5_temp = max(data$TA_ERA5, na.rm = TRUE),
      min_era5_temp = min(data$TA_ERA5, na.rm = TRUE),
      
      # Soil conditions
      mean_soil_temp = mean(data$TS_3_1_1, na.rm = TRUE),
      max_soil_temp = max(data$TS_3_1_1, na.rm = TRUE),
      min_soil_temp = min(data$TS_3_1_1, na.rm = TRUE),
      
      mean_soil_moisture = mean(data$SWC_3_1_1, na.rm = TRUE),
      max_soil_moisture = max(data$SWC_3_1_1, na.rm = TRUE),
      min_soil_moisture = min(data$SWC_3_1_1, na.rm = TRUE),
      
      # Carbon fluxes
      mean_NEE = mean(data$FC_F, na.rm = TRUE),
      mean_CH4 = mean(data$FCH4_F, na.rm = TRUE),
      cumulative_NEE = sum(data$FC_F, na.rm = TRUE),
      cumulative_CH4 = sum(data$FCH4_F, na.rm = TRUE)
    )
  }
  
  # Calculate statistics for each season
  winter_stats <- get_season_stats(winter)
  growing_stats <- get_season_stats(growing)
  fall_stats <- get_season_stats(fall)
  
  # Print summary information
  cat(paste("\nSeasonal Summary for", year_num, ":\n"))
  cat("================================================\n")
  
  for(season_name in c("Winter", "Growing Season", "Fall Senescence")) {
    season_data <- switch(season_name,
                         "Winter" = winter,
                         "Growing Season" = growing,
                         "Fall Senescence" = fall)
    stats <- switch(season_name,
                   "Winter" = winter_stats,
                   "Growing Season" = growing_stats,
                   "Fall Senescence" = fall_stats)
    
    cat(paste("\n", season_name, ":\n"))
    cat("----------------\n")
    cat("Dates:", format(range(season_data$date), "%Y-%m-%d"), "\n")
    cat("Number of days:", nrow(season_data), "\n")
    cat("\nTemperature Conditions:\n")
    cat(sprintf("Measured Air Temperature: %.1f°C (range: %.1f to %.1f°C)\n", 
                stats$mean_air_temp, stats$min_air_temp, stats$max_air_temp))
    cat(sprintf("ERA5 Air Temperature: %.1f°C (range: %.1f to %.1f°C)\n", 
                stats$mean_era5_temp, stats$min_era5_temp, stats$max_era5_temp))
    cat(sprintf("Soil Temperature: %.1f°C (range: %.1f to %.1f°C)\n", 
                stats$mean_soil_temp, stats$min_soil_temp, stats$max_soil_temp))
    
    cat("\nSoil Moisture:\n")
    cat(sprintf("Mean: %.1f %%SWC (range: %.1f to %.1f %%SWC)\n", 
                stats$mean_soil_moisture, stats$min_soil_moisture, stats$max_soil_moisture))
    
    cat("\nCarbon Fluxes:\n")
    cat("\nCarbon Fluxes:\n")
    cat(sprintf("Mean NEE: %.2f µmol/m²/s\n", stats$mean_NEE))
    cat(sprintf("Mean CH4: %.3f nmol/m²/s\n", stats$mean_CH4))
    cat(sprintf("Cumulative NEE: %.1f µmol/m²\n", stats$cumulative_NEE))
    cat(sprintf("Cumulative CH4: %.2f nmol/m²\n", stats$cumulative_CH4))
    cat("\n")
  }
  
  # Return the datasets as a list
  return(list(
    winter = winter,
    growing = growing,
    fall = fall,
    stats = list(
      winter = winter_stats,
      growing = growing_stats,
      fall = fall_stats
    )
  ))
}

# print results 
seasons_2017 <- create_seasonal_subsets(df_avg_2017, 2017)
seasons_2018 <- create_seasonal_subsets(df_avg_2018, 2018)
seasons_2019 <- create_seasonal_subsets(df_avg_2019, 2019)
seasons_2020 <- create_seasonal_subsets(df_avg_2020, 2020)
seasons_2021 <- create_seasonal_subsets(df_avg_2021, 2021)
seasons_2022 <- create_seasonal_subsets(df_avg_2022, 2022)


# Access individual seasonal datasets if needed:
winter_2019 <- seasons_2019$winter
growing_2019 <- seasons_2019$growing
fall_2019 <- seasons_2019$fall



```

#---------------------------------------------

#Coding help from Claude -streamlining some steps into one code chunk
```{r}
# Annual Trends Analysis - Complete Visualization Script
# Air Temperature, Soil Temperature, Soil Moisture, and VPD
# Distinguish observed (solid) vs gap-filled (open/transparent) data

library(ggplot2)
library(dplyr)
library(gridExtra)

# ============================================================================
# AIR TEMPERATURE
# ============================================================================

# Calculate annual means for air temperature (exclude 2023)
annual_temp_summary <- df_avg2 %>%
  filter(year %in% 2017:2022) %>%
  group_by(year) %>%
  summarise(
    # Observed air temp
    TA_mean = mean(TA, na.rm = TRUE),
    TA_se = sd(TA, na.rm = TRUE) / sqrt(sum(!is.na(TA))),
    TA_n = sum(!is.na(TA)),
    
    # Gap-filled air temp  
    TA_gapfilled_mean = mean(TA_gapfilled, na.rm = TRUE),
    TA_gapfilled_se = sd(TA_gapfilled, na.rm = TRUE) / sqrt(sum(!is.na(TA_gapfilled))),
    TA_gapfilled_n = sum(!is.na(TA_gapfilled)),
    
    # Calculate gap-fill percentage
    gapfill_percent = (TA_gapfilled_n - TA_n) / TA_gapfilled_n * 100
  )

# Calculate seasonal means for air temperature
seasonal_temp_summary <- df_avg2 %>%
  filter(year %in% 2017:2022) %>%
  group_by(year, season) %>%
  summarise(
    # Observed air temp
    TA_mean = mean(TA, na.rm = TRUE),
    TA_se = sd(TA, na.rm = TRUE) / sqrt(sum(!is.na(TA))),
    TA_n = sum(!is.na(TA)),
    
    # Gap-filled air temp
    TA_gapfilled_mean = mean(TA_gapfilled, na.rm = TRUE),
    TA_gapfilled_se = sd(TA_gapfilled, na.rm = TRUE) / sqrt(sum(!is.na(TA_gapfilled))),
    TA_gapfilled_n = sum(!is.na(TA_gapfilled)),
    
    # Calculate gap-fill percentage
    gapfill_percent = (TA_gapfilled_n - TA_n) / TA_gapfilled_n * 100,
    .groups = 'drop'
  )

# Plot 1: Annual air temperature trends
p1 <- ggplot(annual_temp_summary) +
  # Gap-filled data (open circles, transparent)
  geom_point(aes(x = year, y = TA_gapfilled_mean), 
             shape = 1, size = 3, color = "blue", alpha = 0.7) +
  geom_errorbar(aes(x = year, ymin = TA_gapfilled_mean - TA_gapfilled_se, 
                    ymax = TA_gapfilled_mean + TA_gapfilled_se),
                width = 0.1, color = "blue", alpha = 0.7) +
  
  # Observed data (solid circles)
  geom_point(aes(x = year, y = TA_mean), 
             shape = 16, size = 3, color = "red") +
  geom_errorbar(aes(x = year, ymin = TA_mean - TA_se, 
                    ymax = TA_mean + TA_se),
                width = 0.1, color = "red") +
  
  # Add trend lines
  geom_smooth(aes(x = year, y = TA_gapfilled_mean), 
              method = "lm", se = TRUE, color = "blue", alpha = 0.3) +
  geom_smooth(aes(x = year, y = TA_mean), 
              method = "lm", se = TRUE, color = "red", alpha = 0.3) +
  
  labs(title = "Annual Air Temperature Trends (2017-2022)",
       subtitle = "Red = Observed data, Blue = Gap-filled data",
       x = "Year", 
       y = "Air Temperature (°C)") +
  theme_bw() +
  scale_x_continuous(breaks = 2017:2022)

# Plot 2: Seasonal air temperature trends (faceted)
p2 <- ggplot(seasonal_temp_summary) +
  # Gap-filled data (open circles)
  geom_point(aes(x = year, y = TA_gapfilled_mean), 
             shape = 1, size = 2.5, color = "blue", alpha = 0.7) +
  geom_errorbar(aes(x = year, ymin = TA_gapfilled_mean - TA_gapfilled_se, 
                    ymax = TA_gapfilled_mean + TA_gapfilled_se),
                width = 0.1, color = "blue", alpha = 0.7) +
  
  # Observed data (solid circles)
  geom_point(aes(x = year, y = TA_mean), 
             shape = 16, size = 2.5, color = "red") +
  geom_errorbar(aes(x = year, ymin = TA_mean - TA_se, 
                    ymax = TA_mean + TA_se),
                width = 0.1, color = "red") +
  
  # Add trend lines by season
  geom_smooth(aes(x = year, y = TA_gapfilled_mean), 
              method = "lm", se = FALSE, color = "blue", alpha = 0.7, size = 0.8) +
  geom_smooth(aes(x = year, y = TA_mean), 
              method = "lm", se = FALSE, color = "red", alpha = 0.7, size = 0.8) +
  
  facet_wrap(~ season, scales = "free_y", ncol = 3) +
  
  labs(title = "Seasonal Air Temperature Trends by Season (2017-2022)",
       subtitle = "Red = Observed data, Blue = Gap-filled data",
       x = "Year", 
       y = "Air Temperature (°C)") +
  theme_bw() +
  scale_x_continuous(breaks = c(2017, 2019, 2021)) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# ============================================================================
# SOIL TEMPERATURE
# ============================================================================

# Calculate annual means for soil temperature
annual_soil_temp_summary <- df_avg2 %>%
  filter(year %in% 2017:2022) %>%
  group_by(year) %>%
  summarise(
    # Observed soil temp (TS_3_1_1)
    TS_3_mean = mean(TS_3_1_1, na.rm = TRUE),
    TS_3_se = sd(TS_3_1_1, na.rm = TRUE) / sqrt(sum(!is.na(TS_3_1_1))),
    TS_3_n = sum(!is.na(TS_3_1_1)),
    
    # Gap-filled soil temp
    TS_3_gapfilled_mean = mean(TS_3_gapfilled, na.rm = TRUE),
    TS_3_gapfilled_se = sd(TS_3_gapfilled, na.rm = TRUE) / sqrt(sum(!is.na(TS_3_gapfilled))),
    TS_3_gapfilled_n = sum(!is.na(TS_3_gapfilled)),
    
    # Calculate gap-fill percentage
    gapfill_percent = (TS_3_gapfilled_n - TS_3_n) / TS_3_gapfilled_n * 100
  )

# Calculate seasonal means for soil temperature
seasonal_soil_temp_summary <- df_avg2 %>%
  filter(year %in% 2017:2022) %>%
  group_by(year, season) %>%
  summarise(
    # Observed soil temp
    TS_3_mean = mean(TS_3_1_1, na.rm = TRUE),
    TS_3_se = sd(TS_3_1_1, na.rm = TRUE) / sqrt(sum(!is.na(TS_3_1_1))),
    TS_3_n = sum(!is.na(TS_3_1_1)),
    
    # Gap-filled soil temp
    TS_3_gapfilled_mean = mean(TS_3_gapfilled, na.rm = TRUE),
    TS_3_gapfilled_se = sd(TS_3_gapfilled, na.rm = TRUE) / sqrt(sum(!is.na(TS_3_gapfilled))),
    TS_3_gapfilled_n = sum(!is.na(TS_3_gapfilled)),
    
    # Calculate gap-fill percentage
    gapfill_percent = (TS_3_gapfilled_n - TS_3_n) / TS_3_gapfilled_n * 100,
    .groups = 'drop'
  )

# Plot 3: Annual soil temperature trends
p3 <- ggplot(annual_soil_temp_summary) +
  # Gap-filled data (open circles, transparent)
  geom_point(aes(x = year, y = TS_3_gapfilled_mean), 
             shape = 1, size = 3, color = "darkgreen", alpha = 0.7) +
  geom_errorbar(aes(x = year, ymin = TS_3_gapfilled_mean - TS_3_gapfilled_se, 
                    ymax = TS_3_gapfilled_mean + TS_3_gapfilled_se),
                width = 0.1, color = "darkgreen", alpha = 0.7) +
  
  # Observed data (solid circles)
  geom_point(aes(x = year, y = TS_3_mean), 
             shape = 16, size = 3, color = "orange") +
  geom_errorbar(aes(x = year, ymin = TS_3_mean - TS_3_se, 
                    ymax = TS_3_mean + TS_3_se),
                width = 0.1, color = "orange") +
  
  # Add trend lines
  geom_smooth(aes(x = year, y = TS_3_gapfilled_mean), 
              method = "lm", se = TRUE, color = "darkgreen", alpha = 0.3) +
  geom_smooth(aes(x = year, y = TS_3_mean), 
              method = "lm", se = TRUE, color = "orange", alpha = 0.3) +
  
  labs(title = "Annual Soil Temperature Trends (2017-2022)",
       subtitle = "Orange = Observed data, Green = Gap-filled data",
       x = "Year", 
       y = "Soil Temperature (°C)") +
  theme_bw() +
  scale_x_continuous(breaks = 2017:2022)

# Plot 4: Seasonal soil temperature trends (faceted)
p4 <- ggplot(seasonal_soil_temp_summary) +
  # Gap-filled data (open circles)
  geom_point(aes(x = year, y = TS_3_gapfilled_mean), 
             shape = 1, size = 2.5, color = "darkgreen", alpha = 0.7) +
  geom_errorbar(aes(x = year, ymin = TS_3_gapfilled_mean - TS_3_gapfilled_se, 
                    ymax = TS_3_gapfilled_mean + TS_3_gapfilled_se),
                width = 0.1, color = "darkgreen", alpha = 0.7) +
  
  # Observed data (solid circles)
  geom_point(aes(x = year, y = TS_3_mean), 
             shape = 16, size = 2.5, color = "orange") +
  geom_errorbar(aes(x = year, ymin = TS_3_mean - TS_3_se, 
                    ymax = TS_3_mean + TS_3_se),
                width = 0.1, color = "orange") +
  
  # Add trend lines by season
  geom_smooth(aes(x = year, y = TS_3_gapfilled_mean), 
              method = "lm", se = FALSE, color = "darkgreen", alpha = 0.7, size = 0.8) +
  geom_smooth(aes(x = year, y = TS_3_mean), 
              method = "lm", se = FALSE, color = "orange", alpha = 0.7, size = 0.8) +
  
  facet_wrap(~ season, scales = "free_y", ncol = 3) +
  
  labs(title = "Seasonal Soil Temperature Trends by Season (2017-2022)",
       subtitle = "Orange = Observed data, Green = Gap-filled data",
       x = "Year", 
       y = "Soil Temperature (°C)") +
  theme_bw() +
  scale_x_continuous(breaks = c(2017, 2019, 2021)) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# ============================================================================
# SOIL MOISTURE AND VPD
# ============================================================================

# Calculate annual means for soil moisture and VPD
annual_other_summary <- df_avg2 %>%
  filter(year %in% 2017:2022) %>%
  group_by(year) %>%
  summarise(
    # Soil moisture (SWC_3_1_1)
    SWC_3_mean = mean(SWC_3_1_1, na.rm = TRUE),
    SWC_3_se = sd(SWC_3_1_1, na.rm = TRUE) / sqrt(sum(!is.na(SWC_3_1_1))),
    SWC_3_n = sum(!is.na(SWC_3_1_1)),
    
    # VPD
    VPD_mean = mean(VPD, na.rm = TRUE),
    VPD_se = sd(VPD, na.rm = TRUE) / sqrt(sum(!is.na(VPD))),
    VPD_n = sum(!is.na(VPD))
  )

# Calculate seasonal means
seasonal_other_summary <- df_avg2 %>%
  filter(year %in% 2017:2022) %>%
  group_by(year, season) %>%
  summarise(
    # Soil moisture
    SWC_3_mean = mean(SWC_3_1_1, na.rm = TRUE),
    SWC_3_se = sd(SWC_3_1_1, na.rm = TRUE) / sqrt(sum(!is.na(SWC_3_1_1))),
    SWC_3_n = sum(!is.na(SWC_3_1_1)),
    
    # VPD
    VPD_mean = mean(VPD, na.rm = TRUE),
    VPD_se = sd(VPD, na.rm = TRUE) / sqrt(sum(!is.na(VPD))),
    VPD_n = sum(!is.na(VPD)),
    .groups = 'drop'
  )

# Plot 5: Annual soil moisture trends
p5 <- ggplot(annual_other_summary) +
  geom_point(aes(x = year, y = SWC_3_mean), 
             shape = 16, size = 3, color = "brown") +
  geom_errorbar(aes(x = year, ymin = SWC_3_mean - SWC_3_se, 
                    ymax = SWC_3_mean + SWC_3_se),
                width = 0.1, color = "brown") +
  
  # Add trend line
  geom_smooth(aes(x = year, y = SWC_3_mean), 
              method = "lm", se = TRUE, color = "brown", alpha = 0.3) +
  
  labs(title = "Annual Soil Moisture Trends (2017-2022)",
       x = "Year", 
       y = "Soil Water Content (%)") +
  theme_bw() +
  scale_x_continuous(breaks = 2017:2022)

# Plot 6: Seasonal soil moisture trends
p6 <- ggplot(seasonal_other_summary) +
  geom_point(aes(x = year, y = SWC_3_mean), 
             shape = 16, size = 2.5, color = "brown") +
  geom_errorbar(aes(x = year, ymin = SWC_3_mean - SWC_3_se, 
                    ymax = SWC_3_mean + SWC_3_se),
                width = 0.1, color = "brown") +
  
  # Add trend lines by season
  geom_smooth(aes(x = year, y = SWC_3_mean), 
              method = "lm", se = FALSE, color = "brown", alpha = 0.7, size = 0.8) +
  
  facet_wrap(~ season, scales = "free_y", ncol = 3) +
  
  labs(title = "Seasonal Soil Moisture Trends by Season (2017-2022)",
       x = "Year", 
       y = "Soil Water Content (%)") +
  theme_bw() +
  scale_x_continuous(breaks = c(2017, 2019, 2021)) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# Plot 7: Annual VPD trends
p7 <- ggplot(annual_other_summary) +
  geom_point(aes(x = year, y = VPD_mean), 
             shape = 16, size = 3, color = "purple") +
  geom_errorbar(aes(x = year, ymin = VPD_mean - VPD_se, 
                    ymax = VPD_mean + VPD_se),
                width = 0.1, color = "purple") +
  
  # Add trend line
  geom_smooth(aes(x = year, y = VPD_mean), 
              method = "lm", se = TRUE, color = "purple", alpha = 0.3) +
  
  labs(title = "Annual Vapor Pressure Deficit Trends (2017-2022)",
       x = "Year", 
       y = "VPD (hPa)") +
  theme_bw() +
  scale_x_continuous(breaks = 2017:2022)

# Plot 8: Seasonal VPD trends
p8 <- ggplot(seasonal_other_summary) +
  geom_point(aes(x = year, y = VPD_mean), 
             shape = 16, size = 2.5, color = "purple") +
  geom_errorbar(aes(x = year, ymin = VPD_mean - VPD_se, 
                    ymax = VPD_mean + VPD_se),
                width = 0.1, color = "purple") +
  
  # Add trend lines by season
  geom_smooth(aes(x = year, y = VPD_mean), 
              method = "lm", se = FALSE, color = "purple", alpha = 0.7, size = 0.8) +
  
  facet_wrap(~ season, scales = "free_y", ncol = 3) +
  
  labs(title = "Seasonal VPD Trends by Season (2017-2022)",
       x = "Year", 
       y = "VPD (hPa)") +
  theme_bw() +
  scale_x_continuous(breaks = c(2017, 2019, 2021)) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# ============================================================================
# DISPLAY ALL PLOTS
# ============================================================================

# Display plots
print(p1)  # Annual air temp
print(p2)  # Seasonal air temp
print(p3)  # Annual soil temp
print(p4)  # Seasonal soil temp
print(p5)  # Annual soil moisture
print(p6)  # Seasonal soil moisture
print(p7)  # Annual VPD
print(p8)  # Seasonal VPD

# ============================================================================
# PRINT SUMMARY STATISTICS
# ============================================================================

cat("\n=== AIR TEMPERATURE SUMMARY ===\n")
cat("\nAnnual Air Temperature:\n")
print(annual_temp_summary)
cat("\nSeasonal Air Temperature:\n")
print(seasonal_temp_summary)

cat("\n=== SOIL TEMPERATURE SUMMARY ===\n")
cat("\nAnnual Soil Temperature:\n")
print(annual_soil_temp_summary)
cat("\nSeasonal Soil Temperature:\n")
print(seasonal_soil_temp_summary)

cat("\n=== SOIL MOISTURE AND VPD SUMMARY ===\n")
cat("\nAnnual Summary:\n")
print(annual_other_summary)
cat("\nSeasonal Summary:\n")
print(seasonal_other_summary)

  
```
 

#Seasonal averages for each year, facetwrapped by season 

##prepare seasonal summary dataset by year, set color for each year for consistency across figures 
```{r}
# Seasonal Trends Faceted by Season - All Variables

library(ggplot2)
library(dplyr)

# Prepare seasonal summaries for all variables (2017-2022)
seasonal_summary_all <- df_avg2 %>%
  filter(year %in% 2017:2022) %>%
  group_by(year, season) %>%
  summarise(
    # ERA5 GF Air temperature (gap-filled)
    TA_gapfilled_mean = mean(TA_gapfilled, na.rm = TRUE),
    TA_gapfilled_se = sd(TA_gapfilled, na.rm = TRUE) / sqrt(sum(!is.na(TA_gapfilled))),
    
    # measured Air temperature 
    TA_mean = mean(TA, na.rm = TRUE),
    TA_se = sd(TA, na.rm = TRUE) / sqrt(sum(!is.na(TA))),
    
    # ERA5 GF Soil temperature (gap-filled only)
    TS_3_gapfilled_mean = mean(TS_3_gapfilled, na.rm = TRUE),
    TS_3_gapfilled_se = sd(TS_3_gapfilled, na.rm = TRUE) / sqrt(sum(!is.na(TS_3_gapfilled))),
    
    # Measured Soil temperature 
    TS_3_mean = mean(TS_3_1_1, na.rm = TRUE),
    TS_3_se = sd(TS_3_1_1, na.rm = TRUE) / sqrt(sum(!is.na(TS_3_1_1))),
    
    # Soil moisture
    SWC_3_mean = mean(SWC_3_1_1, na.rm = TRUE),
    SWC_3_se = sd(SWC_3_1_1, na.rm = TRUE) / sqrt(sum(!is.na(SWC_3_1_1))),
    
    # VPD
    VPD_mean = mean(VPD, na.rm = TRUE),
    VPD_se = sd(VPD, na.rm = TRUE) / sqrt(sum(!is.na(VPD))),
    
    # RH - relative humidity 
    RH_mean = mean(RH, na.rm = TRUE),
    RH_se = sd(RH, na.rm = TRUE) / sqrt(sum(!is.na(RH))),
    
    # Sensible heat
    H_mean = mean(H, na.rm = TRUE),
    H_se = sd(H, na.rm = TRUE) / sqrt(sum(!is.na(H))),
    
    # Latent heat
    LE_mean = mean(LE, na.rm = TRUE),
    LE_se = sd(LE, na.rm = TRUE) / sqrt(sum(!is.na(LE))),
    
    # Ground heat
    G_mean = mean(G_1_1_1, na.rm = TRUE),
    G_se = sd(G_1_1_1, na.rm = TRUE) / sqrt(sum(!is.na(G_1_1_1))),
    
    
    
    .groups = 'drop'
  )

# Define consistent year colors
year_colors <- c("2017" = "#E41A1C",  # Red
                 "2018" = "#377EB8",  # Blue
                 "2019" = "#4DAF4A",  # Green
                 "2020" = "#984EA3",  # Purple
                 "2021" = "#FF7F00",  # Orange
                 "2022" = "#A65628")  # Brown

# Convert year to factor for consistent color mapping
seasonal_summary_all$year_factor <- as.factor(seasonal_summary_all$year)
```


####make plots 
```{r}
# ============================================================================
# Plot 1: Air Temperature by Season (Gap-filled only)
# ============================================================================

p_TA <- ggplot(seasonal_summary_all) +
  geom_hline(yintercept = 0, color = "black", linewidth = 0.5) +
  
  geom_point(aes(x = year, y = TA_gapfilled_mean, color = year_factor, group = year), 
             size = 3) +
  geom_errorbar(aes(x = year, ymin = TA_gapfilled_mean - TA_gapfilled_se, 
                    ymax = TA_gapfilled_mean + TA_gapfilled_se, color = year_factor),
                width = 0.2) +
  
  geom_smooth(aes(x = year, y = TA_gapfilled_mean), 
              method = "lm", se = TRUE, color = "black", alpha = 0.2, linewidth = 0.8) +
  
  facet_wrap(~ season, ncol = 3) +
  
  scale_color_manual(values = year_colors) +
  scale_x_continuous(breaks = 2017:2022) +
  
  labs(title = "Seasonal Air Temperature Trends by Season (2017-2022)",
       x = "Year", 
       y = "Air Temperature (°C)") +
  theme_bw() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    axis.title.x = element_text(face = "bold", size = 12),
    axis.title.y = element_text(face = "bold", size = 12),
    axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"),
    axis.text.y = element_text(face = "bold"),
    strip.text = element_text(face = "bold", size = 11),
    legend.position = "none"
  )

# ============================================================================
# Plot 2: Soil Temperature by Season (Gap-filled only)
# ============================================================================

p_TS <- ggplot(seasonal_summary_all) +
  geom_hline(yintercept = 0, color = "black", linewidth = 0.5) +
  
  geom_point(aes(x = year, y = TS_3_gapfilled_mean, color = year_factor, group = year), 
             size = 3) +
  geom_errorbar(aes(x = year, ymin = TS_3_gapfilled_mean - TS_3_gapfilled_se, 
                    ymax = TS_3_gapfilled_mean + TS_3_gapfilled_se, color = year_factor),
                width = 0.2) +
  
  geom_smooth(aes(x = year, y = TS_3_gapfilled_mean), 
              method = "lm", se = TRUE, color = "black", alpha = 0.2, linewidth = 0.8) +
  
  facet_wrap(~ season, ncol = 3) +
  
  scale_color_manual(values = year_colors) +
  scale_x_continuous(breaks = 2017:2022) +
  
  labs(title = "Seasonal Soil Temperature Trends by Season (2017-2022)",
       x = "Year", 
       y = "Soil Temperature (°C)") +
  theme_bw() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    axis.title.x = element_text(face = "bold", size = 12),
    axis.title.y = element_text(face = "bold", size = 12),
    axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"),
    axis.text.y = element_text(face = "bold"),
    strip.text = element_text(face = "bold", size = 11),
    legend.position = "none"
  )

# ============================================================================
# Plot 3: Soil Moisture by Season
# ============================================================================

p_SWC <- ggplot(seasonal_summary_all) +
  geom_hline(yintercept = 0, color = "black", linewidth = 0.5) +
  
  geom_point(aes(x = year, y = SWC_3_mean, color = year_factor, group = year), 
             size = 3) +
  geom_errorbar(aes(x = year, ymin = SWC_3_mean - SWC_3_se, 
                    ymax = SWC_3_mean + SWC_3_se, color = year_factor),
                width = 0.2) +
  
  geom_smooth(aes(x = year, y = SWC_3_mean), 
              method = "lm", se = TRUE, color = "black", alpha = 0.2, linewidth = 0.8) +
  
  facet_wrap(~ season, ncol = 3) +
  
  scale_color_manual(values = year_colors) +
  scale_x_continuous(breaks = 2017:2022) +
  
  labs(title = "Seasonal Soil Moisture Trends by Season (2017-2022)",
       x = "Year", 
       y = "Soil Water Content (%)") +
  theme_bw() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    axis.title.x = element_text(face = "bold", size = 12),
    axis.title.y = element_text(face = "bold", size = 12),
    axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"),
    axis.text.y = element_text(face = "bold"),
    strip.text = element_text(face = "bold", size = 11),
    legend.position = "none"
  )

# ============================================================================
# Plot 4: VPD by Season
# ============================================================================

p_VPD <- ggplot(seasonal_summary_all) +
  geom_hline(yintercept = 0, color = "black", linewidth = 0.5) +
  
  geom_point(aes(x = year, y = VPD_mean, color = year_factor, group = year), 
             size = 3) +
  geom_errorbar(aes(x = year, ymin = VPD_mean - VPD_se, 
                    ymax = VPD_mean + VPD_se, color = year_factor),
                width = 0.2) +
  
  geom_smooth(aes(x = year, y = VPD_mean), 
              method = "lm", se = TRUE, color = "black", alpha = 0.2, linewidth = 0.8) +
  
  facet_wrap(~ season, ncol = 3) +
  
  scale_color_manual(values = year_colors) +
  scale_x_continuous(breaks = 2017:2022) +
  
  labs(title = "Seasonal VPD Trends by Season (2017-2022)",
       x = "Year", 
       y = "VPD (hPa)") +
  theme_bw() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    axis.title.x = element_text(face = "bold", size = 12),
    axis.title.y = element_text(face = "bold", size = 12),
    axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"),
    axis.text.y = element_text(face = "bold"),
    strip.text = element_text(face = "bold", size = 11),
    legend.position = "none"
  )


# ============================================================================
# Plot 5: RH by Season
# ============================================================================

p_RH <- ggplot(seasonal_summary_all) +
  geom_hline(yintercept = 0, color = "black", linewidth = 0.5) +
  
  geom_point(aes(x = year, y = RH_mean, color = year_factor, group = year), 
             size = 3) +
  geom_errorbar(aes(x = year, ymin = RH_mean - RH_se, 
                    ymax = RH_mean + RH_se, color = year_factor),
                width = 0.2) +
  
  geom_smooth(aes(x = year, y = RH_mean), 
              method = "lm", se = TRUE, color = "black", alpha = 0.2, linewidth = 0.8) +
  
  facet_wrap(~ season, ncol = 3) +
  
  scale_color_manual(values = year_colors) +
  scale_x_continuous(breaks = 2017:2022) +
  
  labs(title = "Seasonal RH Trends by Season (2017-2022)",
       x = "Year", 
       y = "RH (%)") +
  theme_bw() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    axis.title.x = element_text(face = "bold", size = 12),
    axis.title.y = element_text(face = "bold", size = 12),
    axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"),
    axis.text.y = element_text(face = "bold"),
    strip.text = element_text(face = "bold", size = 11),
    legend.position = "none"
  )

# ============================================================================
# Plot 6: Sensible Heat (H) by Season
# ============================================================================

p_H <- ggplot(seasonal_summary_all) +
  geom_hline(yintercept = 0, color = "black", linewidth = 0.5) +
  
  geom_point(aes(x = year, y = H_mean, color = year_factor, group = year), 
             size = 3) +
  geom_errorbar(aes(x = year, ymin = H_mean - H_se, 
                    ymax = H_mean + H_se, color = year_factor),
                width = 0.2) +
  
  geom_smooth(aes(x = year, y = H_mean), 
              method = "lm", se = TRUE, color = "black", alpha = 0.2, linewidth = 0.8) +
  
  facet_wrap(~ season, ncol = 3) +
  
  scale_color_manual(values = year_colors) +
  scale_x_continuous(breaks = 2017:2022) +
  
  labs(title = "Seasonal Sensible Heat Flux Trends by Season (2017-2022)",
       x = "Year", 
       y = "H (W/m²)") +
  theme_bw() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    axis.title.x = element_text(face = "bold", size = 12),
    axis.title.y = element_text(face = "bold", size = 12),
    axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"),
    axis.text.y = element_text(face = "bold"),
    strip.text = element_text(face = "bold", size = 11),
    legend.position = "none"
  )

# ============================================================================
# Plot 7: Latent Heat (LE) by Season
# ============================================================================

p_LE <- ggplot(seasonal_summary_all) +
  geom_hline(yintercept = 0, color = "black", linewidth = 0.5) +
  
  geom_point(aes(x = year, y = LE_mean, color = year_factor, group = year), 
             size = 3) +
  geom_errorbar(aes(x = year, ymin = LE_mean - LE_se, 
                    ymax = LE_mean + LE_se, color = year_factor),
                width = 0.2) +
  
  geom_smooth(aes(x = year, y = LE_mean), 
              method = "lm", se = TRUE, color = "black", alpha = 0.2, linewidth = 0.8) +
  
  facet_wrap(~ season, ncol = 3) +
  
  scale_color_manual(values = year_colors) +
  scale_x_continuous(breaks = 2017:2022) +
  
  labs(title = "Seasonal Latent Heat Flux Trends by Season (2017-2022)",
       x = "Year", 
       y = "LE (W/m²)") +
  theme_bw() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    axis.title.x = element_text(face = "bold", size = 12),
    axis.title.y = element_text(face = "bold", size = 12),
    axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"),
    axis.text.y = element_text(face = "bold"),
    strip.text = element_text(face = "bold", size = 11),
    legend.position = "none"
  )


# ============================================================================
# Plot 8: Ground Heat Flux (G) by Season
# ============================================================================

p_G <- ggplot(seasonal_summary_all) +
  geom_hline(yintercept = 0, color = "black", linewidth = 0.5) +
  
  geom_point(aes(x = year, y = G_mean, color = year_factor, group = year), 
             size = 3) +
  geom_errorbar(aes(x = year, ymin = G_mean - G_se, 
                    ymax = G_mean + G_se, color = year_factor),
                width = 0.2) +
  
  geom_smooth(aes(x = year, y = G_mean), 
              method = "lm", se = TRUE, color = "black", alpha = 0.2, linewidth = 0.8) +
  
  facet_wrap(~ season, ncol = 3) +
  
  scale_color_manual(values = year_colors) +
  scale_x_continuous(breaks = 2017:2022) +
  
  labs(title = "Seasonal Ground Heat Flux Trends by Season (2017-2022)",
       x = "Year", 
       y = "G (W/m²)") +
  theme_bw() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    axis.title.x = element_text(face = "bold", size = 12),
    axis.title.y = element_text(face = "bold", size = 12),
    axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"),
    axis.text.y = element_text(face = "bold"),
    strip.text = element_text(face = "bold", size = 11),
    legend.position = "none"
  )
# ============================================================================
# DISPLAY ALL PLOTS
# ============================================================================

print(p_TA)
print(p_TS)
print(p_SWC)
print(p_VPD)
print(p_RH)
print(p_H)
print(p_LE)
print(p_G)
```
 
####Adj figure to take out the trendline and trendline SE-shading 
```{r}
# Seasonal Trends Faceted by Season - All Variables

# ============================================================================
# Plot 1: Air Temperature by Season (ERA5 Gap-filled)
# ============================================================================

p_TA <- ggplot(seasonal_summary_all) +
  geom_hline(yintercept = 0, color = "black", linewidth = 0.5) +
  
  geom_point(aes(x = year, y = TA_gapfilled_mean, color = year_factor, group = year), 
             size = 3) +
  geom_errorbar(aes(x = year, ymin = TA_gapfilled_mean - TA_gapfilled_se, 
                    ymax = TA_gapfilled_mean + TA_gapfilled_se, color = "black"), # color = year_factor),
                width = 0.3, linewidth = 0.7, alpha = 1 ) +
  
  # geom_smooth(aes(x = year, y = TA_gapfilled_mean), 
  #             method = "auto", se = TRUE, color = "black", alpha = 0.2, linewidth = 0.8) +
  
  facet_wrap(~ season, ncol = 3) +
  
  scale_color_manual(values = year_colors) +
  scale_x_continuous(breaks = 2017:2022) +
  
  labs(title = "Seasonal Air Temperature Trends by Season (2017-2022)",
       x = "Year", 
       y = "Air Temperature (°C)") +
  theme_bw() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    axis.title.x = element_text(face = "bold", size = 12),
    axis.title.y = element_text(face = "bold", size = 12),
    axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"),
    axis.text.y = element_text(face = "bold"),
    strip.text = element_text(face = "bold", size = 11),
    legend.position = "none"
  )


# ============================================================================
# Plot 2: Soil Temperature by Season (ERA5 Gap-filled)
# ============================================================================

p_TS <- ggplot(seasonal_summary_all) +
  geom_hline(yintercept = 0, color = "black", linewidth = 0.5) +
  
  geom_point(aes(x = year, y = TS_3_gapfilled_mean, color = year_factor, group = year), 
             size = 3) +
  geom_errorbar(aes(x = year, ymin = TS_3_gapfilled_mean - TS_3_gapfilled_se, 
                    ymax = TS_3_gapfilled_mean + TS_3_gapfilled_se, color = "black"), # color = year_factor),
                 width = 0.3, linewidth = 0.7, alpha = 1 ) +
  
  # geom_smooth(aes(x = year, y = TS_3_gapfilled_mean), 
  #             method = "auto", se = TRUE, color = "black", alpha = 0.2, linewidth = 0.8) +
  
  facet_wrap(~ season, ncol = 3) +
  
  scale_color_manual(values = year_colors) +
  scale_x_continuous(breaks = 2017:2022) +
  
  labs(title = "Seasonal Soil Temperature Trends by Season (2017-2022)",
       x = "Year", 
       y = "Soil Temperature (°C)") +
  theme_bw() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    axis.title.x = element_text(face = "bold", size = 12),
    axis.title.y = element_text(face = "bold", size = 12),
    axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"),
    axis.text.y = element_text(face = "bold"),
    strip.text = element_text(face = "bold", size = 11),
    legend.position = "none"
  )

# ============================================================================
# Plot 3: Soil Moisture by Season
# ============================================================================

p_SWC <- ggplot(seasonal_summary_all) +
  geom_hline(yintercept = 0, color = "black", linewidth = 0.5) +
  
  geom_point(aes(x = year, y = SWC_3_mean, color = year_factor, group = year), 
             size = 3) +
  geom_errorbar(aes(x = year, ymin = SWC_3_mean - SWC_3_se, 
                    ymax = SWC_3_mean + SWC_3_se, color = "black"), # color = year_factor),
                width = 0.3, linewidth = 0.7, alpha = 1 ) +
  
  # geom_smooth(aes(x = year, y = SWC_3_mean), 
  #             method = "auto", se = TRUE, color = "black", alpha = 0.2, linewidth = 0.8) +
  
  facet_wrap(~ season, ncol = 3) +
  
  scale_color_manual(values = year_colors) +
  scale_x_continuous(breaks = 2017:2022) +
  
  labs(title = "Seasonal Soil Moisture Trends by Season (2017-2022)",
       x = "Year", 
       y = "Soil Water Content (%)") +
  theme_bw() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    axis.title.x = element_text(face = "bold", size = 12),
    axis.title.y = element_text(face = "bold", size = 12),
    axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"),
    axis.text.y = element_text(face = "bold"),
    strip.text = element_text(face = "bold", size = 11),
    legend.position = "none"
  )

# ============================================================================
# Plot 4: RH by Season
# ============================================================================

p_RH <- ggplot(seasonal_summary_all) +
  geom_hline(yintercept = 0, color = "black", linewidth = 0.5) +
  
  geom_point(aes(x = year, y = RH_mean, color = year_factor, group = year), 
             size = 3) +
  geom_errorbar(aes(x = year, ymin = RH_mean - RH_se, 
                    ymax = RH_mean + RH_se, color = "black"), # color = year_factor),
                width = 0.3, linewidth = 0.7, alpha = 1 ) +
  
  # geom_smooth(aes(x = year, y = RH_mean), 
  #             method = "auto", se = TRUE, color = "black", alpha = 0.2, linewidth = 0.8) +
  
  facet_wrap(~ season, ncol = 3) +
  
  scale_color_manual(values = year_colors) +
  scale_x_continuous(breaks = 2017:2022) +
  
  labs(title = "Seasonal RH Trends by Season (2017-2022)",
       x = "Year", 
       y = "RH (%)") +
  theme_bw() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    axis.title.x = element_text(face = "bold", size = 12),
    axis.title.y = element_text(face = "bold", size = 12),
    axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"),
    axis.text.y = element_text(face = "bold"),
    strip.text = element_text(face = "bold", size = 11),
    legend.position = "none"
  )

# ============================================================================
# Plot 5: VPD by Season
# ============================================================================

p_VPD <- ggplot(seasonal_summary_all) +
  geom_hline(yintercept = 0, color = "black", linewidth = 0.5) +
  
  geom_point(aes(x = year, y = VPD_mean, color = year_factor, group = year), 
             size = 3) +
  geom_errorbar(aes(x = year, ymin = VPD_mean - VPD_se, 
                    ymax = VPD_mean + VPD_se, color = "black"), # color = year_factor),
                 width = 0.3, linewidth = 0.7, alpha = 1 ) +
  
  # geom_smooth(aes(x = year, y = VPD_mean), 
  #             method = "auto", se = TRUE, color = "black", alpha = 0.2, linewidth = 0.8) +
  
  facet_wrap(~ season, ncol = 3) +
  
  scale_color_manual(values = year_colors) +
  scale_x_continuous(breaks = 2017:2022) +
  
  labs(title = "Seasonal VPD Trends by Season (2017-2022)",
       x = "Year", 
       y = "VPD (hPa)") +
  theme_bw() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    axis.title.x = element_text(face = "bold", size = 12),
    axis.title.y = element_text(face = "bold", size = 12),
    axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"),
    axis.text.y = element_text(face = "bold"),
    strip.text = element_text(face = "bold", size = 11),
    legend.position = "none"
  )

# ============================================================================
# Plot 6: Sensible Heat (H) by Season
# ============================================================================

p_H <- ggplot(seasonal_summary_all) +
  geom_hline(yintercept = 0, color = "black", linewidth = 0.5) +
  
  geom_point(aes(x = year, y = H_mean, color = year_factor, group = year), 
             size = 3) +
  geom_errorbar(aes(x = year, ymin = H_mean - H_se, 
                    ymax = H_mean + H_se, color = "black"), # color = year_factor),
                 width = 0.3, linewidth = 0.7, alpha = 1 ) +
  
  #geom_smooth(aes(x = year, y = H_mean), 
             # method = "auto", se = TRUE, color = "black", alpha = 0.2, linewidth = 0.8) +
  
  facet_wrap(~ season, ncol = 3) +
  
  scale_color_manual(values = year_colors) +
  scale_x_continuous(breaks = 2017:2022) +
  
  labs(title = "Seasonal Sensible Heat Flux Trends by Season (2017-2022)",
       x = "Year", 
       y = "H (W/m²)") +
  theme_bw() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    axis.title.x = element_text(face = "bold", size = 12),
    axis.title.y = element_text(face = "bold", size = 12),
    axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"),
    axis.text.y = element_text(face = "bold"),
    strip.text = element_text(face = "bold", size = 11),
    legend.position = "none"
  )

# ============================================================================
# Plot 7: Latent Heat (LE) by Season
# ============================================================================

p_LE <- ggplot(seasonal_summary_all) +
  geom_hline(yintercept = 0, color = "black", linewidth = 0.5) +
  
  geom_point(aes(x = year, y = LE_mean, color = year_factor, group = year), 
             size = 3) +
  geom_errorbar(aes(x = year, ymin = LE_mean - LE_se, 
                    ymax = LE_mean + LE_se, color = "black"), #color = year_factor),
                 width = 0.3, linewidth = 0.7, alpha = 1 ) +
  
  #geom_smooth(aes(x = year, y = LE_mean), 
             # method = "auto", se = TRUE, color = "black", alpha = 0.2, linewidth = 0.8) +
  
  facet_wrap(~ season, ncol = 3) +
  
  scale_color_manual(values = year_colors) +
  scale_x_continuous(breaks = 2017:2022) +
  
  labs(title = "Seasonal Latent Heat Flux Trends by Season (2017-2022)",
       x = "Year", 
       y = "LE (W/m²)") +
  theme_bw() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    axis.title.x = element_text(face = "bold", size = 12),
    axis.title.y = element_text(face = "bold", size = 12),
    axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"),
    axis.text.y = element_text(face = "bold"),
    strip.text = element_text(face = "bold", size = 11),
    legend.position = "none"
  )

# ============================================================================
# Plot 8: Ground Heat Flux (G) by Season
# ============================================================================

p_G <- ggplot(seasonal_summary_all) +
  geom_hline(yintercept = 0, color = "black", linewidth = 0.5) +
  
  geom_point(aes(x = year, y = G_mean, color = year_factor, group = year), 
             size = 3) +
  geom_errorbar(aes(x = year, ymin = G_mean - G_se, 
                    ymax = G_mean + G_se, color = "black"),
                 width = 0.3, linewidth = 0.7, alpha = 1 ) +
  
  # geom_smooth(aes(x = year, y = G_mean), 
  #             method = "lm", se = TRUE, color = "black", alpha = 0.2, linewidth = 0.8) +
  
  facet_wrap(~ season, ncol = 3) +
  
  scale_color_manual(values = year_colors) +
  scale_x_continuous(breaks = 2017:2022) +
  
  labs(title = "Seasonal Ground Heat Flux Trends by Season (2017-2022)",
       x = "Year", 
       y = "G (W/m²)") +
  theme_bw() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    axis.title.x = element_text(face = "bold", size = 12),
    axis.title.y = element_text(face = "bold", size = 12),
    axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"),
    axis.text.y = element_text(face = "bold"),
    strip.text = element_text(face = "bold", size = 11),
    legend.position = "none"
  )

# ============================================================================
# DISPLAY ALL PLOTS  
# ============================================================================

print(p_TA)
print(p_TS)
print(p_SWC)
print(p_RH)
print(p_VPD)
print(p_H)
print(p_LE)
print(p_G)


#note, SE is present but some error bars are so small compared to the scale of the fig they appear as if they're not showing up...but if you change scale = "free", you can see them, this just doesn't maintain consistent axis ranges among seasons
```


#Arrange figures into one 
```{r}
library(gridExtra)
library(grid)
library(ggplot2)

# Remove titles from all plots
p_TA <- p_TA + labs(title = NULL)
p_TS <- p_TS + labs(title = NULL)
p_SWC <- p_SWC + labs(title = NULL)
p_VPD <- p_VPD + labs(title = NULL)
p_RH <- p_RH + labs(title = NULL)
p_H <- p_H + labs(title = NULL)
p_LE <- p_LE + labs(title = NULL)
p_G <- p_G + labs(title = NULL)


# Extract the legend from one of your existing plots
# First, temporarily modify one plot to show the legend
p_with_legend <- p_TA + 
  theme(legend.position = "right") +
  scale_color_manual(values = year_colors, name = "Year")

# Function to extract legend
get_legend <- function(myggplot) {
  tmp <- ggplot_gtable(ggplot_build(myggplot))
  leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
  legend <- tmp$grobs[[leg]]
  return(legend)
}

legend <- get_legend(p_with_legend)

# Arrange all your existing plots with the shared legend
seasonal_MeanMet_by_yr <- grid.arrange(
  arrangeGrob(p_TA, p_TS, p_SWC, p_VPD, p_RH, p_H, p_LE, p_G, ncol = 2),
  legend,
  ncol = 2,
  widths = c(10, 1.5),
  top = textGrob("Seasonal Environmental Trends (2017-2022)", 
                 gp = gpar(fontsize = 16, fontface = "bold"))
)
```
#Save figure 

```{r}

ggsave("C:/Users/kkent/Documents/Github Flux Network/Council_Flux_Analysis_Paper/Council Figures/seasonal_MeanMet_vars_by_year_plot.png", seasonal_MeanMet_by_yr, 
        width = 15, height = 15, dpi = 600)
```

```{r}
sum(is.na(df$FC)) #82174
sum(is.na(df$FCH4)) #91231   # difference of 9057 obs for FC vs FCH4

sum(is.na(df_avg2$FC)) # 1614
sum(is.na(df_avg2$FCH4)) # 1855   - diff of 241 obs for FC vs FCH4

```

#Autocorrelation check 

Autocorr test - just in case, though since these are seasonal averages among years, autocorr should not be an issue

 * Want to test autocorr among years, but within each season* 

#Autocorr
```{r}
# For each season separately:
winter_data <- seasonal_summary_all %>% 
  filter(season == "Winter") %>%
  arrange(year) #%>%
  #pull(TS_3_gapfilled_mean)  # or whatever variable



# Check autocorrelation
acf(winter_data$TS_3_gapfilled_mean, lag.max = 2, plot = TRUE)

# Or get the lag-1 autocorrelation value
lag1_autocorr <- acf(winter_data$TS_3_gapfilled_mean, lag.max = 1, plot = FALSE)$acf[2]

#Ljung-Box test for timeseries models / data -- if p<0.05, there is autocorr and residuals are not independent - not working here, not sure why
#Box.test(winter_data$TS_3_gapfilled_mean, lag = 20, type = "Ljung-Box") #p<0.001


#Durbin watson test for when a model has been fitted - checks if residuals are autocorrelated - DW = 2 = no autocorr, DW < 2 = pos autocorr, DW > 2 = neg autocorr

#install.packages("lmtest")   
library(lmtest)

lm_test<- lm(TS_3_gapfilled_mean ~ year, data = winter_data)
dwtest(lm_test)
acf(residuals(lm_test), main = "ACF of model residuals")

#not doing all tests, these seem ok / not autocorr 

#growing season
#SWC: ok 
#Air temp GF: ok
#soil temp GF: ok 
#LE:
#H:
#G:
#RH: 


#fall
#SWC: ok 
#Air temp GF: ok 
#soil temp GF: ok 
#LE:
#H:
#G:
#RH: 


#winter
#SWC: ok
#Air temp GF: ok
#soil temp GF: ok 
#LE:
#H:
#G:
#RH: 


```


#Stats - differences in variables among years within each season 


#Important: this is looking at the normality / heterogeneity of the annual means for each season, for each year (so n = 6) - shapiro-wilkes will have very low power with this low sample size so rely on QQ-plots and histograms 
```{r}
# Visual Diagnostics for Assumption Testing
# QQ-plots and Histograms for normality assessment

library(ggplot2)
library(dplyr)
library(gridExtra)

# Prepare seasonal summaries
# seasonal_summary_all <- df_avg2 %>%
#   filter(year %in% 2017:2022) %>%
#   group_by(year, season) %>%
#   summarise(
#     TA_gapfilled_mean = mean(TA_gapfilled, na.rm = TRUE),
#     TS_3_gapfilled_mean = mean(TS_3_gapfilled, na.rm = TRUE),
#     SWC_3_mean = mean(SWC_3_1_1, na.rm = TRUE),
#     VPD_mean = mean(VPD, na.rm = TRUE),
#     H_mean = mean(H, na.rm = TRUE),
#     LE_mean = mean(LE, na.rm = TRUE),
#     .groups = 'drop'
#   )

# ============================================================================
# FUNCTION: Create diagnostic plots for a variable
# ============================================================================

create_diagnostic_plots <- function(data, var_name, var_label) {
  
  seasons <- unique(data$season)
  plot_list <- list()
  
  for (s in seasons) {
    season_data <- data %>% filter(season == s)
    y_vals <- season_data[[var_name]]
    
    # Skip if too many NAs
    if (sum(!is.na(y_vals)) < 4) next
    
    # Shapiro test
    shapiro_p <- round(shapiro.test(y_vals)$p.value, 4)
    normal_status <- ifelse(shapiro_p > 0.05, "Normal", "Non-normal")
    
    # QQ-plot
    qq_plot <- ggplot(data.frame(sample = y_vals), aes(sample = sample)) +
      stat_qq() +
      stat_qq_line(color = "red", linewidth = 1) +
      labs(title = paste(s, "- QQ Plot"),
           subtitle = paste("Shapiro p =", shapiro_p, "-", normal_status),
           x = "Theoretical Quantiles",
           y = "Sample Quantiles") +
      theme_bw() +
      theme(
        plot.title = element_text(face = "bold", size = 10),
        plot.subtitle = element_text(size = 9),
        axis.title = element_text(face = "bold", size = 9),
        axis.text = element_text(face = "bold", size = 8)
      )
    
    # Histogram
    hist_plot <- ggplot(data.frame(value = y_vals), aes(x = value)) +
      geom_histogram(bins = 5, fill = "steelblue", color = "black", alpha = 0.7) +
      geom_density(aes(y = after_stat(count)), color = "red", linewidth = 1) +
      labs(title = paste(s, "- Histogram"),
           x = var_label,
           y = "Count") +
      theme_bw() +
      theme(
        plot.title = element_text(face = "bold", size = 10),
        axis.title = element_text(face = "bold", size = 9),
        axis.text = element_text(face = "bold", size = 8)
      )
    
    # Residuals plot (from linear model)
    # Remove NAs to ensure consistent lengths
    complete_cases <- complete.cases(y_vals, season_data$year)
    y_complete <- y_vals[complete_cases]
    x_complete <- season_data$year[complete_cases]
    
    lm_model <- lm(y_complete ~ x_complete)
    resid_data <- data.frame(
      fitted = fitted(lm_model),
      residuals = residuals(lm_model),
      year = x_complete
    )
    
    resid_plot <- ggplot(resid_data, aes(x = fitted, y = residuals)) +
      geom_point(size = 3, color = "steelblue") +
      geom_hline(yintercept = 0, linetype = "dashed", color = "red", linewidth = 1) +
      geom_smooth(method = "loess", se = FALSE, color = "black", linewidth = 0.8) +
      labs(title = paste(s, "- Residuals vs Fitted"),
           x = "Fitted Values",
           y = "Residuals") +
      theme_bw() +
      theme(
        plot.title = element_text(face = "bold", size = 10),
        axis.title = element_text(face = "bold", size = 9),
        axis.text = element_text(face = "bold", size = 8)
      )
    
    plot_list[[s]] <- list(qq = qq_plot, hist = hist_plot, resid = resid_plot)
  }
  
  return(plot_list)
}

# ============================================================================
# CREATE DIAGNOSTIC PLOTS FOR ALL VARIABLES
# ============================================================================


cat("Creating diagnostic plots for assumption testing...\n\n")

# ERA5-GF Air Temperature
cat("--- AIR TEMPERATURE (Gap-filled) ---\n")
GF_ta_diag <- create_diagnostic_plots(seasonal_summary_all, 
                                    "TA_gapfilled_mean", 
                                    "GF Air Temperature (°C)")

# Arrange plots in a grid for each season
for (season in names(GF_ta_diag)) {
  grid.arrange(GF_ta_diag[[season]]$qq, 
               GF_ta_diag[[season]]$hist, 
               GF_ta_diag[[season]]$resid,
               ncol = 3,
               top = paste("GF Air Temperature -", season))
}

# Air Temperature
cat("--- AIR TEMPERATURE (measured) ---\n")
ta_diag <- create_diagnostic_plots(seasonal_summary_all, 
                                    "TA_mean", 
                                    "Air Temperature (°C)")

# Arrange plots in a grid for each season
for (season in names(ta_diag)) {
  grid.arrange(ta_diag[[season]]$qq, 
               ta_diag[[season]]$hist, 
               ta_diag[[season]]$resid,
               ncol = 3,
               top = paste("Air Temperature -", season))
}

# ERA5-GF Soil Temperature
cat("\n--- SOIL TEMPERATURE (Gap-filled) ---\n")
GF_ts_diag <- create_diagnostic_plots(seasonal_summary_all, 
                                    "TS_3_gapfilled_mean", 
                                    "GF Soil Temperature (°C)")

for (season in names(GF_ts_diag)) {
  grid.arrange(GF_ts_diag[[season]]$qq, 
               GF_ts_diag[[season]]$hist, 
               GF_ts_diag[[season]]$resid,
               ncol = 3,
               top = paste("GF Soil Temperature -", season))
}

# Measured Soil Temperature
cat("\n--- SOIL TEMPERATURE (measured) ---\n")
ts_diag <- create_diagnostic_plots(seasonal_summary_all, 
                                    "TS_3_mean", 
                                    "Soil Temperature (°C)")

for (season in names(ts_diag)) {
  grid.arrange(ts_diag[[season]]$qq, 
               ts_diag[[season]]$hist, 
               ts_diag[[season]]$resid,
               ncol = 3,
               top = paste("Soil Temperature -", season))
}

# Soil Moisture
cat("\n--- SOIL MOISTURE ---\n")
swc_diag <- create_diagnostic_plots(seasonal_summary_all, 
                                     "SWC_3_mean", 
                                     "Soil Moisture (%)")

for (season in names(swc_diag)) {
  grid.arrange(swc_diag[[season]]$qq, 
               swc_diag[[season]]$hist, 
               swc_diag[[season]]$resid,
               ncol = 3,
               top = paste("Soil Moisture -", season))
}

# RH
cat("\n--- RH ---\n")
rh_diag <- create_diagnostic_plots(seasonal_summary_all, 
                                     "RH_mean", 
                                     "SRH (%)")

for (season in names(rh_diag)) {
  grid.arrange(rh_diag[[season]]$qq, 
               rh_diag[[season]]$hist, 
               rh_diag[[season]]$resid,
               ncol = 3,
               top = paste("RH -", season))
}

# VPD
cat("\n--- VAPOR PRESSURE DEFICIT ---\n")
vpd_diag <- create_diagnostic_plots(seasonal_summary_all, 
                                     "VPD_mean", 
                                     "VPD (hPa)")

for (season in names(vpd_diag)) {
  grid.arrange(vpd_diag[[season]]$qq, 
               vpd_diag[[season]]$hist, 
               vpd_diag[[season]]$resid,
               ncol = 3,
               top = paste("VPD -", season))
}

# Sensible Heat
cat("\n--- SENSIBLE HEAT FLUX ---\n")
h_diag <- create_diagnostic_plots(seasonal_summary_all, 
                                   "H_mean", 
                                   "Sensible Heat (W/m²)")

for (season in names(h_diag)) {
  grid.arrange(h_diag[[season]]$qq, 
               h_diag[[season]]$hist, 
               h_diag[[season]]$resid,
               ncol = 3,
               top = paste("Sensible Heat -", season))
}

# Latent Heat
cat("\n--- LATENT HEAT FLUX ---\n")
le_diag <- create_diagnostic_plots(seasonal_summary_all, 
                                    "LE_mean", 
                                    "Latent Heat (W/m²)")

for (season in names(le_diag)) {
  grid.arrange(le_diag[[season]]$qq, 
               le_diag[[season]]$hist, 
               le_diag[[season]]$resid,
               ncol = 3,
               top = paste("Latent Heat -", season))
}

# Ground heat flux 
cat("\n--- Ground HEAT FLUX ---\n")
g_diag <- create_diagnostic_plots(seasonal_summary_all, 
                                    "G_mean", 
                                    "Ground Heat Flux (W/m²)")

for (season in names(g_diag)) {
  grid.arrange(g_diag[[season]]$qq, 
               g_diag[[season]]$hist, 
               g_diag[[season]]$resid,
               ncol = 3,
               top = paste("Ground Heat -", season))
}

cat("\n\nInterpretation Guide:\n")
cat("====================\n")
cat("QQ-Plot: Points should fall along the red line for normal data\n")
cat("  - Points above line = right skew (heavy upper tail)\n")
cat("  - Points below line = left skew (heavy lower tail)\n")
cat("  - S-shape = data has both tails heavier/lighter than normal\n\n")
cat("Histogram: Should be approximately bell-shaped for normal data\n\n")
cat("Residuals Plot: Should show random scatter around 0 line\n")
cat("  - Pattern/curve = non-linear relationship\n")
cat("  - Funnel shape = heteroscedasticity (non-constant variance)\n\n")
cat("Shapiro-Wilk p-value: > 0.05 suggests normality\n") #but important to note that with n=6, shapiro wilkes has VERY low power, so rely on QQ-plot & histogram & use your judgement 

#QQ plots don't look terrible, but the histograms don't look like normal distributions most times 
```

#Spot-test: Verifying the above output from Claude's code with stepwise tests for normality and homogeneity of variance 

#Test normality of avg annual met vars within each season 
```{r}
library(dplyr)

#swap out variables of interest to spot check 
seasonal_summary_all %>% #this is the dataset with the seasonal avg by year 
#filter(complete.cases(season, VPD)) %>%   # remove NA values
  group_by(season) %>%
  summarize(
    shapiro_p = shapiro.test(TS_3_mean)$p.value,
    normal = ifelse(shapiro_p > 0.05, "Yes", "No")
          )
#TA_gapfilled air: all yes - agreement 
#TS_3: all yes 


#VPD
seasonal_summary_all %>% #this is the dataset with the seasonal avg by year 
#filter(complete.cases(season, VPD)) %>%   # remove NA values
  group_by(season) %>%
  summarize(
    shapiro_p = shapiro.test(VPD_mean)$p.value,
    normal = ifelse(shapiro_p > 0.05, "Yes", "No")
          )
#VPD: winter no, summer / fall yes 


# QQ plots for each season 
qqnorm(seasonal_summary_all$VPD_mean[seasonal_summary_all$season == "Growing Season"]) #looks ok..?
qqline(seasonal_summary_all$VPD_mean[seasonal_summary_all$season == "Growing Season"], col = "red")

qqnorm(seasonal_summary_all$SWC_3_mean[seasonal_summary_all$season == "Growing Season"]) 
qqline(seasonal_summary_all$SWC_3_mean[seasonal_summary_all$season == "Growing Season"], col = "red")

ggplot(seasonal_summary_all, aes(x = VPD_mean)) +
  geom_histogram(bins = 5, fill = "steelblue", color = "black", alpha = 0.7) +
  geom_density(aes(y = after_stat(count)), color = "red", linewidth = 1) +
  theme_bw() +
  facet_wrap(~season, scales = "free_x") +  # Added scales = "free_x"
  labs(title = "VPD Distribution by Season (Annual Means)",
       x = "VPD (hPa)",
       y = "Count")


```

##### starts with testing lm assumptions, pivots to non-parametric if assumptions are violated, uses spearman's corr & kendall's tau (similar to spearman corr but supposedly better for small sample sizes and here we only have 6 yrs so n = 6) - streamlined function code by Claude 
```{r}

# Tests for significant trends in environmental variables by season (2017-2022)

library(dplyr)
library(broom)



# ============================================================================
# FUNCTION: Test trends for a variable within each season
# ============================================================================

test_seasonal_trends <- function(data, var_name, var_label, units) {
  
  results_list <- list()
  seasons <- unique(data$season)
  
  for (s in seasons) {
    season_data <- data %>% filter(season == s)
    
    # Extract variable values
    y_vals <- season_data[[var_name]]
    x_vals <- season_data$year
    
    # Skip if too many NAs
    if (sum(!is.na(y_vals)) < 4) {
      next
    }
    
    # Test normality (Shapiro-Wilk) - tests normality of raw data, but for this we want residuals of the fitted lm 
    #shapiro_p <- shapiro.test(y_vals)$p.value
    
    # Linear regression
    lm_model <- lm(y_vals ~ x_vals)
    lm_summary <- summary(lm_model)
    
    #Test normality of RESIDUALS (not raw data)
    residuals_vals <- residuals(lm_model)
    shapiro_p <- shapiro.test(residuals_vals)$p.value
    
    # Extract key statistics
    slope <- coef(lm_model)[2]
    slope_se <- summary(lm_model)$coefficients[2, 2]
    slope_p <- summary(lm_model)$coefficients[2, 4]
    r_squared <- lm_summary$r.squared
    adj_r_squared <- lm_summary$adj.r.squared
    
    # Mann-Kendall test (non-parametric trend test) - run on the raw/observed data 
    # Kendall's tau correlation
    kendall_test <- cor.test(x_vals, y_vals, method = "kendall")
    kendall_tau <- kendall_test$estimate
    kendall_p <- kendall_test$p.value
    
    # Spearman correlation (another non-parametric option) - run on the raw/observed data 
    spearman_test <- cor.test(x_vals, y_vals, method = "spearman")
    spearman_rho <- spearman_test$estimate
    spearman_p <- spearman_test$p.value
    
    # # Calculate percent change over period - not sure this is working properly...
    # first_val <- y_vals[1]
    # last_val <- y_vals[length(y_vals)]
    # total_change <- last_val - first_val
    # pct_change <- (total_change / abs(first_val)) * 100
    
    # Calculate change per year
   # change_per_year <- slope
    
    # Store results
    results_list[[s]] <- data.frame(
      season = s,
      variable = var_label,
      units = units,
      n_years = length(y_vals),
      mean_value = mean(y_vals, na.rm = TRUE),
      
      # Normality test
      shapiro_p = shapiro_p,
      normal = ifelse(shapiro_p > 0.05, "Yes", "No"),
      
      # Linear model
      slope = slope,
      slope_se = slope_se,
      slope_p = slope_p,
      r_squared = r_squared,
      adj_r_squared = adj_r_squared,
      
      # Non-parametric tests
      kendall_tau = kendall_tau,
      kendall_p = kendall_p,
      spearman_rho = spearman_rho,
      spearman_p = spearman_p,
      
      # # Trend magnitude
      # change_per_year = change_per_year,
      # total_change_2017_2022 = total_change,
      # percent_change_2017_2022 = pct_change,
      
      # Significance (using appropriate test)
      significant = ifelse(shapiro_p > 0.05, 
                          ifelse(slope_p < 0.05, "Yes*", "No"),
                          ifelse(kendall_p < 0.05, "Yes**", "No")),
      
      stringsAsFactors = FALSE
    )
  }
  
  # Combine all seasons
  do.call(rbind, results_list)
}

# ============================================================================
# RUN TESTS FOR ALL VARIABLES
# ============================================================================

cat("============================================================\n")
cat("ANNUAL TREND ANALYSIS BY SEASON (2017-2022)\n")
cat("============================================================\n\n")

cat("Significance codes:\n")
cat("* = Linear regression (data normal)\n")
cat("** = Kendall's tau (data non-normal)\n")
cat("p < 0.05 = significant trend\n\n")

# GF Air Temperature
cat("\n--- AIR TEMPERATURE (Gap-filled) ---\n")
gf_ta_results <- test_seasonal_trends(seasonal_summary_all, 
                                    "TA_gapfilled_mean", 
                                    "GF Air Temperature", 
                                    "°C")
print(gf_ta_results[, c("season", "mean_value", "normal", "slope", "slope_p", 
                     "kendall_tau", "kendall_p", #"change_per_year", #"percent_change_2017_2022"
                     "spearman_rho", "spearman_p", "significant")])

# Air Temperature (measured)
cat("\n--- AIR TEMPERATURE (measured) ---\n")
ta_results <- test_seasonal_trends(seasonal_summary_all, 
                                    "TA_mean", 
                                    "Air Temperature", 
                                    "°C")
print(ta_results[, c("season", "mean_value", "normal", "slope", "slope_p", 
                     "kendall_tau", "kendall_p", #"change_per_year", 
                     "spearman_rho", "spearman_p", "significant")])


# GF Soil Temperature
cat("\n--- SOIL TEMPERATURE (Gap-filled) ---\n")
gf_ts_results <- test_seasonal_trends(seasonal_summary_all, 
                                    "TS_3_gapfilled_mean", 
                                    "GF Soil Temperature", 
                                    "°C")
print(gf_ts_results[, c("season", "mean_value", "normal", "slope", "slope_p", 
                     "kendall_tau", "kendall_p", #"change_per_year", 
                     "spearman_rho", "spearman_p", "significant")])

# Soil Temperature (measured)
cat("\n--- SOIL TEMPERATURE ---\n")
ts_results <- test_seasonal_trends(seasonal_summary_all, 
                                    "TS_3_mean", 
                                    "Soil Temperature", 
                                    "°C")
print(ts_results[, c("season", "mean_value", "normal", "slope", "slope_p", 
                     "kendall_tau", "kendall_p", #"change_per_year", 
                     "spearman_rho", "spearman_p", "significant")])


# Soil Moisture
cat("\n--- SOIL MOISTURE ---\n")
swc_results <- test_seasonal_trends(seasonal_summary_all, 
                                     "SWC_3_mean", 
                                     "Soil Moisture", 
                                     "%")
print(swc_results[, c("season", "mean_value", "normal", "slope", "slope_p", 
                      "kendall_tau", "kendall_p", #"change_per_year", 
                      "spearman_rho", "spearman_p", "significant")])

# VPD
cat("\n--- VAPOR PRESSURE DEFICIT ---\n")
vpd_results <- test_seasonal_trends(seasonal_summary_all, 
                                     "VPD_mean", 
                                     "VPD", 
                                     "hPa")
print(vpd_results[, c("season", "mean_value", "normal", "slope", "slope_p", 
                      "kendall_tau", "kendall_p", #"change_per_year", 
                      "spearman_rho", "spearman_p", "significant")])

# RH
cat("\n--- RH ---\n")
rh_results <- test_seasonal_trends(seasonal_summary_all, 
                                     "RH_mean", 
                                     "RH", 
                                     "%")
print(rh_results[, c("season", "mean_value", "normal", "slope", "slope_p", 
                      "kendall_tau", "kendall_p", #"change_per_year", 
                      "spearman_rho", "spearman_p", "significant")])

# Sensible Heat
cat("\n--- SENSIBLE HEAT FLUX ---\n")
h_results <- test_seasonal_trends(seasonal_summary_all, 
                                   "H_mean", 
                                   "Sensible Heat", 
                                   "W/m²")
print(h_results[, c("season", "mean_value", "normal", "slope", "slope_p", 
                    "kendall_tau", "kendall_p", #"change_per_year", 
                    "spearman_rho", "spearman_p", "significant")])

# Latent Heat
cat("\n--- LATENT HEAT FLUX ---\n")
le_results <- test_seasonal_trends(seasonal_summary_all, 
                                    "LE_mean", 
                                    "Latent Heat", 
                                    "W/m²")
print(le_results[, c("season", "mean_value", "normal", "slope", "slope_p", 
                     "kendall_tau", "kendall_p", #"change_per_year", 
                     "spearman_rho", "spearman_p", "significant")])

# Ground Heat
cat("\n--- Ground HEAT FLUX ---\n")
g_results <- test_seasonal_trends(seasonal_summary_all, 
                                    "G_mean", 
                                    "Ground Heat Flux", 
                                    "W/m²")
print(g_results[, c("season", "mean_value", "normal", "slope", "slope_p", 
                     "kendall_tau", "kendall_p", #"change_per_year", 
                     "spearman_rho", "spearman_p","significant")])

# ============================================================================
# COMBINE ALL RESULTS INTO ONE TABLE
# ============================================================================

all_results <- rbind(gf_ta_results, ta_results, gf_ts_results, ts_results, swc_results, 
                     vpd_results, rh_results, h_results, le_results, g_results)

cat("\n\n============================================================\n")
cat("SUMMARY: SIGNIFICANT TRENDS ONLY\n")
cat("============================================================\n")

significant_trends <- all_results %>%
  filter(significant %in% c("Yes*", "Yes**")) %>%
  select(variable, season, mean_value, units, #change_per_year, #percent_change_2017_2022
         spearman_rho, spearman_p, slope_p, kendall_p, significant)

if (nrow(significant_trends) > 0) {
  print(significant_trends)
} else {
  cat("No statistically significant trends detected at p < 0.05\n")
}

cat("\n\nInterpretation:\n")
cat("- Positive slope/change = increasing trend\n")
cat("- Negative slope/change = decreasing trend\n")
cat("- change_per_year = average annual change\n")
cat("- percent_change = total change from 2017 to 2022\n")
```
#Make table of all stats results 
```{r}
# Combine all results
all_results <- rbind(gf_ta_results, ta_results, gf_ts_results, ts_results, 
                     swc_results, vpd_results, rh_results, h_results, 
                     le_results, g_results)

# View the complete table
print(all_results)

# Select specific columns for cleaner presentation
supp_table <- all_results %>%
  select(variable, season, n_years, mean_value, units,
         slope, slope_se, slope_p, 
         adj_r_squared,
         kendall_tau, kendall_p,
         spearman_rho, spearman_p,
         shapiro_p, normal, significant) %>%
  arrange(variable, season)

supp_table

# Export to CSV
write.csv(supp_table, "C:/Users/kkent/Documents/Github Flux Network/Council_Flux_Analysis_Paper/Council Figures/seasonal_met_trends_statisticscsv", row.names = FALSE)


```



#pairwise comparisons of years using daily avg data - might not work well due to potential autocorrelation - coding help from Claude
```{r}
# Pairwise Year Comparisons Using Daily Averages
# Tests if specific years differ from each other within each season

library(dplyr)
library(broom)

# Function to perform pairwise comparisons for a variable
pairwise_year_comparison <- function(data, var_name, var_label, season_name) {
  
  # Filter to specific season
  season_data <- data %>%
    filter(year %in% 2017:2022, season == season_name) %>%
    select(year, value = !!sym(var_name)) %>%
    filter(!is.na(value))
  
  # Get all unique years
  years <- sort(unique(season_data$year))
  
  # Create all pairwise combinations
  comparisons <- combn(years, 2, simplify = FALSE)
  
  results_list <- list()
  
  for (i in seq_along(comparisons)) {
    year1 <- comparisons[[i]][1]
    year2 <- comparisons[[i]][2]
    
    # Extract data for each year
    data1 <- season_data %>% filter(year == year1) %>% pull(value)
    data2 <- season_data %>% filter(year == year2) %>% pull(value)
    
    # Skip if insufficient data
    if (length(data1) < 3 || length(data2) < 3) next
    
    # Test normality
    shapiro1 <- shapiro.test(data1)$p.value
    shapiro2 <- shapiro.test(data2)$p.value
    both_normal <- (shapiro1 > 0.05 & shapiro2 > 0.05)
    
    # Perform appropriate test
    if (both_normal) {
      # t-test
      test_result <- t.test(data1, data2)
      test_stat <- test_result$statistic
      p_value <- test_result$p.value
      test_used <- "t-test"
    } else {
      # Mann-Whitney U test (Wilcoxon rank-sum)
      test_result <- wilcox.test(data1, data2)
      test_stat <- test_result$statistic
      p_value <- test_result$p.value
      test_used <- "Mann-Whitney"
    }
    
    # Calculate effect size (Cohen's d or rank-biserial)
    mean1 <- mean(data1, na.rm = TRUE)
    mean2 <- mean(data2, na.rm = TRUE)
    diff <- mean1 - mean2
    
    # Store results
    results_list[[i]] <- data.frame(
      variable = var_label,
      season = season_name,
      comparison = paste(year1, "vs", year2),
      year1 = year1,
      year2 = year2,
      n1 = length(data1),
      n2 = length(data2),
      mean1 = mean1,
      mean2 = mean2,
      difference = diff,
      test_used = test_used,
      p_value = p_value,
      significant = ifelse(p_value < 0.05, "Yes", "No"),
      stringsAsFactors = FALSE
    )
  }
  
  # Combine results
  do.call(rbind, results_list)
}

# ============================================================================
# Run pairwise comparisons for key variables
# ============================================================================

cat("============================================================\n")
cat("PAIRWISE YEAR COMPARISONS (Using Daily Averages)\n")
cat("============================================================\n\n")

# Air Temperature - Growing Season
cat("\n--- AIR TEMPERATURE - GROWING SEASON ---\n")
ta_gs_pairs <- pairwise_year_comparison(df_avg2, "TA_gapfilled", 
                                        "Air Temperature", "Growing Season")
print(ta_gs_pairs[, c("comparison", "n1", "n2", "mean1", "mean2", 
                      "difference", "test_used", "p_value", "significant")])

# Air Temperature - Winter
cat("\n--- AIR TEMPERATURE - WINTER ---\n")
ta_winter_pairs <- pairwise_year_comparison(df_avg2, "TA_gapfilled", 
                                            "Air Temperature", "Winter")
print(ta_winter_pairs[, c("comparison", "n1", "n2", "mean1", "mean2", 
                          "difference", "test_used", "p_value", "significant")])

# VPD - Growing Season (significant trend detected)
cat("\n--- VPD - GROWING SEASON ---\n")
vpd_gs_pairs <- pairwise_year_comparison(df_avg2, "VPD", 
                                         "VPD", "Growing Season")
print(vpd_gs_pairs[, c("comparison", "n1", "n2", "mean1", "mean2", 
                       "difference", "test_used", "p_value", "significant")])

# Soil Moisture - Growing Season (marginally significant trend)
cat("\n--- SOIL MOISTURE - GROWING SEASON ---\n")
swc_gs_pairs <- pairwise_year_comparison(df_avg2, "SWC_3_1_1", 
                                         "Soil Moisture", "Growing Season")
print(swc_gs_pairs[, c("comparison", "n1", "n2", "mean1", "mean2", 
                       "difference", "test_used", "p_value", "significant")])

# ============================================================================
# Identify anomalous years
# ============================================================================

cat("\n\n============================================================\n")
cat("SUMMARY: SIGNIFICANT PAIRWISE DIFFERENCES\n")
cat("============================================================\n")

# Combine all results
all_pairs <- rbind(ta_gs_pairs, ta_winter_pairs, vpd_gs_pairs, swc_gs_pairs)

significant_pairs <- all_pairs %>%
  filter(significant == "Yes") %>%
  select(variable, season, comparison, difference, p_value)

if (nrow(significant_pairs) > 0) {
  print(significant_pairs)
  
  # Identify which years appear most often as different
  cat("\n\nYears appearing most frequently in significant comparisons:\n")
  year_counts <- c(significant_pairs$year1, significant_pairs$year2)
  year_freq <- sort(table(year_counts), decreasing = TRUE)
  print(year_freq)
  
} else {
  cat("No statistically significant pairwise differences detected.\n")
}

cat("\n\nInterpretation:\n")
cat("- Uses daily averages for each comparison (n ~ 100-200 per year)\n")
cat("- Automatically selects t-test (normal data) or Mann-Whitney (non-normal)\n")
cat("- Years appearing frequently may be anomalous\n")
cat("- Compare with trend analysis to distinguish anomalies from trends\n")

#nearly all pairings are sig, this suggests that mayber there is autocorrelation, which wouldn't be a surprise using days in sequential order. Likely doing the stats this way isn't appropriate 

# After getting all results - apply multiple comparison correction to see if that slims down the number of sig pairings 
all_pairs <- all_pairs %>%
  mutate(p_adjusted = p.adjust(p_value, method = "BH"))

# Filter for adjusted significance
significant_pairs <- all_pairs %>%
  filter(p_adjusted < 0.05)

significant_pairs

#still almost all are sig, so the correction didn't help potential autocorrelation 
```

#Multi-yr mean to detect anomalous years - code from Claude
```{r}
# Compare Each Year to Multi-Year Mean (2017-2022)
# More conservative approach to identify truly anomalous years

library(dplyr)
library(broom)

# Function to test if each year differs from the overall mean
identify_anomalous_years <- function(data, var_name, var_label, season_name) {
  
  # Filter to specific season, all years
  season_data <- data %>%
    filter(year %in% 2017:2022, season == season_name) %>%
    select(year, value = !!sym(var_name)) %>%
    filter(!is.na(value))
  
  # Calculate overall statistics
  overall_mean <- mean(season_data$value, na.rm = TRUE)
  overall_sd <- sd(season_data$value, na.rm = TRUE)
  
  years <- 2017:2022
  results_list <- list()
  
  for (yr in years) {
    # Get data for this year and all other years
    year_data <- season_data %>% filter(year == yr) %>% pull(value)
    other_years_data <- season_data %>% filter(year != yr) %>% pull(value)
    
    # Skip if insufficient data
    if (length(year_data) < 3) next
    
    # Test normality
    if (length(year_data) >= 3) {
      shapiro_p <- shapiro.test(year_data)$p.value
      is_normal <- shapiro_p > 0.05
    } else {
      is_normal <- FALSE
    }
    
    # Test if this year differs from all other years combined
    if (is_normal && length(other_years_data) > 30) {
      test_result <- t.test(year_data, other_years_data)
      test_used <- "t-test"
    } else {
      test_result <- wilcox.test(year_data, other_years_data)
      test_used <- "Mann-Whitney"
    }
    
    # Calculate year statistics
    year_mean <- mean(year_data, na.rm = TRUE)
    year_sd <- sd(year_data, na.rm = TRUE)
    
    # Calculate z-score (how many SDs from overall mean)
    z_score <- (year_mean - overall_mean) / overall_sd
    
    # Store results
    results_list[[as.character(yr)]] <- data.frame(
      variable = var_label,
      season = season_name,
      year = yr,
      n_days = length(year_data),
      year_mean = year_mean,
      year_sd = year_sd,
      overall_mean = overall_mean,
      difference = year_mean - overall_mean,
      percent_diff = ((year_mean - overall_mean) / abs(overall_mean)) * 100,
      z_score = z_score,
      test_used = test_used,
      p_value = test_result$p.value,
      stringsAsFactors = FALSE
    )
  }
  
  # Combine results
  results_df <- do.call(rbind, results_list)
  
  # Add adjusted p-values and significance
  results_df <- results_df %>%
    mutate(
      p_adjusted = p.adjust(p_value, method = "BH"),
      significant = ifelse(p_adjusted < 0.05, "Yes", "No"),
      anomaly_type = case_when(
        significant == "No" ~ "Normal",
        z_score > 2 ~ "High anomaly",
        z_score > 1 ~ "Moderately high",
        z_score < -2 ~ "Low anomaly",
        z_score < -1 ~ "Moderately low",
        TRUE ~ "Significant"
      )
    )
  
  return(results_df)
}

# ============================================================================
# Run anomaly detection for key variables
# ============================================================================

cat("============================================================\n")
cat("ANOMALOUS YEAR DETECTION (Comparison to 2017-2022 Mean)\n")
cat("============================================================\n\n")

# Air Temperature - Growing Season
cat("\n--- AIR TEMPERATURE - GROWING SEASON ---\n")
ta_gs_anom <- identify_anomalous_years(df_avg2, "TA_gapfilled", 
                                       "Air Temperature", "Growing Season")
print(ta_gs_anom[, c("year", "n_days", "year_mean", "overall_mean", 
                     "difference", "z_score", "p_adjusted", "anomaly_type")])

# Air Temperature - Winter
cat("\n--- AIR TEMPERATURE - WINTER ---\n")
ta_winter_anom <- identify_anomalous_years(df_avg2, "TA_gapfilled", 
                                           "Air Temperature", "Winter")
print(ta_winter_anom[, c("year", "n_days", "year_mean", "overall_mean", 
                         "difference", "z_score", "p_adjusted", "anomaly_type")])

# Soil Temperature - Growing Season
cat("\n--- SOIL TEMPERATURE - GROWING SEASON ---\n")
ts_gs_anom <- identify_anomalous_years(df_avg2, "TS_3_gapfilled", 
                                       "Soil Temperature", "Growing Season")
print(ts_gs_anom[, c("year", "n_days", "year_mean", "overall_mean", 
                     "difference", "z_score", "p_adjusted", "anomaly_type")])

# VPD - Growing Season
cat("\n--- VPD - GROWING SEASON ---\n")
vpd_gs_anom <- identify_anomalous_years(df_avg2, "VPD", 
                                        "VPD", "Growing Season")
print(vpd_gs_anom[, c("year", "n_days", "year_mean", "overall_mean", 
                      "difference", "z_score", "p_adjusted", "anomaly_type")])

# VPD - Winter
cat("\n--- VPD - WINTER ---\n")
vpd_winter_anom <- identify_anomalous_years(df_avg2, "VPD", 
                                            "VPD", "Winter")
print(vpd_winter_anom[, c("year", "n_days", "year_mean", "overall_mean", 
                          "difference", "z_score", "p_adjusted", "anomaly_type")])

# Soil Moisture - Growing Season
cat("\n--- SOIL MOISTURE - GROWING SEASON ---\n")
swc_gs_anom <- identify_anomalous_years(df_avg2, "SWC_3_1_1", 
                                        "Soil Moisture", "Growing Season")
print(swc_gs_anom[, c("year", "n_days", "year_mean", "overall_mean", 
                      "difference", "z_score", "p_adjusted", "anomaly_type")])

# Soil Moisture - Winter
cat("\n--- SOIL MOISTURE - WINTER ---\n")
swc_winter_anom <- identify_anomalous_years(df_avg2, "SWC_3_1_1", 
                                            "Soil Moisture", "Winter")
print(swc_winter_anom[, c("year", "n_days", "year_mean", "overall_mean", 
                          "difference", "z_score", "p_adjusted", "anomaly_type")])

# ============================================================================
# Summary of anomalous years
# ============================================================================

cat("\n\n============================================================\n")
cat("SUMMARY: ANOMALOUS YEARS IDENTIFIED\n")
cat("============================================================\n")

# Combine all results
all_anomalies <- rbind(
  ta_gs_anom, ta_winter_anom, ts_gs_anom,
  vpd_gs_anom, vpd_winter_anom, 
  swc_gs_anom, swc_winter_anom
)

# Filter for significant anomalies
significant_anomalies <- all_anomalies %>%
  filter(significant == "Yes") %>%
  arrange(variable, season, year) %>%
  select(variable, season, year, difference, z_score, p_adjusted, anomaly_type)

if (nrow(significant_anomalies) > 0) {
  print(significant_anomalies)
  
  # Count anomalies by year
  cat("\n\nYears with most anomalies:\n")
  year_counts <- table(significant_anomalies$year)
  print(sort(year_counts, decreasing = TRUE))
  
} else {
  cat("No statistically significant anomalous years detected.\n")
}

cat("\n\nInterpretation Guide:\n")
cat("- z_score: How many standard deviations from the 6-year mean\n")
cat("  |z| > 2: Strong anomaly (unusual)\n")
cat("  |z| > 1: Moderate anomaly\n")
cat("  |z| < 1: Within normal range\n")
cat("- p_adjusted: BH-corrected p-value for multiple comparisons\n")
cat("- difference: Actual value difference from mean (in original units)\n")
cat("- This approach is more conservative than pairwise comparisons\n")
```
#Checking linear trends of variables that showed sig slopes per lm and/or kendall's tau (which is VPD, RH, possibly SWC)
#### note that here it's using an intercept based off of year = 0, when our first year is 2017...so the b/y-intercept here is wrong - use "year_c" to re-center onto 2017 as starting reference point

### LM - VPD
```{r}

#coding suggestion from claude: set year 2017 as the first year so the intercept is interpretable - called "Centering" so that the intercept is within the range of your data's range 
seasonal_summary_all <- seasonal_summary_all %>%
  mutate(year_c = year - 2017) #sets 2017 at year 0, aka starting point - if the intercept is important, use the variable year_c instead of year in the lm formula 

#VPD

#Across all seasons and years 
#want to use "year" (numeric) here, not year_factor 
vpd_lm = lm(formula = seasonal_summary_all$VPD_mean ~ seasonal_summary_all$year, na.rm = TRUE)
summary(vpd_lm) 
#Results: slope = 0.81, R2=0.58, p = 0.00022

#Growing season 
vpd_lm_summer <- lm(VPD_mean ~ year,
                data = seasonal_summary_all,
                subset = season == "Growing Season")

summary(vpd_lm_summer)
#Results: slope = 0.81, R2 = 0.84, p = 0.0065 *SIG

#Fall
vpd_lm_fall <- lm(VPD_mean ~ year,
                data = seasonal_summary_all,
                subset = season == "Fall Senescence")

summary(vpd_lm_fall) #slope = 0.6, R2 = 0.9458, p = 0.000715 *SIG

#Winter  - 2021 winter is missing VPD 
vpd_lm_winter <- lm(VPD_mean ~ year,
                data = seasonal_summary_all,
                subset = season == "Winter", na.rm = TRUE)

summary(vpd_lm_winter) # slope = 0.91, R2 = 0.749, p = 0.0367 *SIG
```

#LM - RH 
```{r}
#========== RH ==================

#Across all seasons and years 
rh_lm = lm(formula = seasonal_summary_all$RH_mean ~ seasonal_summary_all$year, na.rm = TRUE)
summary(rh_lm) 
#Results: slope = -7.092, R2 = 0.621, p = 0.000104 *SIG

#Growing season 
rh_lm_summer <- lm(RH_mean ~ year,
                data = seasonal_summary_all,
                subset = season == "Growing Season")

summary(rh_lm_summer)
#Results: slope = -6.59, R2 = 0.959, p = 0.00039 *SIG

#Fall
rh_lm_fall <- lm(RH_mean ~ year,
                data = seasonal_summary_all,
                subset = season == "Fall Senescence")

summary(rh_lm_fall) #slope = -7.51, R2 = 0.97, p = 0.000204 *SIG

#Winter
rh_lm_winter <- lm(RH_mean ~ year,
                data = seasonal_summary_all,
                subset = season == "Winter", na.rm = TRUE)

summary(rh_lm_winter) # slope = -8.379, R2 = 0.894, p = 0.00973 *SIG 
```

#LM - SWC
```{r}

#========== SWC (potentially borderline) ==================

#Across all seasons and years 
SWC_lm = lm(formula = seasonal_summary_all$SWC_3_mean ~ seasonal_summary_all$year)
summary(SWC_lm) 
#Results: slope = -3.299, R2 = 0.0757, p = 0.141 - not sig 

#Growing season 
SWC_lm_summer <- lm(SWC_3_mean ~ year,
                data = seasonal_summary_all,
                subset = season == "Growing Season")

summary(SWC_lm_summer)
#Results: slope = -1.967, R2 = 0.578, p = 0.0487 *sig but borderline 

#Fall
SWC_lm_fall <- lm(SWC_3_mean ~ year,
                data = seasonal_summary_all,
                subset = season == "Fall Senescence")

summary(SWC_lm_fall) #slope = -0.748, R2 = -0.0379 (???), p = 0.417  - not sig 

#Winter
SWC_lm_winter <- lm(SWC_3_mean ~ year,
                data = seasonal_summary_all,
                subset = season == "Winter")

summary(SWC_lm_winter) # slope = -7.218, R2 = 0.572, p = 0.050 - not sig 
```

#LM - Air T

```{r}

#========== Air temp  ==================

#Across all seasons and years 
TA_lm = lm(formula = seasonal_summary_all$TA_mean ~ seasonal_summary_all$year)
summary(TA_lm) 
#Results: slope = -0.295, R2 = -0.0586, p = 0.812 - not sig 

#Growing season 
TA_lm_summer <- lm(TA_mean ~ year,
                data = seasonal_summary_all,
                subset = season == "Growing Season")

summary(TA_lm_summer)
#Results: slope = -0.202, R2 = -0.043, p = 0.423 - not sig 

#Fall
TA_lm_fall <- lm(TA_mean ~ year,
                data = seasonal_summary_all,
                subset = season == "Fall Senescence")

summary(TA_lm_fall) #slope = -0.102, R2=-0.235, p = 0.838 - not sig  

#Winter
TA_lm_winter <- lm(TA_mean ~ year,
                data = seasonal_summary_all,
                subset = season == "Winter")

summary(TA_lm_winter) # slope = -0.58, R2 = 0.10, p = 0.29 - not sig 
```

# LM - TS_3

```{r}

#========== TS_3 ==================

#Across all seasons and years 
TS_lm = lm(formula = seasonal_summary_all$TS_3_mean ~ seasonal_summary_all$year)
summary(TS_lm) 
#Results: slope = -0.044, R2 = -0.062, p = 0.938 - not sig 

#Growing season 
TS_lm_summer <- lm(TS_3_mean ~ year,
                data = seasonal_summary_all,
                subset = season == "Growing Season")

summary(TS_lm_summer)
#Results: slope = 0.213, R2 = -0.114, p = 0.52 - not sig 

#Fall
TS_lm_fall <- lm(TS_3_mean ~ year,
                data = seasonal_summary_all,
                subset = season == "Fall Senescence")

summary(TS_lm_fall) #slope = 0.00367, R2 = -0.247, p = 0.928 - not sig 

#Winter
TS_lm_winter <- lm(TS_3_mean ~ year,
                data = seasonal_summary_all,
                subset = season == "Winter")

summary(TS_lm_winter) # slope = -0.38, R2 = 0.645, p = 0.0336 - *SIG* (but was borderline in kendall-tau)


```
#Checking normality / homogeneity again of the lm models that showed sig p 

#### TS (measured, not gf) - Winter 
```{r}
library(car)
library(nlme)
library(lme4)

# Extract fitted values and residuals
fitted_values <- fitted(TS_lm_winter)
residuals <- residuals(TS_lm_winter)


# Graphical assessment
par(mfrow = c(1, 2))
# Histogram of residuals
hist(residuals, main = "Histogram of Standardized Residuals", 
     xlab = "Standardized Residuals", freq = FALSE)
curve(dnorm, add = TRUE, col = "red")

# QQ plot
qqnorm(residuals, main = "Normal Q-Q Plot")
qqline(residuals, col = "red")

# Formal test
shapiro_test <- shapiro.test(residuals)
print(shapiro_test) #p=0.896 


# Plot residuals vs. predictor

ggplot(seasonal_summary_all %>% filter(season == "Winter"), 
       aes(x = TS_3_mean, y = residuals)) +
  geom_point() +
  geom_hline(yintercept = 0, linetype = "dashed") +
  labs(x = "Cont. Pred. Var",
       y = "Residuals",
       title = "Residuals vs. Predictor Var") +
  theme_bw()

# Create a scale-location plot --> should be randomly scattered with a relatively flat trend line (red) for homogeneity of variance 
plot(TS_lm_winter, which = 3)


#Breusch-Pagan test - specifically tests if variance of residuals is constant - want a p > 0.05 for homogeneity of var
library(lmtest)
bptest(TS_lm_winter) #p=0.11, ok 


```
#### RH - all seasons  
```{r}
library(car)
library(nlme)
library(lme4)

#Winter - some NA's in RH, 2021 winter missing 

rh_lm_winter2 <- lm(RH_mean ~ year,
                   data = seasonal_summary_all,
                   subset = season == "Winter",
                   na.action = na.exclude)

# Extract fitted values and residuals
fitted_values <- fitted(rh_lm_winter2)
residuals <- residuals(rh_lm_winter2)


# Graphical assessment
par(mfrow = c(1, 2))
# Histogram of residuals
hist(residuals, main = "Histogram of Standardized Residuals", 
     xlab = "Standardized Residuals", freq = FALSE)
curve(dnorm, add = TRUE, col = "red")

# QQ plot
qqnorm(residuals, main = "Normal Q-Q Plot")
qqline(residuals, col = "red")

# Formal test
shapiro_test <- shapiro.test(residuals)
print(shapiro_test) #p=0.18 - ok 


# Plot residuals vs. predictor

ggplot(seasonal_summary_all %>% filter(season == "Winter"), 
       aes(x = RH_mean, y = residuals)) +
  geom_point() +
  geom_hline(yintercept = 0, linetype = "dashed") +
  labs(x = "Cont. Pred. Var",
       y = "Residuals",
       title = "Residuals vs. Predictor Var") +
  theme_bw()

# Create a scale-location plot --> should be randomly scattered with a relatively flat trend line (red) for homogeneity of variance 
plot(rh_lm_winter, which = 3)


#Breusch-Pagan test - specifically tests if variance of residuals is constant - want a p > 0.05 for homogeneity of var
library(lmtest)
bptest(rh_lm_winter) #p=0.0.475 -ok 


#================================================================================
#Growing Season 
#=================================================================================

# Extract fitted values and residuals
fitted_values <- fitted(rh_lm_summer)
residuals <- residuals(rh_lm_summer)


# Graphical assessment
par(mfrow = c(1, 2))
# Histogram of residuals
hist(residuals, main = "Histogram of Standardized Residuals", 
     xlab = "Standardized Residuals", freq = FALSE)
curve(dnorm, add = TRUE, col = "red")

# QQ plot
qqnorm(residuals, main = "Normal Q-Q Plot")
qqline(residuals, col = "red")

# Formal test
shapiro_test <- shapiro.test(residuals)
print(shapiro_test) #p=0.837 - ok


# Plot residuals vs. predictor

ggplot(seasonal_summary_all %>% filter(season == "Growing Season"), 
       aes(x = RH_mean, y = residuals)) +
  geom_point() +
  geom_hline(yintercept = 0, linetype = "dashed") +
  labs(x = "Cont. Pred. Var",
       y = "Residuals",
       title = "Residuals vs. Predictor Var") +
  theme_bw()

# Create a scale-location plot --> should be randomly scattered with a relatively flat trend line (red) for homogeneity of variance 
plot(rh_lm_summer , which = 3)


#Breusch-Pagan test - specifically tests if variance of residuals is constant - want a p > 0.05 for homogeneity of var
library(lmtest)
bptest(rh_lm_summer ) #p=0.047 - NOT OK ** 


#================================================================================
# FALL
#=================================================================================

# Extract fitted values and residuals
fitted_values <- fitted(rh_lm_fall)
residuals <- residuals(rh_lm_fall)


# Graphical assessment
par(mfrow = c(1, 2))
# Histogram of residuals
hist(residuals, main = "Histogram of Standardized Residuals", 
     xlab = "Standardized Residuals", freq = FALSE)
curve(dnorm, add = TRUE, col = "red")

# QQ plot
qqnorm(residuals, main = "Normal Q-Q Plot")
qqline(residuals, col = "red")

# Formal test
shapiro_test <- shapiro.test(residuals)
print(shapiro_test) #p=0.88 - ok but QQ plot does NOT look ok


# Plot residuals vs. predictor

ggplot(seasonal_summary_all %>% filter(season == "Fall Senescence"), 
       aes(x = RH_mean, y = residuals)) +
  geom_point() +
  geom_hline(yintercept = 0, linetype = "dashed") +
  labs(x = "Cont. Pred. Var",
       y = "Residuals",
       title = "Residuals vs. Predictor Var") +
  theme_bw()

# Create a scale-location plot --> should be randomly scattered with a relatively flat trend line (red) for homogeneity of variance 
plot(rh_lm_fall, which = 3)


#Breusch-Pagan test - specifically tests if variance of residuals is constant - want a p > 0.05 for homogeneity of var
library(lmtest)
bptest(rh_lm_fall ) #p=0.068, ok, but the visuals don't look very good 

```
#VPD all seasons 
```{r}

#Winter - some NA's in VPD, 2021 winter missing 

vpd_lm_winter2 <- lm(VPD_mean ~ year,
                   data = seasonal_summary_all,
                   subset = season == "Winter",
                   na.action = na.exclude)

# Extract fitted values and residuals
fitted_values <- fitted(vpd_lm_winter2)
residuals <- residuals(vpd_lm_winter2)


# Graphical assessment
par(mfrow = c(1, 2))
# Histogram of residuals
hist(residuals, main = "Histogram of Standardized Residuals", 
     xlab = "Standardized Residuals", freq = FALSE)
curve(dnorm, add = TRUE, col = "red")

# QQ plot
qqnorm(residuals, main = "Normal Q-Q Plot")
qqline(residuals, col = "red")

# Formal test
shapiro_test <- shapiro.test(residuals)
print(shapiro_test) #p=0.725 - ok 


# Plot residuals vs. predictor

ggplot(seasonal_summary_all %>% filter(season == "Winter"), 
       aes(x = VPD_mean, y = residuals)) +
  geom_point() +
  geom_hline(yintercept = 0, linetype = "dashed") +
  labs(x = "Cont. Pred. Var",
       y = "Residuals",
       title = "Residuals vs. Predictor Var") +
  theme_bw()

# Create a scale-location plot --> should be randomly scattered with a relatively flat trend line (red) for homogeneity of variance 
plot(vpd_lm_winter, which = 3)


#Breusch-Pagan test - specifically tests if variance of residuals is constant - want a p > 0.05 for homogeneity of var
library(lmtest)
bptest(vpd_lm_winter) #p=0.0.22 -ok but the visuals do NOT look ok 


#================================================================================
#Growing Season 
#=================================================================================

# Extract fitted values and residuals
fitted_values <- fitted(vpd_lm_summer)
residuals <- residuals(vpd_lm_summer)


# Graphical assessment
par(mfrow = c(1, 2))
# Histogram of residuals
hist(residuals, main = "Histogram of Standardized Residuals", 
     xlab = "Standardized Residuals", freq = FALSE)
curve(dnorm, add = TRUE, col = "red")

# QQ plot
qqnorm(residuals, main = "Normal Q-Q Plot")
qqline(residuals, col = "red")

# Formal test
shapiro_test <- shapiro.test(residuals)
print(shapiro_test) #p=0.72 - ok


# Plot residuals vs. predictor

ggplot(seasonal_summary_all %>% filter(season == "Growing Season"), 
       aes(x = VPD_mean, y = residuals)) +
  geom_point() +
  geom_hline(yintercept = 0, linetype = "dashed") +
  labs(x = "Cont. Pred. Var",
       y = "Residuals",
       title = "Residuals vs. Predictor Var") +
  theme_bw()

# Create a scale-location plot --> should be randomly scattered with a relatively flat trend line (red) for homogeneity of variance 
plot(vpd_lm_summer , which = 3)


#Breusch-Pagan test - specifically tests if variance of residuals is constant - want a p > 0.05 for homogeneity of var
library(lmtest)
bptest(vpd_lm_summer ) #p=0.63 - ok 


#================================================================================
# FALL
#=================================================================================

# Extract fitted values and residuals
fitted_values <- fitted(vpd_lm_fall)
residuals <- residuals(vpd_lm_fall)


# Graphical assessment
par(mfrow = c(1, 2))
# Histogram of residuals
hist(residuals, main = "Histogram of Standardized Residuals", 
     xlab = "Standardized Residuals", freq = FALSE)
curve(dnorm, add = TRUE, col = "red")

# QQ plot
qqnorm(residuals, main = "Normal Q-Q Plot")
qqline(residuals, col = "red")

# Formal test
shapiro_test <- shapiro.test(residuals)
print(shapiro_test) #p=0.92


# Plot residuals vs. predictor

ggplot(seasonal_summary_all %>% filter(season == "Fall Senescence"), 
       aes(x = VPD_mean, y = residuals)) +
  geom_point() +
  geom_hline(yintercept = 0, linetype = "dashed") +
  labs(x = "Cont. Pred. Var",
       y = "Residuals",
       title = "Residuals vs. Predictor Var") +
  theme_bw()

# Create a scale-location plot --> should be randomly scattered with a relatively flat trend line (red) for homogeneity of variance 
plot(vpd_lm_fall, which = 3)


#Breusch-Pagan test - specifically tests if variance of residuals is constant - want a p > 0.05 for homogeneity of var
library(lmtest)
bptest(vpd_lm_fall ) #p = 0.68, ok 

```


#### SWC - winter
```{r}

#Winter 

# Extract fitted values and residuals
fitted_values <- fitted(SWC_lm_winter)
residuals <- residuals(SWC_lm_winter)


# Graphical assessment
par(mfrow = c(1, 2))
# Histogram of residuals
hist(residuals, main = "Histogram of Standardized Residuals", 
     xlab = "Standardized Residuals", freq = FALSE)
curve(dnorm, add = TRUE, col = "red")

# QQ plot
qqnorm(residuals, main = "Normal Q-Q Plot")
qqline(residuals, col = "red")

# Formal test
shapiro_test <- shapiro.test(residuals)
print(shapiro_test) #p=0.503 -ok 


# Plot residuals vs. predictor

ggplot(seasonal_summary_all %>% filter(season == "Winter"), 
       aes(x = SWC_3_mean, y = residuals)) +
  geom_point() +
  geom_hline(yintercept = 0, linetype = "dashed") +
  labs(x = "Cont. Pred. Var",
       y = "Residuals",
       title = "Residuals vs. Predictor Var") +
  theme_bw()

# Create a scale-location plot --> should be randomly scattered with a relatively flat trend line (red) for homogeneity of variance 
plot(SWC_lm_winter, which = 3)


#Breusch-Pagan test - specifically tests if variance of residuals is constant - want a p > 0.05 for homogeneity of var
library(lmtest)
bptest(SWC_lm_winter) #p=0.36, ok 

```




#VPD with stats 
```{r}

library(ggpmisc)  # For adding equation and stats to plots

# VPD - Shows trends in all seasons 
p_VPD_with_stats <- ggplot(seasonal_summary_all, aes(x = year_c, y = VPD_mean, color = year_factor)) +
  geom_hline(yintercept = 0, color = "black", linewidth = 0.5) +
  geom_point(size = 2.5) +
  geom_errorbar(aes(ymin = VPD_mean - VPD_se, 
                    ymax = VPD_mean + VPD_se),
                width = 0.2, linewidth = 0.8) +
  
  # Add trend line
  geom_smooth(aes(group = season), method = "lm", se = TRUE, 
              color = "black", linewidth = 0.8, alpha = 0.2) +
  
  # Add R² and p-value
  # stat_poly_eq(aes(label = paste(after_stat(eq.label),
  #                                  after_stat(rr.label),
  #                                  after_stat(p.value.label),
  #                                  sep = "~~~")),
  stat_poly_eq(aes(label = after_stat(paste("atop(", 
                                           eq.label, ",", 
                                           "atop(", adj.rr.label, ",", 
                                           p.value.label, "))"))),
               formula = y ~ x,
               parse = TRUE,
               size = 4,
               color = "black") +
  
  facet_wrap(~ season, ncol = 3) +
  
  scale_color_manual(
    values = c("2017" = "#1f77b4", "2018" = "#ff7f0e", "2019" = "#2ca02c", 
               "2020" = "#d62728", "2021" = "#9467bd", "2022" = "#8c564b"),
    name = "Year"
  ) +
  
  scale_x_continuous(breaks = 2017:2022) +
  
  labs(x = "Year", y = "VPD (hPa)") +
  theme_bw() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"),
    axis.text.y = element_text(face = "bold"),
    axis.title = element_text(face = "bold"),
    strip.text = element_text(face = "bold"),
    legend.position = "none"
  )


p_VPD_with_stats
```
#RH with stats 

```{r}
# VPD - Shows trends in all seasons 
p_RH_with_stats <- ggplot(seasonal_summary_all, aes(x = year_c, y = RH_mean, color = year_factor)) +
  geom_hline(yintercept = 0, color = "black", linewidth = 0.5) +
  geom_point(size = 2.5) +
  geom_errorbar(aes(ymin = RH_mean - RH_se, 
                    ymax = RH_mean + RH_se),
                width = 0.2, linewidth = 0.8) +
  
  # Add trend line
  geom_smooth(aes(group = season), method = "lm", se = TRUE, 
              color = "black", linewidth = 0.8, alpha = 0.2) +
  
  # Add R² and p-value
  # stat_poly_eq(aes(label = paste(after_stat(eq.label),
  #                                  after_stat(rr.label),
  #                                  after_stat(p.value.label),
  #                                  sep = "~~~")),
  stat_poly_eq(aes(label = after_stat(paste("atop(", 
                                           eq.label, ",", 
                                           "atop(", adj.rr.label, ",", 
                                           p.value.label, "))"))),
               formula = y ~ x,
               parse = TRUE,
               size = 4,
               color = "black") +
  
  facet_wrap(~ season, ncol = 3) +
  
  scale_color_manual(
    values = c("2017" = "#1f77b4", "2018" = "#ff7f0e", "2019" = "#2ca02c", 
               "2020" = "#d62728", "2021" = "#9467bd", "2022" = "#8c564b"),
    name = "Year"
  ) +
  
  scale_x_continuous(breaks = 2017:2022) +
  
  labs(x = "Year", y = "RH (%)") +
  theme_bw() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"),
    axis.text.y = element_text(face = "bold"),
    axis.title = element_text(face = "bold"),
    strip.text = element_text(face = "bold"),
    legend.position = "none"
  )


p_RH_with_stats
```






























#Manual annotations of stats for each panel 
#VPD - Annotating each panel - code from Claude - fixed with corrected Mann-Kendall test 10.14.2025
```{r}
#Best way to add unique text to each panel in the facet_wrapped figure is to create a dataframe with the info you want to add to each panel 

# Create a dataframe with statistics for each season
vpd_stats <- data.frame(
  season = c("Winter", "Growing Season", "Fall Senescence"), #order of labels for panels in facetwrap
  r2 = c(0.75, 0.84, 0.95),  # Replace with your actual adj R² values - Fall, Growing, Winter 
  slope = c(0.91, 0.81, 0.63),  # Replace with your actual slopes - Fall, Growing, Winter 
  p_value = c(0.037, 0.007, 0.001),  # Replace with your actual p-values - Fall, Growing, Winter 
  mann_kendall_p = c(0.027, 0.024, 0.024),
  mann_kendall_tau = c(1.00, 0.87, 0.87),
  x = c(2017, 2017, 2017),  # x position for text
  y = c(10, 10, 10)  # y position for text - adjust based on your data range
)

# Create labels
vpd_stats <- vpd_stats %>%
  mutate(label = paste0("adj R² = ", round(r2, 2), "\n",
                        "Slope = ", round(slope, 2), "\n",
                        "LM_p = ", format.pval(p_value, digits = 3), "\n",
                        "Mann-Kendall_tau =", round(mann_kendall_tau, 2), "\n",
                        "Mann-Kendall_p =", format.pval(mann_kendall_p, digits = 3)))

# Add to plot
p_VPD_lm <- ggplot(seasonal_summary_all, aes(x = year, y = VPD_mean, color = year_factor)) +
  geom_hline(yintercept = 0, color = "black", linewidth = 0.5) +
  geom_point(size = 2.5) +
  geom_errorbar(aes(ymin = VPD_mean - VPD_se, 
                    ymax = VPD_mean + VPD_se),
                width = 0.2, linewidth = 0.8) +
  
  # Add trend line
  geom_smooth(aes(group = season), method = "lm", se = TRUE, 
              color = "black", linewidth = 0.8, alpha = 0.2) +
  
  # Add manual annotations
  geom_text(data = vpd_stats, 
            aes(x = x, y = y, label = label),
            color = "black", size = 3, hjust = 0, vjust = 1,
            inherit.aes = FALSE) +
facet_wrap(~factor(season, levels = c("Winter", "Growing Season", "Fall Senescence")), ncol = 3)+ #sets order of panels
  
  #facet_wrap(~ season, ncol = 3) +
  
  scale_color_manual(
    values = c("2017" = "#1f77b4", "2018" = "#ff7f0e", "2019" = "#2ca02c", 
               "2020" = "#d62728", "2021" = "#9467bd", "2022" = "#8c564b"),
    name = "Year"
  ) +
  
  scale_x_continuous(breaks = 2017:2022) +
  
  labs(x = "Year", y = "VPD (hPa)") +
  theme_bw() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"),
    axis.text.y = element_text(face = "bold"),
    axis.title = element_text(face = "bold"),
    strip.text = element_text(face = "bold"),
    legend.position = "none"
  )

p_VPD_lm
```
#Save figure 

```{r}

ggsave("C:/Users/kkent/Documents/Github Flux Network/Council_Flux_Analysis_Paper/Council Figures/VPD_trends_stats.png", p_VPD_lm, 
        width = 7, height = 5, dpi = 600)
```

#RH - Annotating each panel - code from Claude - updated with corrected Mann-Kendall test for timeseries 
```{r}
#Best way to add unique text to each panel in the facet_wrapped figure is to create a dataframe with the info you want to add to each panel 

# Create a dataframe with statistics for each season
rh_stats <- data.frame(
  season = c("Winter", "Growing Season", "Fall Senescence"),
  r2 = c(0.89, 0.96, 0.97),  # Replace with your actual adj R² values - Fall, Growing, Winter 
  slope = c(-8.38, -6.59, -7.52),  # Replace with your actual slopes - Fall, Growing, Winter 
  p_value = c(0.01, 0.0004, 0.0002),  # Replace with your actual p-values - Fall, Growing, Winter 
  mann_kendall_p = c(0.027, 0.009, 0.009),
  mann_kendall_tau = c(-1.00, -1.00, -1.00),
  x = c(2018, 2018, 2018),  # x position for text
  y = c(100, 100, 100)  # y position for text - adjust based on your data range
)

# Create labels
rh_stats <- rh_stats %>%
  mutate(label = paste0("adj R² = ", round(r2, 2), "\n",
                        "Slope = ", round(slope, 2), "\n",
                        "LM_p = ", format.pval(p_value, digits = 4, scientific = FALSE), "\n", 
                        "Mann-Kendall_tau =", round(mann_kendall_tau, 2), "\n",
                        "Mann-Kendall_p =", format.pval(mann_kendall_p, digits = 4)))

# Add to plot
p_rh_lm <- ggplot(seasonal_summary_all, aes(x = year, y = RH_mean, color = year_factor)) +
  geom_hline(yintercept = 0, color = "black", linewidth = 0.5) +
  geom_point(size = 2.5) +
  geom_errorbar(aes(ymin = RH_mean - RH_se, 
                    ymax = RH_mean + RH_se),
                width = 0.2, linewidth = 0.8) +
  
  # Add trend line
  geom_smooth(aes(group = season), method = "lm", se = TRUE, 
              color = "black", linewidth = 0.8, alpha = 0.2) +
  
  # Add manual annotations
  geom_text(data = rh_stats, 
            aes(x = x, y = y, label = label),
            color = "black", size = 3, hjust = 0, vjust = 1,
            inherit.aes = FALSE) +
  
facet_wrap(~factor(season, levels = c("Winter", "Growing Season", "Fall Senescence")), ncol = 3)+
  
  #facet_wrap(~ season, ncol = 3) +
  
  scale_color_manual(
    values = c("2017" = "#1f77b4", "2018" = "#ff7f0e", "2019" = "#2ca02c", 
               "2020" = "#d62728", "2021" = "#9467bd", "2022" = "#8c564b"),
    name = "Year"
  ) +
  
  scale_x_continuous(breaks = 2017:2022) +
  
  labs(x = "Year", y = "RH (%)") +
  theme_bw() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"),
    axis.text.y = element_text(face = "bold"),
    axis.title = element_text(face = "bold"),
    strip.text = element_text(face = "bold"),
    legend.position = "none"
  )

p_rh_lm
```
#Save figure 

```{r}

ggsave("C:/Users/kkent/Documents/Github Flux Network/Council_Flux_Analysis_Paper/Council Figures/RH_trends_stats.png", p_rh_lm, 
        width = 7, height = 5, dpi = 600) 
```


#Correcting the kendall's rank corr to mann-kendall test 

```{r}
# Tests for significant trends in environmental variables by season (2017-2022)

library(dplyr)
library(broom)
library(Kendall)  # For proper Mann-Kendall test

# ============================================================================
# FUNCTION: Test trends for a variable within each season
# ============================================================================

test_seasonal_trends <- function(data, var_name, var_label, units) {
  
  results_list <- list()
  seasons <- unique(data$season)
  
  for (s in seasons) {
    season_data <- data %>% filter(season == s) %>% arrange(year)  # Ensure temporal order!
    
    # Extract variable values
    y_vals <- season_data[[var_name]]
    x_vals <- season_data$year
    
    # Skip if too many NAs
    if (sum(!is.na(y_vals)) < 4) {
      next
    }
    
    # Linear regression
    lm_model <- lm(y_vals ~ x_vals)
    lm_summary <- summary(lm_model)
    
    # Test normality of RESIDUALS (not raw data)
    residuals_vals <- residuals(lm_model)
    shapiro_p <- shapiro.test(residuals_vals)$p.value
    
    # Extract key statistics from linear model
    slope <- coef(lm_model)[2]
    slope_se <- summary(lm_model)$coefficients[2, 2]
    slope_p <- summary(lm_model)$coefficients[2, 4]
    r_squared <- lm_summary$r.squared
    adj_r_squared <- lm_summary$adj.r.squared
    
    # PROPER Mann-Kendall test for temporal trends
    mk_test <- MannKendall(y_vals)
    mk_tau <- as.numeric(mk_test$tau)
    mk_p <- as.numeric(mk_test$sl)  # significance level (p-value)
    
    # Spearman correlation (alternative non-parametric option)
    spearman_test <- cor.test(x_vals, y_vals, method = "spearman")
    spearman_rho <- spearman_test$estimate
    spearman_p <- spearman_test$p.value
    
    # Sen's slope (robust trend estimator, pairs well with Mann-Kendall)
    sens_slope <- NA
    tryCatch({
      sens_test <- sens.slope(y_vals)
      sens_slope <- as.numeric(sens_test$estimates)
    }, error = function(e) {
      sens_slope <- NA
    })
    
    # Store results
    results_list[[s]] <- data.frame(
      season = s,
      variable = var_label,
      units = units,
      n_years = length(y_vals),
      mean_value = mean(y_vals, na.rm = TRUE),
      
      # Normality test
      shapiro_p = shapiro_p,
      normal = ifelse(shapiro_p > 0.05, "Yes", "No"),
      
      # Linear model (parametric)
      slope = slope,
      slope_se = slope_se,
      slope_p = slope_p,
      r_squared = r_squared,
      adj_r_squared = adj_r_squared,
      
      # Non-parametric tests
      mann_kendall_tau = mk_tau,
      mann_kendall_p = mk_p,
      sens_slope = sens_slope,
      spearman_rho = spearman_rho,
      spearman_p = spearman_p,
      
      # Significance (using appropriate test)
      significant = ifelse(shapiro_p > 0.05, 
                          ifelse(slope_p < 0.05, "Yes*", "No"),
                          ifelse(mk_p < 0.05, "Yes**", "No")),
      recommended_test = ifelse(shapiro_p > 0.05, 
                               "Linear Regression", 
                               "Mann-Kendall"),
      
      stringsAsFactors = FALSE
    )
  }
  
  # Combine all seasons
  do.call(rbind, results_list)
}

# ============================================================================
# RUN TESTS FOR ALL VARIABLES
# ============================================================================

cat("============================================================\n")
cat("ANNUAL TREND ANALYSIS BY SEASON (2017-2022)\n")
cat("============================================================\n\n")

cat("Significance codes:\n")
cat("* = Linear regression (residuals normal)\n")
cat("** = Mann-Kendall test (residuals non-normal)\n")
cat("p < 0.05 = significant trend\n\n")

# GF Air Temperature
cat("\n--- AIR TEMPERATURE (Gap-filled) ---\n")
gf_ta_results <- test_seasonal_trends(seasonal_summary_all, 
                                    "TA_gapfilled_mean", 
                                    "GF Air Temperature", 
                                    "°C")
print(gf_ta_results[, c("season", "mean_value", "normal", "slope", "slope_p", 
                     "mann_kendall_tau", "mann_kendall_p", "sens_slope", "spearman_rho",                                "spearman_p", "recommended_test", "significant")])



# Air Temperature (measured)
cat("\n--- AIR TEMPERATURE (measured) ---\n")
ta_results <- test_seasonal_trends(seasonal_summary_all, 
                                    "TA_mean", 
                                    "Air Temperature", 
                                    "°C")
print(ta_results[, c("season", "mean_value", "normal", "slope", "slope_p", 
                     "mann_kendall_tau", "mann_kendall_p", "sens_slope", "spearman_rho",                                "spearman_p", "recommended_test", "significant")])

# GF Soil Temperature
cat("\n--- SOIL TEMPERATURE (Gap-filled) ---\n")
gf_ts_results <- test_seasonal_trends(seasonal_summary_all, 
                                    "TS_3_gapfilled_mean", 
                                    "GF Soil Temperature", 
                                    "°C")
print(gf_ts_results[, c("season", "mean_value", "normal", "slope", "slope_p", 
                     "mann_kendall_tau", "mann_kendall_p", "sens_slope", "spearman_rho",                                "spearman_p", "recommended_test", "significant")])

# Soil Temperature (measured)
cat("\n--- SOIL TEMPERATURE ---\n")
ts_results <- test_seasonal_trends(seasonal_summary_all, 
                                    "TS_3_mean", 
                                    "Soil Temperature", 
                                    "°C")
print(ts_results[, c("season", "mean_value", "normal", "slope", "slope_p", 
                     "mann_kendall_tau", "mann_kendall_p", "sens_slope", "spearman_rho",                                "spearman_p", "recommended_test", "significant")])

# Soil Moisture
cat("\n--- SOIL MOISTURE ---\n")
swc_results <- test_seasonal_trends(seasonal_summary_all, 
                                     "SWC_3_mean", 
                                     "Soil Moisture", 
                                     "%")
print(swc_results[, c("season", "mean_value", "normal", "slope", "slope_p", 
                     "mann_kendall_tau", "mann_kendall_p", "sens_slope", "spearman_rho",                                "spearman_p", "recommended_test", "significant")])

# VPD
cat("\n--- VAPOR PRESSURE DEFICIT ---\n")
vpd_results <- test_seasonal_trends(seasonal_summary_all, 
                                     "VPD_mean", 
                                     "VPD", 
                                     "hPa")
print(vpd_results[, c("season", "mean_value", "normal", "slope", "slope_p", 
                     "mann_kendall_tau", "mann_kendall_p", "sens_slope", "spearman_rho",                                "spearman_p", "recommended_test", "significant")])

# RH
cat("\n--- RH ---\n")
rh_results <- test_seasonal_trends(seasonal_summary_all, 
                                     "RH_mean", 
                                     "RH", 
                                     "%")
print(rh_results[, c("season", "mean_value", "normal", "slope", "slope_p", 
                     "mann_kendall_tau", "mann_kendall_p", "sens_slope", "spearman_rho",                                "spearman_p", "recommended_test", "significant")])

# Sensible Heat
cat("\n--- SENSIBLE HEAT FLUX ---\n")
h_results <- test_seasonal_trends(seasonal_summary_all, 
                                   "H_mean", 
                                   "Sensible Heat", 
                                   "W/m²")
print(h_results[, c("season", "mean_value", "normal", "slope", "slope_p", 
                     "mann_kendall_tau", "mann_kendall_p", "sens_slope", "spearman_rho",                                "spearman_p", "recommended_test", "significant")])

# Latent Heat
cat("\n--- LATENT HEAT FLUX ---\n")
le_results <- test_seasonal_trends(seasonal_summary_all, 
                                    "LE_mean", 
                                    "Latent Heat", 
                                    "W/m²")
print(le_results[, c("season", "mean_value", "normal", "slope", "slope_p", 
                     "mann_kendall_tau", "mann_kendall_p", "sens_slope", "spearman_rho",                                "spearman_p", "recommended_test", "significant")])

# Ground Heat
cat("\n--- GROUND HEAT FLUX ---\n")
g_results <- test_seasonal_trends(seasonal_summary_all, 
                                    "G_mean", 
                                    "Ground Heat Flux", 
                                    "W/m²")
print(g_results[, c("season", "mean_value", "normal", "slope", "slope_p", 
                     "mann_kendall_tau", "mann_kendall_p", "sens_slope", "spearman_rho",                                "spearman_p", "recommended_test", "significant")])

# ============================================================================
# COMBINE ALL RESULTS INTO ONE TABLE
# ============================================================================

all_results <- rbind(gf_ta_results, ta_results, gf_ts_results, ts_results, swc_results, 
                     vpd_results, rh_results, h_results, le_results, g_results)

cat("\n\n============================================================\n")
cat("SUMMARY: SIGNIFICANT TRENDS ONLY\n")
cat("============================================================\n")

significant_trends <- all_results %>%
  filter(significant %in% c("Yes*", "Yes**")) %>%
  select(variable, season, mean_value, units, slope, sens_slope,
         mann_kendall_tau, mann_kendall_p, slope_p, recommended_test, significant)

if (nrow(significant_trends) > 0) {
  print(significant_trends)
} else {
  cat("No statistically significant trends detected at p < 0.05\n")
}

cat("\n\nInterpretation:\n")
cat("- Positive slope/tau = increasing trend over time\n")
cat("- Negative slope/tau = decreasing trend over time\n")
cat("- slope = parametric trend estimate (°C/year, W/m²/year, etc.)\n")
cat("- sens_slope = Sen's slope (robust non-parametric trend estimate)\n")
cat("- mann_kendall_tau = strength of monotonic trend (-1 to +1)\n")
cat("- Use recommended_test column to know which result to report\n")
```


#Make table of all stats results 
```{r}
# Combine all results
all_results <- rbind(gf_ta_results, ta_results, gf_ts_results, ts_results, 
                     swc_results, vpd_results, rh_results, h_results, 
                     le_results, g_results)

# View the complete table
print(all_results)

# Select specific columns for cleaner presentation
supp_table <- all_results %>%
  select(variable, season, n_years, mean_value, units,
         slope, slope_se, slope_p, 
         adj_r_squared,
         mann_kendall_tau, mann_kendall_p, sens_slope,
         spearman_rho, spearman_p,
         shapiro_p, normal, recommended_test, significant) %>%
  arrange(variable, season)


supp_table

# Export to CSV
# write.csv(supp_table, "C:/Users/kkent/Documents/Github Flux Network/Council_Flux_Analysis_Paper/Council Figures/seasonal_met_trends_statisticscsv2", row.names = FALSE)

write_xlsx(supp_table, "C:/Users/kkent/Documents/Github Flux Network/Council_Flux_Analysis_Paper/Council Figures/seasonal_met_trends_statistics_XL2.xlsx")

```

#trying to sens-slope to work -- Sens_slope goes hand in hand with the Mann-Kendall test for timeseries. It shows the magnitude of change across time (similar to slope in linear regression but robust to outliers and data that don't meet assumptions/autocorrelation)
```{r}
install.packages("trend")


# Tests for significant trends in environmental variables by season (2017-2022)

library(dplyr)
library(broom)
library(Kendall)  # For proper Mann-Kendall test
library(trend)    # For Sen's slope (zyp package is an alternative)

# ============================================================================
# FUNCTION: Test trends for a variable within each season
# ============================================================================

test_seasonal_trends <- function(data, var_name, var_label, units) {
  
  results_list <- list()
  seasons <- unique(data$season)
  
  for (s in seasons) {
    season_data <- data %>% filter(season == s) %>% arrange(year)  # Ensure temporal order!
    
    # Extract variable values
    y_vals <- season_data[[var_name]]
    x_vals <- season_data$year
    
    # Skip if too many NAs
    if (sum(!is.na(y_vals)) < 4) {
      next
    }
    
    # Linear regression
    lm_model <- lm(y_vals ~ x_vals)
    lm_summary <- summary(lm_model)
    
    # Test normality of RESIDUALS (not raw data)
    residuals_vals <- residuals(lm_model)
    shapiro_p <- shapiro.test(residuals_vals)$p.value
    
    # Extract key statistics from linear model
    slope <- coef(lm_model)[2]
    slope_se <- summary(lm_model)$coefficients[2, 2]
    slope_p <- summary(lm_model)$coefficients[2, 4]
    r_squared <- lm_summary$r.squared
    adj_r_squared <- lm_summary$adj.r.squared
    
    # PROPER Mann-Kendall test for temporal trends
    mk_test <- MannKendall(y_vals)
    mk_tau <- as.numeric(mk_test$tau)
    mk_p <- as.numeric(mk_test$sl)  # significance level (p-value)
    
    # Spearman correlation (alternative non-parametric option)
    spearman_test <- cor.test(x_vals, y_vals, method = "spearman")
    spearman_rho <- spearman_test$estimate
    spearman_p <- spearman_test$p.value
    
    # Sen's slope (robust trend estimator, pairs well with Mann-Kendall)
    sens_slope <- NA
    tryCatch({
      # Remove NAs before calculating Sen's slope
      y_clean <- y_vals[!is.na(y_vals)]
      if(length(y_clean) >= 3) {  # Need at least 3 observations
        sens_test <- sens.slope(y_clean)
        sens_slope <- as.numeric(sens_test$estimates)
      }
    }, error = function(e) {
      # If trend package doesn't work, try zyp package as alternative
      tryCatch({
        if(requireNamespace("zyp", quietly = TRUE)) {
          y_clean <- y_vals[!is.na(y_vals)]
          sens_result <- zyp::zyp.sen(y_clean ~ seq_along(y_clean))
          sens_slope <- as.numeric(coef(sens_result)[2])
        }
      }, error = function(e2) {
        cat("Warning: Sen's slope failed for", var_label, "in", s, "\n")
      })
    })
    
    # Store results
    results_list[[s]] <- data.frame(
      season = s,
      variable = var_label,
      units = units,
      n_years = length(y_vals),
      mean_value = mean(y_vals, na.rm = TRUE),
      
      # Normality test
      shapiro_p = shapiro_p,
      normal = ifelse(shapiro_p > 0.05, "Yes", "No"),
      
      # Linear model (parametric)
      slope = slope,
      slope_se = slope_se,
      slope_p = slope_p,
      r_squared = r_squared,
      adj_r_squared = adj_r_squared,
      
      # Non-parametric tests
      mann_kendall_tau = mk_tau,
      mann_kendall_p = mk_p,
      sens_slope = sens_slope,
      spearman_rho = spearman_rho,
      spearman_p = spearman_p,
      
      # Significance (using appropriate test)
      significant = ifelse(shapiro_p > 0.05, 
                          ifelse(slope_p < 0.05, "Yes*", "No"),
                          ifelse(mk_p < 0.05, "Yes**", "No")),
      recommended_test = ifelse(shapiro_p > 0.05, 
                               "Linear Regression", 
                               "Mann-Kendall"),
      
      stringsAsFactors = FALSE
    )
  }
  
  # Combine all seasons
  do.call(rbind, results_list)
}

# ============================================================================
# RUN TESTS FOR ALL VARIABLES
# ============================================================================

cat("============================================================\n")
cat("ANNUAL TREND ANALYSIS BY SEASON (2017-2022)\n")
cat("============================================================\n\n")

cat("Significance codes:\n")
cat("* = Linear regression (residuals normal)\n")
cat("** = Mann-Kendall test (residuals non-normal)\n")
cat("p < 0.05 = significant trend\n\n")

# GF Air Temperature
cat("\n--- AIR TEMPERATURE (Gap-filled) ---\n")
gf_ta_results <- test_seasonal_trends(seasonal_summary_all, 
                                    "TA_gapfilled_mean", 
                                    "GF Air Temperature", 
                                    "°C")
print(gf_ta_results[, c("season", "mean_value", "normal", "slope", "slope_p", 
                     "mann_kendall_tau", "mann_kendall_p", "sens_slope",
                     "recommended_test", "significant")])

# Air Temperature (measured)
cat("\n--- AIR TEMPERATURE (measured) ---\n")
ta_results <- test_seasonal_trends(seasonal_summary_all, 
                                    "TA_mean", 
                                    "Air Temperature", 
                                    "°C")
print(ta_results[, c("season", "mean_value", "normal", "slope", "slope_p", 
                     "mann_kendall_tau", "mann_kendall_p", "sens_slope",
                     "recommended_test", "significant")])

# GF Soil Temperature
cat("\n--- SOIL TEMPERATURE (Gap-filled) ---\n")
gf_ts_results <- test_seasonal_trends(seasonal_summary_all, 
                                    "TS_3_gapfilled_mean", 
                                    "GF Soil Temperature", 
                                    "°C")
print(gf_ts_results[, c("season", "mean_value", "normal", "slope", "slope_p", 
                     "mann_kendall_tau", "mann_kendall_p", "sens_slope",
                     "recommended_test", "significant")])

# Soil Temperature (measured)
cat("\n--- SOIL TEMPERATURE ---\n")
ts_results <- test_seasonal_trends(seasonal_summary_all, 
                                    "TS_3_mean", 
                                    "Soil Temperature", 
                                    "°C")
print(ts_results[, c("season", "mean_value", "normal", "slope", "slope_p", 
                     "mann_kendall_tau", "mann_kendall_p", "sens_slope",
                     "recommended_test", "significant")])

# Soil Moisture
cat("\n--- SOIL MOISTURE ---\n")
swc_results <- test_seasonal_trends(seasonal_summary_all, 
                                     "SWC_3_mean", 
                                     "Soil Moisture", 
                                     "%")
print(swc_results[, c("season", "mean_value", "normal", "slope", "slope_p", 
                      "mann_kendall_tau", "mann_kendall_p", "sens_slope",
                      "recommended_test", "significant")])

# VPD
cat("\n--- VAPOR PRESSURE DEFICIT ---\n")
vpd_results <- test_seasonal_trends(seasonal_summary_all, 
                                     "VPD_mean", 
                                     "VPD", 
                                     "hPa")
print(vpd_results[, c("season", "mean_value", "normal", "slope", "slope_p", 
                      "mann_kendall_tau", "mann_kendall_p", "sens_slope",
                      "recommended_test", "significant")])

# RH
cat("\n--- RH ---\n")
rh_results <- test_seasonal_trends(seasonal_summary_all, 
                                     "RH_mean", 
                                     "RH", 
                                     "%")
print(rh_results[, c("season", "mean_value", "normal", "slope", "slope_p", 
                      "mann_kendall_tau", "mann_kendall_p", "sens_slope",
                      "recommended_test", "significant")])

# Sensible Heat
cat("\n--- SENSIBLE HEAT FLUX ---\n")
h_results <- test_seasonal_trends(seasonal_summary_all, 
                                   "H_mean", 
                                   "Sensible Heat", 
                                   "W/m²")
print(h_results[, c("season", "mean_value", "normal", "slope", "slope_p", 
                    "mann_kendall_tau", "mann_kendall_p", "sens_slope",
                    "recommended_test", "significant")])

# Latent Heat
cat("\n--- LATENT HEAT FLUX ---\n")
le_results <- test_seasonal_trends(seasonal_summary_all, 
                                    "LE_mean", 
                                    "Latent Heat", 
                                    "W/m²")
print(le_results[, c("season", "mean_value", "normal", "slope", "slope_p", 
                     "mann_kendall_tau", "mann_kendall_p", "sens_slope",
                     "recommended_test", "significant")])

# Ground Heat
cat("\n--- GROUND HEAT FLUX ---\n")
g_results <- test_seasonal_trends(seasonal_summary_all, 
                                    "G_mean", 
                                    "Ground Heat Flux", 
                                    "W/m²")
print(g_results[, c("season", "mean_value", "normal", "slope", "slope_p", 
                     "mann_kendall_tau", "mann_kendall_p", "sens_slope",
                     "recommended_test", "significant")])

# ============================================================================
# COMBINE ALL RESULTS INTO ONE TABLE
# ============================================================================

all_results <- rbind(gf_ta_results, ta_results, gf_ts_results, ts_results, swc_results, 
                     vpd_results, rh_results, h_results, le_results, g_results)

cat("\n\n============================================================\n")
cat("SUMMARY: SIGNIFICANT TRENDS ONLY\n")
cat("============================================================\n")

significant_trends <- all_results %>%
  filter(significant %in% c("Yes*", "Yes**")) %>%
  select(variable, season, mean_value, units, slope, sens_slope,
         mann_kendall_tau, mann_kendall_p, slope_p, recommended_test, significant)

if (nrow(significant_trends) > 0) {
  print(significant_trends)
} else {
  cat("No statistically significant trends detected at p < 0.05\n")
}

cat("\n\nInterpretation:\n")
cat("- Positive slope/tau = increasing trend over time\n")
cat("- Negative slope/tau = decreasing trend over time\n")
cat("- slope = parametric trend estimate (°C/year, W/m²/year, etc.)\n")
cat("- sens_slope = Sen's slope (robust non-parametric trend estimate)\n")
cat("- mann_kendall_tau = strength of monotonic trend (-1 to +1)\n")
cat("- Use recommended_test column to know which result to report\n")
```

#Make table of all stats results 
```{r}
# Combine all results
all_results <- rbind(gf_ta_results, ta_results, gf_ts_results, ts_results, 
                     swc_results, vpd_results, rh_results, h_results, 
                     le_results, g_results)

# View the complete table
print(all_results)

# Select specific columns for cleaner presentation
supp_table <- all_results %>%
  select(variable, season, n_years, mean_value, units,
         slope, slope_se, slope_p, 
         adj_r_squared,
         mann_kendall_tau, mann_kendall_p, sens_slope,
         spearman_rho, spearman_p,
         shapiro_p, normal, recommended_test, significant) %>%
  arrange(variable, season)


supp_table

# Export to CSV
# write.csv(supp_table, "C:/Users/kkent/Documents/Github Flux Network/Council_Flux_Analysis_Paper/Council Figures/seasonal_met_trends_statisticscsv2", row.names = FALSE)

write_xlsx(supp_table, "C:/Users/kkent/Documents/Github Flux Network/Council_Flux_Analysis_Paper/Council Figures/seasonal_met_trends_statistics_XL3.xlsx")
```



#Trying to automate visuals that use the appropriate test (linear reg for slope, R2, p or mann-kendall for tau, sens-slope, and mk p) - code from Claude 

#this doesn't really work bc n=6, so everything is coming up as normal/homogeneity of var, when it may or may not be. Best to use non-parametric here but leaving this code becuase it's a good reference for automation 

```{r}
# VISUALIZATION: Seasonal Trends Over Time (2017-2022)
# Automatically plots linear regression or Sen's slope based on normality

library(ggplot2)
library(dplyr)
library(trend)
library(gridExtra)

# ============================================================================
# FUNCTION: Create trend plot for a variable within a season
# ============================================================================

plot_seasonal_trend <- function(data, var_name, season_name, 
                                result_row, var_label, units) {
  
  # Filter data for this season and arrange by year
  plot_data <- data %>% 
    filter(season == season_name) %>%
    arrange(year) %>%
    select(year, value = !!sym(var_name)) %>%
    filter(!is.na(value))
  
  # Determine which test to use
  use_parametric <- result_row$normal == "Yes"
  
  # Create base plot
  p <- ggplot(plot_data, aes(x = year, y = value)) +
    geom_point(size = 4, alpha = 0.7, color = "#2166ac") +
    theme_bw() +
    theme(
      plot.title = element_text(face = "bold", size = 13),
      axis.title = element_text(face = "bold", size = 11),
      axis.text = element_text(size = 10),
      panel.grid.minor = element_blank()
    )
  
  # Add appropriate trend line and statistics
  if(use_parametric) {
    # Use linear regression
    p <- p + 
      geom_smooth(method = "lm", se = TRUE, 
                  color = "#d73027", fill = "#d73027", 
                  alpha = 0.2, linewidth = 1.2) +
      labs(
        title = paste0(var_label, " - ", season_name),
        subtitle = "Linear Regression (Normal Residuals)",
        x = "Year",
        y = paste0(var_label, " (", units, ")")
      )
    
    # Create annotation text
    stats_text <- paste0(
      "Slope = ", sprintf("%.4f", result_row$slope), " ", units, "/year",
      "\nR² = ", sprintf("%.3f", result_row$adj_r_squared),
      "\np = ", format.pval(result_row$slope_p, digits = 3),
      "\n", ifelse(result_row$significant == "Yes*", "✓ Significant", "Not significant")
    )
    
  } else {
    # Use Sen's slope
    # Calculate Sen's slope line for plotting
    sens_slope_val <- result_row$sens_slope
    
    if(!is.na(sens_slope_val)) {
      # Calculate intercept for Sen's slope line
      # Use median point as anchor
      median_year <- median(plot_data$year)
      median_value <- median(plot_data$value)
      sens_intercept <- median_value - sens_slope_val * median_year
      
      p <- p + 
        geom_abline(slope = sens_slope_val, 
                    intercept = sens_intercept,
                    color = "#1b7837", linewidth = 1.2) +
        # Add a ribbon for uncertainty (optional - using IQR as rough estimate)
        stat_smooth(method = "lm", formula = y ~ x, 
                   se = TRUE, alpha = 0.1, 
                   color = NA, fill = "#1b7837")
    }
    
    p <- p + 
      labs(
        title = paste0(var_label, " - ", season_name),
        subtitle = "Mann-Kendall Trend Test (Non-Normal Residuals)",
        x = "Year",
        y = paste0(var_label, " (", units, ")")
      )
    
    # Create annotation text
    stats_text <- paste0(
      "Sen's Slope = ", sprintf("%.4f", result_row$sens_slope), " ", units, "/year",
      "\nτ = ", sprintf("%.3f", result_row$mann_kendall_tau),
      "\np = ", format.pval(result_row$mann_kendall_p, digits = 3),
      "\n", ifelse(result_row$significant == "Yes**", "✓ Significant", "Not significant")
    )
  }
  
  # Add statistics annotation
  p <- p + 
    annotate("text", 
             x = min(plot_data$year), 
             y = max(plot_data$value), 
             label = stats_text,
             hjust = 0, vjust = 1, 
             size = 3.5, 
             fontface = "bold",
             color = ifelse(use_parametric, "#d73027", "#1b7837"))
  
  return(p)
}

# ============================================================================
# FUNCTION: Create plots for all seasons of a variable
# ============================================================================

plot_all_seasons <- function(data, var_name, results_df, var_label, units, 
                             save_file = TRUE) {
  
  plot_list <- list()
  seasons <- unique(results_df$season)
  
  for(s in seasons) {
    result_row <- results_df %>% filter(season == s)
    
    if(nrow(result_row) == 0) next
    
    p <- plot_seasonal_trend(data, var_name, s, result_row, var_label, units)
    plot_list[[s]] <- p
  }
  
  # Combine plots
  if(length(plot_list) > 0) {
    combined <- grid.arrange(grobs = plot_list, ncol = 2)
    
    # Save if requested
    # if(save_file) {
    #   filename <- paste0(gsub(" ", "_", var_label), "_seasonal_trends.png")
    #   ggsave(filename, combined, width = 12, height = 8, dpi = 300)
    #   cat("Saved:", filename, "\n")
    #}
    
    return(combined)
  }
}

# ============================================================================
# CREATE PLOTS FOR SIGNIFICANT TRENDS
# ============================================================================

cat("============================================================\n")
cat("CREATING SEASONAL TREND VISUALIZATIONS\n")
cat("============================================================\n\n")

cat("Red lines = Linear Regression (normal residuals)\n")
cat("Green lines = Sen's Slope (non-normal residuals)\n\n")

# Example usage - modify based on your variable names in seasonal_summary_all

# Air Temperature (gap-filled)
cat("\n--- Plotting Air Temperature (Gap-filled) ---\n")
if(exists("gf_ta_results")) {
  plot_all_seasons(seasonal_summary_all, "TA_gapfilled_mean", 
                   gf_ta_results, "Air Temperature (GF)", "°C")
}

# Soil Temperature (gap-filled)
cat("\n--- Plotting Soil Temperature (Gap-filled) ---\n")
if(exists("gf_ts_results")) {
  plot_all_seasons(seasonal_summary_all, "TS_3_gapfilled_mean", 
                   gf_ts_results, "Soil Temperature (GF)", "°C")
}

# Soil Moisture
cat("\n--- Plotting Soil Moisture ---\n")
if(exists("swc_results")) {
  plot_all_seasons(seasonal_summary_all, "SWC_3_mean", 
                   swc_results, "Soil Moisture", "%")
}

# VPD
cat("\n--- Plotting VPD ---\n")
if(exists("vpd_results")) {
  plot_all_seasons(seasonal_summary_all, "VPD_mean", 
                   vpd_results, "VPD", "hPa")
}

# RH
cat("\n--- Plotting RH ---\n")
if(exists("rh_results")) {
  plot_all_seasons(seasonal_summary_all, "RH_mean", 
                   rh_results, "Relative Humidity", "%")
}

# Sensible Heat
cat("\n--- Plotting Sensible Heat ---\n")
if(exists("h_results")) {
  plot_all_seasons(seasonal_summary_all, "H_mean", 
                   h_results, "Sensible Heat Flux", "W/m²")
}

# Latent Heat
cat("\n--- Plotting Latent Heat ---\n")
if(exists("le_results")) {
  plot_all_seasons(seasonal_summary_all, "LE_mean", 
                   le_results, "Latent Heat Flux", "W/m²")
}

# Ground Heat
cat("\n--- Plotting Ground Heat ---\n")
if(exists("g_results")) {
  plot_all_seasons(seasonal_summary_all, "G_mean", 
                   g_results, "Ground Heat Flux", "W/m²")
}

# ============================================================================
# CREATE A SUMMARY PLOT OF ONLY SIGNIFICANT TRENDS
# ============================================================================

cat("\n\n--- Creating Summary Plot (Significant Trends Only) ---\n")

# Combine all results
if(exists("all_results")) {
  significant_results <- all_results %>%
    filter(significant %in% c("Yes*", "Yes**"))
  
  if(nrow(significant_results) > 0) {
    sig_plot_list <- list()
    
    for(i in 1:nrow(significant_results)) {
      row <- significant_results[i,]
      
      # Determine the variable name in the dataset
      var_map <- list(
        "GF Air Temperature" = "TA_gapfilled_mean",
        "Air Temperature" = "TA_mean",
        "GF Soil Temperature" = "TS_3_gapfilled_mean",
        "Soil Temperature" = "TS_3_mean",
        "Soil Moisture" = "SWC_3_mean",
        "VPD" = "VPD_mean",
        "RH" = "RH_mean",
        "Sensible Heat" = "H_mean",
        "Latent Heat" = "LE_mean",
        "Ground Heat Flux" = "G_mean"
      )
      
      var_name <- var_map[[row$variable]]
      if(!is.null(var_name)) {
        p <- plot_seasonal_trend(seasonal_summary_all, var_name, 
                                row$season, row, row$variable, row$units)
        sig_plot_list[[paste(row$variable, row$season)]] <- p
      }
    }
    
    if(length(sig_plot_list) > 0) {
      n_plots <- length(sig_plot_list)
      ncol_sig <- ifelse(n_plots <= 2, 2, 3)
      nrow_sig <- ceiling(n_plots / ncol_sig)
      
      sig_combined <- grid.arrange(
        grobs = sig_plot_list, 
        ncol = ncol_sig,
        top = grid::textGrob("Significant Seasonal Trends (2017-2022)", 
                            gp = grid::gpar(fontsize = 16, fontface = "bold"))
      )
      
      # ggsave("Significant_seasonal_trends_combined.png", sig_combined,
      #        width = 6 * ncol_sig, height = 5 * nrow_sig, dpi = 300)
      cat("Saved: Significant_seasonal_trends_combined.png\n")
    }
  } else {
    cat("No significant trends to plot.\n")
  }
}

cat("\n\nVisualization complete!\n")
cat("- Individual seasonal trend plots saved for each variable\n")
cat("- Red lines = Linear regression (normal residuals)\n")
cat("- Green lines = Sen's slope (non-normal residuals)\n")
cat("- Statistics shown match the recommended test\n")
```



