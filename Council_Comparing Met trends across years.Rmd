---
title: "Council_Comparing Met trends"
output: html_document
date: "2025-01-13"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, include=FALSE}
rm(list = ls())

library(data.table)
library(ggplot2)
library(cowplot)
library(openair)
library(plotrix)
library(signal)
library(svMisc)
library(zoo)
library(stringr)
library(plyr)
library(viridis)
library(lubridate)
library(tidyverse)
library(gridExtra)
library(plotly)
library(RColorBrewer)
library(pracma)
library(dplyr)

#install.packages("writexl")
library(writexl)


Sys.setenv(TZ='UTC')
```

# Set working directory and then Load data


```{r}
#with gapfilled soil and air temp columns; SWC 3
# #half-hourly, gf (corrected seasons, Nov'25)
df = fread('C:/Users/kkent/Documents/Council Data/Council BASE gapfilling/council_gapfilled_clean_2017_2023_for analysis.2.csv',na.strings = c('-9999','NA','NaN','NAN','-7999'))


#daily avg dataframe --> gapfilled - updated seasons Nov 2025; added winter year Dec 2025
df_avg = fread('C:/Users/kkent/Documents/Council Data/Council BASE gapfilling/council_AVG_gapfilled_clean_2017_2023_for analysis.5.csv',na.strings = c('-9999','NA','NaN','NAN','-7999'))


```


#Annual Avg air temp (based on all years, 2017 - 2022, excluding the incomplete 2023*)
```{r}
library(dplyr)
library(lubridate)

annual_temps <- df_avg %>%
  mutate(year = year(date)) %>%      # extract the calendar year
  filter(year >= 2017, year <= 2022) %>%  
  group_by(year) %>%                 
  summarise(
    obs_airtemp    = mean(TA, na.rm = TRUE),  # observed
    obs_airtemp_se   = sd(TA, na.rm = TRUE)/sqrt(sum(!is.na(TA))),   # annual standard deviation
    era5_airtemp   = mean(TA_ERA5,   na.rm = TRUE),   # modeled air temp 
    era5_airtemp_se   = sd(TA_ERA5, na.rm = TRUE)/sqrt(sum(!is.na(TA_ERA5))),
    obs_soiltemp = mean(TS_3_1_1, na.rm = TRUE), #observed soil temp at TS3
    obs_soiltemp_se = sd(TS_3_1_1, na.rm = TRUE)/sqrt(sum(!is.na(TS_3_1_1))),
    era5_soiltemp = mean(TS_ERA5, na.rm = TRUE), #modeled soil temp 
    era5_soiltemp_se = sd(TS_ERA5, na.rm = TRUE /sqrt(sum(!is.na(TS_ERA5))))
    )
#sd(FC, na.rm = TRUE)/sqrt(sum(!is.na(FC)))
print(annual_temps)

```

#Era5.mod-gapfilled Annual Avg air & soil (TS_3) temp (based on all years, 2017 - 2022, excluding the incomplete 2023*)
```{r}
library(dplyr)
library(lubridate)

annual_temps2 <- df_avg %>%
  mutate(year = year(date)) %>%      
  filter(year >= 2017, year <= 2022) %>%  
  group_by(year) %>%                 
  summarise(
    TA_gapfilled_avg   = mean(TA_gapfilled, na.rm = TRUE),  
   TA_gapfilled_se   = sd(TA_gapfilled, na.rm = TRUE)/sqrt(sum(!is.na(TA_gapfilled))), 
    TS_3_gapfilled_avg = mean(TS_3_gapfilled, na.rm = TRUE), 
    TS_3_gapfilled_se = sd(TS_3_gapfilled, na.rm = TRUE)/sqrt(sum(!is.na(TS_3_gapfilled)))
    )


#sd(FC, na.rm = TRUE)/sqrt(sum(!is.na(FC)))
print(annual_temps2)


```

# % gapfilled vs observed for TS3 and TA

```{r}
# Calculate percentages for Air Temperature (TA)
#HH - year, season 
TA_summaryHH <- df %>%
   filter( year != 2023) %>%
  group_by(year, season) %>%
  summarise(
    total_records = n(),
    observed_count = sum(TA_gapfilled_flag == "observed", na.rm = TRUE),
    gapfilled_count = sum(TA_gapfilled_flag == "gapfilled", na.rm = TRUE),
    missing_count = sum(is.na(TA_gapfilled)),
    observed_percent = round((observed_count / total_records) * 100, 1),
    gapfilled_percent = round((gapfilled_count / total_records) * 100, 1),
    missing_percent = round((missing_count / total_records) * 100, 1)
  ) %>%
  mutate(variable = "Air_Temperature")

#daily avg - year, season
TA_summary <- df_avg %>%
   filter( year != 2023) %>%
  group_by(year, season) %>%
  summarise(
    total_records = n(),
    observed_count = sum(TA_gapfilled_flag == "observed", na.rm = TRUE),
    gapfilled_count = sum(TA_gapfilled_flag == "gapfilled", na.rm = TRUE),
    missing_count = sum(is.na(TA_gapfilled)),
    observed_percent = round((observed_count / total_records) * 100, 1),
    gapfilled_percent = round((gapfilled_count / total_records) * 100, 1),
    missing_percent = round((missing_count / total_records) * 100, 1)
  ) %>%
  mutate(variable = "Air_Temperature")
TA_summary

#HH - year only 
TA_summaryHH_annual <- df %>%
   filter( year != 2023) %>%
  group_by(year) %>%
  summarise(
    total_records = n(),
    observed_count = sum(TA_gapfilled_flag == "observed", na.rm = TRUE),
    gapfilled_count = sum(TA_gapfilled_flag == "gapfilled", na.rm = TRUE),
    missing_count = sum(is.na(TA_gapfilled)),
    observed_percent = round((observed_count / total_records) * 100, 1),
    gapfilled_percent = round((gapfilled_count / total_records) * 100, 1),
    missing_percent = round((missing_count / total_records) * 100, 1)
  ) %>%
  mutate(variable = "Air_Temperature")

#daily avg - year only
TA_summary_annual <- df_avg %>%
   filter( year != 2023) %>%
  group_by(year) %>%
  summarise(
    total_records = n(),
    observed_count = sum(TA_gapfilled_flag == "observed", na.rm = TRUE),
    gapfilled_count = sum(TA_gapfilled_flag == "gapfilled", na.rm = TRUE),
    missing_count = sum(is.na(TA_gapfilled)),
    observed_percent = round((observed_count / total_records) * 100, 1),
    gapfilled_percent = round((gapfilled_count / total_records) * 100, 1),
    missing_percent = round((missing_count / total_records) * 100, 1)
  ) %>%
  mutate(variable = "Air_Temperature")


# Calculate percentages for Soil Temperature (TS_3_1_1)

#HH - year, season 
TS_summaryHH <- df %>%
  filter( year != 2023) %>%
  group_by(year, season) %>%
  summarise(
    total_records = n(),
    observed_count = sum(TS_3_gapfilled_flag == "observed", na.rm = TRUE),
    gapfilled_count = sum(TS_3_gapfilled_flag == "gapfilled", na.rm = TRUE),
    missing_count = sum(is.na(TS_3_gapfilled)),
    observed_percent = round((observed_count / total_records) * 100, 1),
    gapfilled_percent = round((gapfilled_count / total_records) * 100, 1),
    missing_percent = round((missing_count / total_records) * 100, 1)
  ) %>%
  mutate(variable = "Soil_Temperature")


#daily avg - year, season 
TS_summary <- df_avg %>%
   filter( year != 2023) %>%
  group_by(year, season ) %>%
  summarise(
    total_records = n(),
    observed_count = sum(TS_3_gapfilled_flag == "observed", na.rm = TRUE),
    gapfilled_count = sum(TS_3_gapfilled_flag == "gapfilled", na.rm = TRUE),
    missing_count = sum(is.na(TS_3_gapfilled)),
    observed_percent = round((observed_count / total_records) * 100, 1),
    gapfilled_percent = round((gapfilled_count / total_records) * 100, 1),
    missing_percent = round((missing_count / total_records) * 100, 1)
  ) %>%
  mutate(variable = "Soil_Temperature")

#HH - year only 
TS_summaryHH_annual <- df %>%
  filter( year != 2023) %>%
  group_by(year) %>%
  summarise(
    total_records = n(),
    observed_count = sum(TS_3_gapfilled_flag == "observed", na.rm = TRUE),
    gapfilled_count = sum(TS_3_gapfilled_flag == "gapfilled", na.rm = TRUE),
    missing_count = sum(is.na(TS_3_gapfilled)),
    observed_percent = round((observed_count / total_records) * 100, 1),
    gapfilled_percent = round((gapfilled_count / total_records) * 100, 1),
    missing_percent = round((missing_count / total_records) * 100, 1)
  ) %>%
  mutate(variable = "Soil_Temperature")


#daily avg - year only 
TS_summary_annual <- df_avg %>%
   filter( year != 2023) %>%
  group_by(year, season ) %>%
  summarise(
    total_records = n(),
    observed_count = sum(TS_3_gapfilled_flag == "observed", na.rm = TRUE),
    gapfilled_count = sum(TS_3_gapfilled_flag == "gapfilled", na.rm = TRUE),
    missing_count = sum(is.na(TS_3_gapfilled)),
    observed_percent = round((observed_count / total_records) * 100, 1),
    gapfilled_percent = round((gapfilled_count / total_records) * 100, 1),
    missing_percent = round((missing_count / total_records) * 100, 1)
  ) %>%
  mutate(variable = "Soil_Temperature")

```





#Table: seasonal and annual total C budget & met variable tables 
```{r}
# Load necessary packages
library(dplyr)
library(lubridate)

#Annual and seasonal summaries with SE 

#no SE for CO2 and CH4 fluxes as these are sums **** then we calc averages with SE for the met variables 

# Annual summaries with standard errors
# Annual summaries with total C budget
annual_budgets <- df_avg %>%
  group_by(year = year(date)) %>%
  filter(year != 2023) %>% #removing 2023 due to incomplete year data 
  summarize(
    CO2_budget = sum(FC_F * (60*60*24*(1/1000000)*12), na.rm = TRUE),
    CH4_budget = sum(FCH4_F * (60*60*24*(1/1000000000)*12), na.rm = TRUE),
    total_C_budget = CO2_budget + CH4_budget,  # Adding total C budget
    mean_soil_temp = mean(TS_3_1_1, na.rm = TRUE),
    se_soil_temp = sd(TS_3_1_1, na.rm = TRUE)/sqrt(sum(!is.na(TS_3_1_1))),
    mean_TS_ERA5 = mean(TS_ERA5, na.rm = TRUE),
    se_TS_ERA5 = sd(TS_ERA5, na.rm = TRUE)/sqrt(sum(!is.na(TS_ERA5))),
    mean_soil_moisture = mean(SWC_3_1_1, na.rm = TRUE),
    se_soil_moisture = sd(SWC_3_1_1, na.rm = TRUE)/sqrt(sum(!is.na(SWC_3_1_1))),
    mean_TA = mean(TA, na.rm = TRUE),
    se_TA = sd(TA, na.rm = TRUE)/sqrt(sum(!is.na(TA))),
    mean_TA_ERA5 = mean(TA_ERA5, na.rm = TRUE),
    se_TA_ERA5 = sd(TA_ERA5, na.rm = TRUE)/sqrt(sum(!is.na(TA_ERA5))),
    mean_TA_gapfilled   = mean(TA_gapfilled, na.rm = TRUE),  
   se_TA_gapfilled   = sd(TA_gapfilled, na.rm = TRUE)/sqrt(sum(!is.na(TA_gapfilled))), 
    mean_TS_3_gapfilled = mean(TS_3_gapfilled, na.rm = TRUE), 
    se_TS_3_gapfilled = sd(TS_3_gapfilled, na.rm = TRUE /sqrt(sum(!is.na(TS_3_gapfilled))))
      )


# Seasonal summaries with total C budget
seasonal_budgets <- df_avg %>%
  group_by(year = year(date), season) %>%
  filter(year != 2023) %>% #removing 2023 due to incomplete year data 
  summarize(
    CO2_budget = sum(FC_F * (60*60*24*(1/1000000)*12), na.rm = TRUE),
    CH4_budget = sum(FCH4_F * (60*60*24*(1/1000000000)*12), na.rm = TRUE),
    total_C_budget = CO2_budget + CH4_budget,  # Adding total C budget
    mean_soil_temp = mean(TS_3_1_1, na.rm = TRUE),
    se_soil_temp = sd(TS_3_1_1, na.rm = TRUE)/sqrt(sum(!is.na(TS_3_1_1))),
    mean_TS_ERA5 = mean(TS_ERA5, na.rm = TRUE),
    se_TS_ERA5 = sd(TS_ERA5, na.rm = TRUE)/sqrt(sum(!is.na(TS_ERA5))),
    mean_soil_moisture = mean(SWC_3_1_1, na.rm = TRUE),
    se_soil_moisture = sd(SWC_3_1_1, na.rm = TRUE)/sqrt(sum(!is.na(SWC_3_1_1))),
    mean_TA = mean(TA, na.rm = TRUE),
    se_TA = sd(TA, na.rm = TRUE)/sqrt(sum(!is.na(TA))),
    mean_TA_ERA5 = mean(TA_ERA5, na.rm = TRUE),
    se_TA_ERA5 = sd(TA_ERA5, na.rm = TRUE)/sqrt(sum(!is.na(TA_ERA5))),
    mean_TA_gapfilled   = mean(TA_gapfilled, na.rm = TRUE),  
    se_TA_gapfilled   = sd(TA_gapfilled, na.rm = TRUE)/sqrt(sum(!is.na(TA_gapfilled))), 
    mean_TS_3_gapfilled = mean(TS_3_gapfilled, na.rm = TRUE), 
    se_TS_3_gapfilled = sd(TS_3_gapfilled, na.rm = TRUE /sqrt(sum(!is.na(TS_3_gapfilled)))),
    days = n()
  )

print(annual_budgets)
print(seasonal_budgets)


```

#As winter SWC measurements can't be trusted without specific probe calibrations / data processing, we should remove SWC measurements from winter / when the ground is frozen or going through freeze-thaw processes

#### checking winter dates included when filtering for TS3_gapfilled >= 2 C 
```{r}
df_avg_winter_tempcheck <- df_avg_winter %>%
  filter(TS_3_gapfilled >= 2)

ggplot(df_avg_winter_tempcheck)+
  geom_point(aes(x=date, y = TA_gapfilled, color = factor(year)))

#Shows 3 dates when there is a winter day with TS3_gf above 2 with high TA_gf temps - these are "measured" but seem to be outliers May 20 - 22 in year 2022 
```

#Freeze-threshold exploration 
```{r}
#checking to see if there is a natural "drop-off" in SWC by TS_3 to see if we can identify a freeze-threshold to use for excluding SWC measurements from frozen ground 

#all
ggplot(df_avg)+
  geom_point(aes(x=TS_3_gapfilled, y = SWC_3_1_1, color = factor(year))) +
  labs(title = "Daily Avg")


#all
ggplot(df)+
  geom_point(aes(x=TS_3_1_1, y = SWC_3_1_1, color = factor(year))) +
  labs(title = "Daily Avg")


#all
ggplot(df_avg)+
  geom_point(aes(x=TS_3_1_1, y = SWC_3_1_1, color = factor(year))) +
  labs(title = "Daily Avg")

#axis flipped, all 
ggplot(df_avg)+
  geom_point(aes(x=SWC_3_1_1, y = TS_3_gapfilled, color = factor(year))) +
  labs(title = "Daily Avg")

#filtered for around freezing/thawing temps - remember these probes are to 15cm, not surface level 
ggplot(df_avg %>%
         filter(TS_3_gapfilled <= 3 & TS_3_gapfilled >= -5))+
  geom_point(aes(x=TS_3_gapfilled, y = SWC_3_1_1, color = factor(year))) +
  labs(title = "Filtered by soil temps between -5 and 3 C ")

#bigger freeze/thaw window
ggplot(df_avg %>%
         filter(TS_3_gapfilled <= 5 & TS_3_gapfilled >= -10))+
  geom_point(aes(x=TS_3_gapfilled, y = SWC_3_1_1, color = factor(year))) +
  labs(title = "Filtered by soil temps between -10 and 5 C")


#filter by DOY of known transition from "winter" to "growing season" (which is based on NEE, rather than temp) among years 
ggplot(df_avg %>%
         filter(DOY >= 115 & DOY <= 160))+
  geom_point(aes(x=TS_3_gapfilled, y = SWC_3_1_1, color = factor(year))) +
  labs(title = "Filtered by DOY between 125 and 160")

ggplot(df %>%
         filter(DOY >= 115 & DOY <= 160))+
  geom_point(aes(x=TS_3_gapfilled, y = SWC_3_1_1, color = factor(year))) +
  labs(title = "Filtered by DOY between 125 and 160")

#filter by DOY of known transition from "fall" to "winter" (which is based on TA_gf) among years 
ggplot(df_avg %>%
         filter(DOY >= 270 & DOY <= 320))+
  geom_point(aes(x=TS_3_gapfilled, y = SWC_3_1_1, color = factor(year))) +
  labs(title = "Filtered by DOY between 270 and 320, fall to winter ")

#filter by DOY of known transition from "fall" to "winter" (which is based on TA_gf) among years 
ggplot(df_avg %>%
         filter(DOY >= 270 & DOY <= 320))+
  geom_point(aes(x=SWC_3_1_1, y = TS_3_gapfilled, color = factor(year))) +
  labs(title = "Filtered by DOY between 270 and 320, fall to winter ")


#filter by DOY of known transition from "fall" to "winter" (which is based on TA_gf) among years 
ggplot(df_avg %>%
         filter(DOY >= 270 & DOY <= 350))+
  geom_point(aes(x= DOY, y = SWC_3_1_1, color = factor(year))) +
  labs(title = "Filtered by DOY between 270 and 320, fall to winter ")

#temps at percieved drop-off for most years 
ggplot(df_avg %>%
         filter(DOY >= 305 & DOY <= 320))+
  geom_point(aes(x= DOY, y = TS_3_gapfilled, color = factor(year))) +
  labs(title = "Temps at DOY 305 - 320")

#filter by DOY of known transition from "fall" to "winter" (which is based on TA_gf) among years 
ggplot(df_avg %>%
         filter(DOY >= 270 & DOY <= 320))+
  geom_point(aes(x= DOY, y = SWC_3_1_1, color = factor(year))) +
  labs(title = "Filtered by DOY between 270 and 320, fall to winter ")



#filter by DOY of known transition from "fall" to "winter" (which is based on TA_gf) among years 
ggplot(df_avg %>%
         filter(year == 2019) %>%
         filter(DOY >= 270 & DOY <= 320))+
  geom_point(aes(x=TS_3_gapfilled, y = SWC_3_1_1, color = factor(year))) +
  labs(title = "Filtered by DOY between 270 and 320, fall to winter 2019 ")



#don't see a clear threshold...
```


```{r}
#Avg annual SWC without winter (Kyle says winter SWC readings can't really be trusted, run for soil temp >= 2 degC, some wiggle room) ****************** 
#Salmabadi et al. 2025 paper uses 2 degC as a threshold for freeze/thaw processes

#by year
SWC_df_avg_nofreeze <- df_avg %>%
  group_by(year = year(date)) %>%
  filter(year != 2023) %>% #removing 2023 due to incomplete year data 
  filter(TS_3_gapfilled >= 2) 

SWC_avg_nofreeze <- SWC_df_avg_nofreeze %>%
  summarize(
     mean_soil_moisture_nf = mean(SWC_3_1_1, na.rm = TRUE),
    se_soil_moisture_nf = sd(SWC_3_1_1, na.rm = TRUE)/sqrt(sum(!is.na(SWC_3_1_1))),
          )

print(SWC_avg_nofreeze)


#year, season 
SWC_df_avg_seasonal_nofreeze <- df_avg %>%
  group_by(year = year(date), season) %>%
  filter(year != 2023) %>% #removing 2023 due to incomplete year data 
  filter(TS_3_gapfilled >= 2) 

SWC_avg_seasonal_nofreeze <- SWC_df_avg_seasonal_nofreeze %>%
  summarize(
     mean_soil_moisture_nf = mean(SWC_3_1_1, na.rm = TRUE),
    se_soil_moisture_nf = sd(SWC_3_1_1, na.rm = TRUE)/sqrt(sum(!is.na(SWC_3_1_1))),
          )

print(SWC_avg_seasonal_nofreeze)
```



#Plot for SWC when TS3_gf is >= 2 

#### Annual average for TS3_gf >= 2 (uses growing season and fall)

```{r}
p_SWC2 <- ggplot(SWC_avg_nofreeze) +
  geom_hline(yintercept = 0, color = "black", linewidth = 0.5) +
  
  geom_point(aes(x = year, y = mean_soil_moisture_nf, color = factor(year)), 
             size = 3) +
  geom_errorbar(aes(x = year, ymin = mean_soil_moisture_nf - se_soil_moisture_nf, 
                    ymax = mean_soil_moisture_nf + se_soil_moisture_nf, color = "black"), # color = year_factor),
                width = 0.3, linewidth = 0.7, alpha = 1 ) +
  
  # geom_smooth(aes(x = year, y = SWC_3_mean), 
  #             method = "auto", se = TRUE, color = "black", alpha = 0.2, linewidth = 0.8) +
  
  scale_color_manual(values = year_colors) +
  scale_x_continuous(breaks = 2017:2022) +
  
  labs(title = "Mean Annual Soil Moisture Trends (Growing Season & Fall) (2017-2022)",
       x = "Year", 
       y = "Soil Water Content (%)") +
  theme_bw() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    axis.title.x = element_text(face = "bold", size = 12),
    axis.title.y = element_text(face = "bold", size = 12),
    axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"),
    axis.text.y = element_text(face = "bold"),
    strip.text = element_text(face = "bold", size = 11),
    legend.position = "none"
  )

p_SWC2
```


#bind SWC-no freeze with budgets
```{r}
annual_budgets2 <- annual_budgets %>%
  left_join(SWC_avg_nofreeze, by = c("year"))


seasonal_budgets2 <- seasonal_budgets %>%
  left_join(SWC_avg_seasonal_nofreeze, by = c("year", "season"))

```


#Save table of annual and/or seasonal budgets with all SWC
```{r}
#Seasonal budgets - with full SWC measurements 

#install.packages("writexl")
library(writexl)

write_xlsx(seasonal_budgets, "C:/Users/kkent/Documents/Github Flux Network/Council_Flux_Analysis_Paper/Council Figures/seasonal_budgets2.xlsx")

#Write table to CSV
# base R, no additional packages needed)
# write.csv(seasonal_budgets, "seasonal_budgets.csv", row.names = FALSE)


# Create a new table with combined mean ± SE format
seasonal_budgets_formatted <- seasonal_budgets %>%
  mutate(
    soil_temp = sprintf("%.2f ± %.2f", mean_soil_temp, se_soil_temp),
    soil_moisture = sprintf("%.2f ± %.2f", mean_soil_moisture, se_soil_moisture),
    air_temp = sprintf("%.2f ± %.2f", mean_TA, se_TA),
    TS_ERA5 = sprintf("%.2f ± %.2f", mean_TS_ERA5, se_TS_ERA5),
    TA_ERA5 = sprintf("%.2f ± %.2f", mean_TA_ERA5, se_TA_ERA5),
    TA_GF = sprintf("%.2f ± %.2f", mean_TA_gapfilled, se_TA_gapfilled),
    TS3_GF = sprintf("%.2f ± %.2f", mean_TS_3_gapfilled, se_TS_3_gapfilled),
  ) %>%
  dplyr::select(year, season, CO2_budget, CH4_budget, total_C_budget, soil_temp, soil_moisture, air_temp, TS_ERA5, TA_ERA5, TA_GF, TS3_GF, days)

seasonal_budgets_formatted

# Save to Excel
write_xlsx(seasonal_budgets_formatted, "C:/Users/kkent/Documents/Github Flux Network/Council_Flux_Analysis_Paper/Council Figures/seasonal_budgets_formatted3.xlsx")

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#Annual budgets 
# Create a new table with combined mean ± SE format
annual_budgets_formatted <- annual_budgets %>%
  mutate(
    soil_temp = sprintf("%.2f ± %.2f", mean_soil_temp, se_soil_temp),
    soil_moisture = sprintf("%.2f ± %.2f", mean_soil_moisture, se_soil_moisture),
    air_temp = sprintf("%.2f ± %.2f", mean_TA, se_TA),
    TS_ERA5 = sprintf("%.2f ± %.2f", mean_TS_ERA5, se_TS_ERA5),
    TA_ERA5 = sprintf("%.2f ± %.2f", mean_TA_ERA5, se_TA_ERA5),
    TA_GF = sprintf("%.2f ± %.2f", mean_TA_gapfilled, se_TA_gapfilled),
    TS3_GF = sprintf("%.2f ± %.2f", mean_TS_3_gapfilled, se_TS_3_gapfilled),
  ) %>%
  dplyr::select(year, CO2_budget, CH4_budget, total_C_budget, soil_temp, soil_moisture, air_temp, TS_ERA5, TA_ERA5, TA_GF, TS3_GF)

annual_budgets_formatted

# Save to Excel
write_xlsx(annual_budgets_formatted, "C:/Users/kkent/Documents/Github Flux Network/Council_Flux_Analysis_Paper/Council Figures/annual_budgets_formatted2.xlsx")

```

#Add % gapfilled (from HH datasets) to seasonal and annual averages table - all SWC

```{r}
# Join the season, year datasets, adding only the gapfilled_percent column 
seasonal_budgets_with_gapfill <- seasonal_budgets %>%
  left_join(TA_summaryHH %>% select(year, season, TA_gapfill_percent = gapfilled_percent), 
            by = c("year", "season")) %>%
   left_join(TS_summaryHH %>% select(year, season, TS3_gapfill_percent = gapfilled_percent), 
            by = c("year", "season"))

# Check the result
print(seasonal_budgets_with_gapfill)


# Join the annual datasets, adding only the gapfilled_percent column
annual_budgets_with_gapfill <- seasonal_budgets %>%
  left_join(TA_summaryHH_annual %>% select(year, TA_gapfill_percent = gapfilled_percent), 
            by = c("year")) %>%
   left_join(TS_summaryHH_annual %>% select(year, TS3_gapfill_percent = gapfilled_percent), 
            by = c("year"))

# Check the result
print(annual_budgets_with_gapfill)


# ~~~~~~~~~~~~~Add to formatted tables ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#Annual 
# Join the annual datasets, adding only the gapfilled_percent column
annual_budgets_formatted2 <- annual_budgets_formatted %>%
  left_join(TA_summaryHH_annual %>% select(year, TA_gapfill_percent = gapfilled_percent), 
            by = c("year")) %>%
   left_join(TS_summaryHH_annual %>% select(year, TS3_gapfill_percent = gapfilled_percent), 
             by = c("year"))

# Check the result
print(annual_budgets_formatted2)


#Seasonal 

# Join the seasonal datasets, adding only the gapfilled_percent column
seasonal_budgets_formatted2 <- seasonal_budgets_formatted %>%
  left_join(TA_summaryHH %>% select(year, season, TA_gapfill_percent = gapfilled_percent), 
            by = c("year", "season")) %>%
   left_join(TS_summaryHH %>% select(year, season, TS3_gapfill_percent = gapfilled_percent), 
            by = c("year", "season"))

# Check the result
print(seasonal_budgets_formatted2)

```

# Save to Excel
```{r}
#annual 
write_xlsx(annual_budgets_formatted2, "C:/Users/kkent/Documents/Github Flux Network/Council_Flux_Analysis_Paper/Council Figures/annual_budgets_formatted2.xlsx")

#seasonal 
write_xlsx(seasonal_budgets_formatted2, "C:/Users/kkent/Documents/Github Flux Network/Council_Flux_Analysis_Paper/Council Figures/seasonal_budgets_formatted3.xlsx")

```


#Save table of annual and/or seasonal budgets with SWC only from TS3_gf >= 2C
```{r}
#Seasonal budgets - SWC when TS3_gf > 2C

# Create a new table with combined mean ± SE format
seasonal_budgets_formatted_nf <- seasonal_budgets2 %>%
  mutate(
    soil_temp = sprintf("%.2f ± %.2f", mean_soil_temp, se_soil_temp),
    soil_moisture = sprintf("%.2f ± %.2f", mean_soil_moisture, se_soil_moisture),
    soil_moisture_nf = sprintf("%.2f ± %.2f", mean_soil_moisture_nf, se_soil_moisture_nf),
    air_temp = sprintf("%.2f ± %.2f", mean_TA, se_TA),
    TS_ERA5 = sprintf("%.2f ± %.2f", mean_TS_ERA5, se_TS_ERA5),
    TA_ERA5 = sprintf("%.2f ± %.2f", mean_TA_ERA5, se_TA_ERA5),
    TA_GF = sprintf("%.2f ± %.2f", mean_TA_gapfilled, se_TA_gapfilled),
    TS3_GF = sprintf("%.2f ± %.2f", mean_TS_3_gapfilled, se_TS_3_gapfilled),
  ) %>%
  dplyr::select(year, season, CO2_budget, CH4_budget, total_C_budget, soil_temp, soil_moisture, soil_moisture_nf, air_temp, TS_ERA5, TA_ERA5, TA_GF, TS3_GF, days)

seasonal_budgets_formatted_nf

# Save to Excel
write_xlsx(seasonal_budgets_formatted_nf, "C:/Users/kkent/Documents/Github Flux Network/Council_Flux_Analysis_Paper/Council Figures/seasonal_budgets_formatted_nf.xlsx")

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#Annual budgets 
# Create a new table with combined mean ± SE format
annual_budgets_formatted_nf <- annual_budgets2 %>%
  mutate(
    soil_temp = sprintf("%.2f ± %.2f", mean_soil_temp, se_soil_temp),
    soil_moisture = sprintf("%.2f ± %.2f", mean_soil_moisture, se_soil_moisture),
     soil_moisture_nf = sprintf("%.2f ± %.2f", mean_soil_moisture_nf, se_soil_moisture_nf),
    air_temp = sprintf("%.2f ± %.2f", mean_TA, se_TA),
    TS_ERA5 = sprintf("%.2f ± %.2f", mean_TS_ERA5, se_TS_ERA5),
    TA_ERA5 = sprintf("%.2f ± %.2f", mean_TA_ERA5, se_TA_ERA5),
    TA_GF = sprintf("%.2f ± %.2f", mean_TA_gapfilled, se_TA_gapfilled),
    TS3_GF = sprintf("%.2f ± %.2f", mean_TS_3_gapfilled, se_TS_3_gapfilled),
  ) %>%
  dplyr::select(year, CO2_budget, CH4_budget, total_C_budget, soil_temp, soil_moisture, soil_moisture_nf, air_temp, TS_ERA5, TA_ERA5, TA_GF, TS3_GF)

annual_budgets_formatted_nf

# Save to Excel
write_xlsx(annual_budgets_formatted_nf, "C:/Users/kkent/Documents/Github Flux Network/Council_Flux_Analysis_Paper/Council Figures/annual_budgets_formatted_nf.xlsx")

```


#Comparison plots - comparison of monthly met variable means across years 

```{r}
# Load required libraries
library(ggplot2)
library(dplyr)
library(lubridate)
library(tidyr)

# Prepare the data with error bars
monthly_env_data <- df_avg2 %>%
  # Extract year and month from date
  mutate(
    year = year(date),
    month = month(date, label = TRUE, abbr = TRUE)  # Creates abbreviated month names (Jan, Feb, etc.)
  ) %>%
  # Filter for your years of interest
  filter(year >= 2017 & year <= 2023) %>%

  # Group by year and month to calculate monthly averages and standard errors
  group_by(year, month) %>%
  summarise(
    Air_Temperature_mean = mean(TA, na.rm = TRUE),
    Air_Temperature_se = sd(TA, na.rm = TRUE) / sqrt(sum(!is.na(TA))),
    Soil_Temperature_mean = mean(TS_3_1_1, na.rm = TRUE),
    Soil_Temperature_se = sd(TS_3_1_1, na.rm = TRUE) / sqrt(sum(!is.na(TS_3_1_1))),
    Air_TemperatureGF_mean = mean(TA_gapfilled, na.rm = TRUE),
    Air_TemperatureGF_se = sd(TA_gapfilled, na.rm = TRUE) / sqrt(sum(!is.na(TA_gapfilled))),
    Soil_TemperatureGF_mean = mean(TS_3_gapfilled, na.rm = TRUE),
    Soil_TemperatureGF_se = sd(TS_3_gapfilled, na.rm = TRUE) / sqrt(sum(!is.na(TS_3_gapfilled))),
    Soil_Moisture_mean = mean(SWC_3_1_1, na.rm = TRUE),
    Soil_Moisture_se = sd(SWC_3_1_1, na.rm = TRUE) / sqrt(sum(!is.na(SWC_3_1_1))),
    VPD_mean = mean(VPD, na.rm = TRUE),
    VPD_se = sd(VPD, na.rm = TRUE) / sqrt(sum(!is.na(VPD))),
    Net_Radiation_mean = mean(NETRAD, na.rm = TRUE),
    Net_Radiation_se = sd(NETRAD, na.rm = TRUE) / sqrt(sum(!is.na(NETRAD))),
    Wind_Speed_mean = mean(WS, na.rm = TRUE),
    Wind_Speed_se = sd(WS, na.rm = TRUE) / sqrt(sum(!is.na(WS))),
    PAR_mean = mean(PPFD_IN, na.rm = TRUE),
    PAR_se = sd(PPFD_IN, na.rm = TRUE) / sqrt(sum(!is.na(PPFD_IN))),
    H_mean = mean(H, na.rm = TRUE),
    H_se = sd(H, na.rm = TRUE) / sqrt(sum(!is.na(H))),
    LE_mean = mean(LE, na.rm = TRUE),
    LE_se = sd(LE, na.rm = TRUE) / sqrt(sum(!is.na(LE))),
    SWC_mean = mean(SWC_3_1_1, na.rm = TRUE),
    SWC_se = sd(SWC_3_1_1, na.rm = TRUE) / sqrt(sum(!is.na(SWC_3_1_1))),
    RH_mean = mean(RH, na.rm = TRUE),
    RH_se = sd(RH, na.rm = TRUE) / sqrt(sum(!is.na(RH))),
    G_mean = mean(G_1_1_1, na.rm = TRUE),
    G_se = sd(G_1_1_1, na.rm = TRUE) / sqrt(sum(!is.na(G_1_1_1))),
    
    .groups = 'drop'
  ) %>%
  # Convert to long format for faceting
  pivot_longer(
    cols = contains("_mean"),
    names_to = "Variable",
    values_to = "Value",
    names_pattern = "(.*)_mean"
  ) %>%
  # Add corresponding standard errors
  mutate(
    SE = case_when(
      Variable == "Air_Temperature" ~ Air_Temperature_se,
      Variable == "Soil_Temperature" ~ Soil_Temperature_se,
      Variable == "Air_TemperatureGF" ~ Air_TemperatureGF_se,
      Variable == "Soil_TemperatureGF" ~ Soil_TemperatureGF_se,
      Variable == "Soil_Moisture" ~ Soil_Moisture_se,
      Variable == "VPD" ~ VPD_se,
      Variable == "Net_Radiation" ~ Net_Radiation_se,
      Variable == "Wind_Speed" ~ Wind_Speed_se,
      Variable == "PAR" ~ PAR_se,
      Variable == "H" ~ H_se,
      Variable == "LE" ~ LE_se,
      Variable == "SWC" ~ SWC_se,
      Variable == "RH" ~ RH_se,
      Variable == "G" ~ G_se
    )
  ) %>%
  # Create proper labels and units for each variable
  mutate(
    Variable_Label = case_when(
      Variable == "Air_Temperature" ~ "Air Temperature (°C)",
      Variable == "Soil_Temperature" ~ "Soil Temperature to 15cm (°C)", 
      Variable == "Air_TemperatureGF" ~ "Air Temperature ERA5-GF  (°C)",
      Variable == "Soil_TemperatureGF" ~ "Soil Temperature to 15cm ERA5-GF (°C)", 
      Variable == "Soil_Moisture" ~ "Soil Moisture (%)",
      Variable == "VPD" ~ "VPD (hPa)",
      Variable == "Net_Radiation" ~ "Net Radiation (W m⁻²)",
      Variable == "Wind_Speed" ~ "Wind Speed (m s⁻¹)",
      Variable == "PAR" ~ "PAR In (μmol m⁻² s⁻¹)",
      Variable == "H" ~ "Sensible Heat Flux (W m⁻²)",
      Variable == "LE" ~ "Latent Heat Flux (W m⁻²)",
      Variable == "SWC" ~ "SWC to 15cm (%)",
      Variable == "RH" ~ "Relative Humidity (%)",
      Variable == "G" ~ "Soil Heat Flux (W m⁻²)",
    ),
    year = as.factor(year)  # Convert year to factor for better color mapping
  ) %>%
  # Remove the individual SE columns we don't need anymore
  select(-ends_with("_se"))

# Create the plot with error bars
monthly_plot <- ggplot(monthly_env_data, aes(x = month, y = Value, color = year, group = year)) +
  geom_line(size = 1.2) +
  geom_point(size = 2) +
  geom_errorbar(aes(ymin = Value - SE, ymax = Value + SE), 
                width = 0.2, alpha = 0.7) +
  facet_wrap(~ Variable_Label, scales = "free_y", ncol = 3, 
             labeller = labeller(Variable_Label = label_wrap_gen(width = 15))) +
  scale_color_manual(
    values = c("2017" = "#1f77b4", "2018" = "#ff7f0e", "2019" = "#2ca02c", 
               "2020" = "#d62728", "2021" = "#9467bd", "2022" = "#8c564b", 
               "2023" = "#e377c2")
  ) +
  theme_bw() +  # Changed to light theme for better label visibility
  theme(
    strip.text = element_text(size = 11, face = "bold"),
    strip.background = element_rect(fill = "gray90"),
    axis.text.x = element_text(angle = 45, hjust = 1, size = 9),
    axis.text.y = element_text(size = 9),
    axis.title = element_text(face = "bold", size = 12),
    legend.title = element_text(face = "bold", size = 12),
    legend.text = element_text(size = 10),
    panel.grid.minor = element_blank(),
    panel.grid.major = element_line(color = "gray90", size = 0.5),
    plot.title = element_text(size = 14, face = "bold", hjust = 0.5)
  ) +
  labs(
    x = "Month",
    y = "",
    color = "Year",
    title = "Monthly Averages of Environmental Variables (2017-2022)"
  )

# Display the plot
print(monthly_plot)


# Alternative version with white background 
monthly_plot_light <- ggplot(monthly_env_data, aes(x = month, y = Value, color = year, group = year)) +
  geom_line(size = 1.2) +
  geom_point(size = 2) +
  facet_wrap(~ Variable_Label, scales = "free_y", ncol = 3) +
  scale_color_manual(
    values = c("2017" = "#1f77b4", "2018" = "#ff7f0e", "2019" = "#2ca02c", 
               "2020" = "#d62728", "2021" = "#9467bd", "2022" = "#8c564b", 
               "2023" = "#e377c2")
  ) +
  theme_bw() +
  theme(
    strip.text = element_text(size = 12, face = "bold"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.title = element_text(face = "bold"),
    legend.title = element_text(face = "bold"),
    panel.grid.minor = element_blank()
  ) +
  labs(
    x = "Month",
    y = "",
    color = "Year",
    title = "Monthly Averages of Environmental Variables (2017- 2022)"
  )


 print(monthly_plot_light)

```
#save figure 
```{r}
 #Save figure 
 
ggsave("C:/Users/kkent/Documents/Github Flux Network/Council_Flux_Analysis_Paper/Council Figures/monthly_MeanMet_vars_plot.png", monthly_plot_light, 
        width = 12, height = 7, dpi = 600)
```


#seasonal delineations - shows start and end date of each season within the year, and # days within each season for that year - Claude streamlined code 
```{r}
create_seasonal_subsets <- function(year_data, year_num) {
  # Create seasonal datasets
  winter <- year_data %>%
    filter(season == "Winter")
  
  growing <- year_data %>%
    filter(season == "Growing Season")
  
  fall <- year_data %>%
    filter(season == "Fall Senescence")
  
  # Print summary information
  cat(paste("\nSeasonal Summary for", year_num, ":\n"))
  cat("------------------------\n")
  
  cat("Winter dates:\n")
  print(range(winter$date))
  cat(paste("Number of winter days:", nrow(winter), "\n\n"))
  
  cat("Growing Season dates:\n")
  print(range(growing$date))
  cat(paste("Number of growing days:", nrow(growing), "\n\n"))
  
  cat("Fall Senescence dates:\n")
  print(range(fall$date))
  cat(paste("Number of fall days:", nrow(fall), "\n\n"))
  
  # Return the datasets as a list
  return(list(
    winter = winter,
    growing = growing,
    fall = fall
  ))
}


# print results for each year 
seasons_2018 <- create_seasonal_subsets(df_avg_2018, 2018)
seasons_2019 <- create_seasonal_subsets(df_avg_2019, 2019)
seasons_2020 <- create_seasonal_subsets(df_avg_2020, 2020)
seasons_2021 <- create_seasonal_subsets(df_avg_2021, 2021)
seasons_2022 <- create_seasonal_subsets(df_avg_2022, 2022)

# Access individual seasonal datasets if needed:
winter_2017 <- seasons_2017$winter
growing_2017 <- seasons_2017$growing
fall_2017 <- seasons_2017$fall


```


#Met data per season - prints summaries for each season within each year with average, min, max (range) --> Claude streamlined code 
```{r}
create_seasonal_subsets <- function(year_data, year_num) {
  # Create seasonal datasets
  winter <- year_data %>%
    filter(season == "Winter")
  
  growing <- year_data %>%
    filter(season == "Growing Season")
  
  fall <- year_data %>%
    filter(season == "Fall Senescence")
  
  # Function to calculate seasonal statistics
  get_season_stats <- function(data) {
    list(
      # Measured Air Temperature statistics
      mean_air_temp = mean(data$TA, na.rm = TRUE),
      max_air_temp = max(data$TA, na.rm = TRUE),
      min_air_temp = min(data$TA, na.rm = TRUE),
      
      # ERA5 Air Temperature statistics
      mean_era5_temp = mean(data$TA_ERA5, na.rm = TRUE),
      max_era5_temp = max(data$TA_ERA5, na.rm = TRUE),
      min_era5_temp = min(data$TA_ERA5, na.rm = TRUE),
      
      # Soil conditions
      mean_soil_temp = mean(data$TS_3_1_1, na.rm = TRUE),
      max_soil_temp = max(data$TS_3_1_1, na.rm = TRUE),
      min_soil_temp = min(data$TS_3_1_1, na.rm = TRUE),
      
      mean_soil_moisture = mean(data$SWC_3_1_1, na.rm = TRUE),
      max_soil_moisture = max(data$SWC_3_1_1, na.rm = TRUE),
      min_soil_moisture = min(data$SWC_3_1_1, na.rm = TRUE),
      
      # Carbon fluxes
      mean_NEE = mean(data$FC_F, na.rm = TRUE),
      mean_CH4 = mean(data$FCH4_F, na.rm = TRUE),
      cumulative_NEE = sum(data$FC_F, na.rm = TRUE),
      cumulative_CH4 = sum(data$FCH4_F, na.rm = TRUE)
    )
  }
  
  # Calculate statistics for each season
  winter_stats <- get_season_stats(winter)
  growing_stats <- get_season_stats(growing)
  fall_stats <- get_season_stats(fall)
  
  # Print summary information
  cat(paste("\nSeasonal Summary for", year_num, ":\n"))
  cat("================================================\n")
  
  for(season_name in c("Winter", "Growing Season", "Fall Senescence")) {
    season_data <- switch(season_name,
                         "Winter" = winter,
                         "Growing Season" = growing,
                         "Fall Senescence" = fall)
    stats <- switch(season_name,
                   "Winter" = winter_stats,
                   "Growing Season" = growing_stats,
                   "Fall Senescence" = fall_stats)
    
    cat(paste("\n", season_name, ":\n"))
    cat("----------------\n")
    cat("Dates:", format(range(season_data$date), "%Y-%m-%d"), "\n")
    cat("Number of days:", nrow(season_data), "\n")
    cat("\nTemperature Conditions:\n")
    cat(sprintf("Measured Air Temperature: %.1f°C (range: %.1f to %.1f°C)\n", 
                stats$mean_air_temp, stats$min_air_temp, stats$max_air_temp))
    cat(sprintf("ERA5 Air Temperature: %.1f°C (range: %.1f to %.1f°C)\n", 
                stats$mean_era5_temp, stats$min_era5_temp, stats$max_era5_temp))
    cat(sprintf("Soil Temperature: %.1f°C (range: %.1f to %.1f°C)\n", 
                stats$mean_soil_temp, stats$min_soil_temp, stats$max_soil_temp))
    
    cat("\nSoil Moisture:\n")
    cat(sprintf("Mean: %.1f %%SWC (range: %.1f to %.1f %%SWC)\n", 
                stats$mean_soil_moisture, stats$min_soil_moisture, stats$max_soil_moisture))
    
    cat("\nCarbon Fluxes:\n")
    cat("\nCarbon Fluxes:\n")
    cat(sprintf("Mean NEE: %.2f µmol/m²/s\n", stats$mean_NEE))
    cat(sprintf("Mean CH4: %.3f nmol/m²/s\n", stats$mean_CH4))
    cat(sprintf("Cumulative NEE: %.1f µmol/m²\n", stats$cumulative_NEE))
    cat(sprintf("Cumulative CH4: %.2f nmol/m²\n", stats$cumulative_CH4))
    cat("\n")
  }
  
  # Return the datasets as a list
  return(list(
    winter = winter,
    growing = growing,
    fall = fall,
    stats = list(
      winter = winter_stats,
      growing = growing_stats,
      fall = fall_stats
    )
  ))
}

# print results 
seasons_2017 <- create_seasonal_subsets(df_avg_2017, 2017)
seasons_2018 <- create_seasonal_subsets(df_avg_2018, 2018)
seasons_2019 <- create_seasonal_subsets(df_avg_2019, 2019)
seasons_2020 <- create_seasonal_subsets(df_avg_2020, 2020)
seasons_2021 <- create_seasonal_subsets(df_avg_2021, 2021)
seasons_2022 <- create_seasonal_subsets(df_avg_2022, 2022)


# Access individual seasonal datasets if needed:
winter_2019 <- seasons_2019$winter
growing_2019 <- seasons_2019$growing
fall_2019 <- seasons_2019$fall



```

#---------------------------------------------

#Coding help from Claude -streamlining annual and seasonal means, comparing measured with gapfilled trends, with figures into one code chunk
```{r}
# Annual Trends Analysis - Complete Visualization Script
# Air Temperature, Soil Temperature, Soil Moisture, and VPD
# Distinguish observed (solid) vs gap-filled (open/transparent) data

library(ggplot2)
library(dplyr)
library(gridExtra)

# ============================================================================
# AIR TEMPERATURE
# ============================================================================

# Calculate annual means for air temperature (exclude 2023)
annual_temp_summary <- df_avg %>%
group_by(winter_year, season) %>%
  summarise(
    # Observed air temp
    TA_mean = mean(TA, na.rm = TRUE),
    TA_se = sd(TA, na.rm = TRUE) / sqrt(sum(!is.na(TA))),
    TA_n = sum(!is.na(TA)),
    
    # Gap-filled air temp  
    TA_gapfilled_mean = mean(TA_gapfilled, na.rm = TRUE),
    TA_gapfilled_se = sd(TA_gapfilled, na.rm = TRUE) / sqrt(sum(!is.na(TA_gapfilled))),
    TA_gapfilled_n = sum(!is.na(TA_gapfilled)),
    
    # Calculate gap-fill percentage
    gapfill_percent = (TA_gapfilled_n - TA_n) / TA_gapfilled_n * 100
  )

# Calculate seasonal means for air temperature
seasonal_temp_summary <- df_avg %>%
  filter(year %in% 2017:2022) %>%
  group_by(year, season) %>%
  summarise(
    # Observed air temp
    TA_mean = mean(TA, na.rm = TRUE),
    TA_se = sd(TA, na.rm = TRUE) / sqrt(sum(!is.na(TA))),
    TA_n = sum(!is.na(TA)),
    
    # Gap-filled air temp
    TA_gapfilled_mean = mean(TA_gapfilled, na.rm = TRUE),
    TA_gapfilled_se = sd(TA_gapfilled, na.rm = TRUE) / sqrt(sum(!is.na(TA_gapfilled))),
    TA_gapfilled_n = sum(!is.na(TA_gapfilled)),
    
    # Calculate gap-fill percentage
    gapfill_percent = (TA_gapfilled_n - TA_n) / TA_gapfilled_n * 100,
    .groups = 'drop'
  )

# Plot 1: Annual air temperature trends
p1 <- ggplot(annual_temp_summary) +
  # Gap-filled data (open circles, transparent)
  geom_point(aes(x = year, y = TA_gapfilled_mean), 
             shape = 1, size = 3, color = "blue", alpha = 0.7) +
  geom_errorbar(aes(x = year, ymin = TA_gapfilled_mean - TA_gapfilled_se, 
                    ymax = TA_gapfilled_mean + TA_gapfilled_se),
                width = 0.1, color = "blue", alpha = 0.7) +
  
  # Observed data (solid circles)
  geom_point(aes(x = year, y = TA_mean), 
             shape = 16, size = 3, color = "red") +
  geom_errorbar(aes(x = year, ymin = TA_mean - TA_se, 
                    ymax = TA_mean + TA_se),
                width = 0.1, color = "red") +
  
  # Add trend lines
  geom_smooth(aes(x = year, y = TA_gapfilled_mean), 
              method = "lm", se = TRUE, color = "blue", alpha = 0.3) +
  geom_smooth(aes(x = year, y = TA_mean), 
              method = "lm", se = TRUE, color = "red", alpha = 0.3) +
  
  labs(title = "Annual Air Temperature Trends (2017-2022)",
       subtitle = "Red = Observed data, Blue = Gap-filled data",
       x = "Year", 
       y = "Air Temperature (°C)") +
  theme_bw() +
  scale_x_continuous(breaks = 2017:2022)

# Plot 2: Seasonal air temperature trends (faceted)
p2 <- ggplot(seasonal_temp_summary) +
  # Gap-filled data (open circles)
  geom_point(aes(x = year, y = TA_gapfilled_mean), 
             shape = 1, size = 2.5, color = "blue", alpha = 0.7) +
  geom_errorbar(aes(x = year, ymin = TA_gapfilled_mean - TA_gapfilled_se, 
                    ymax = TA_gapfilled_mean + TA_gapfilled_se),
                width = 0.1, color = "blue", alpha = 0.7) +
  
  # Observed data (solid circles)
  geom_point(aes(x = year, y = TA_mean), 
             shape = 16, size = 2.5, color = "red") +
  geom_errorbar(aes(x = year, ymin = TA_mean - TA_se, 
                    ymax = TA_mean + TA_se),
                width = 0.1, color = "red") +
  
  # Add trend lines by season
  geom_smooth(aes(x = year, y = TA_gapfilled_mean), 
              method = "lm", se = FALSE, color = "blue", alpha = 0.7, size = 0.8) +
  geom_smooth(aes(x = year, y = TA_mean), 
              method = "lm", se = FALSE, color = "red", alpha = 0.7, size = 0.8) +
  
  facet_wrap(~ season, scales = "free_y", ncol = 3) +
  
  labs(title = "Seasonal Air Temperature Trends by Season (2017-2022)",
       subtitle = "Red = Observed data, Blue = Gap-filled data",
       x = "Year", 
       y = "Air Temperature (°C)") +
  theme_bw() +
  scale_x_continuous(breaks = c(2017, 2019, 2021)) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# ============================================================================
# SOIL TEMPERATURE
# ============================================================================

# Calculate annual means for soil temperature
annual_soil_temp_summary <- df_avg %>%
  filter(year %in% 2017:2022) %>%
  group_by(year) %>%
  summarise(
    # Observed soil temp (TS_3_1_1)
    TS_3_mean = mean(TS_3_1_1, na.rm = TRUE),
    TS_3_se = sd(TS_3_1_1, na.rm = TRUE) / sqrt(sum(!is.na(TS_3_1_1))),
    TS_3_n = sum(!is.na(TS_3_1_1)),
    
    # Gap-filled soil temp
    TS_3_gapfilled_mean = mean(TS_3_gapfilled, na.rm = TRUE),
    TS_3_gapfilled_se = sd(TS_3_gapfilled, na.rm = TRUE) / sqrt(sum(!is.na(TS_3_gapfilled))),
    TS_3_gapfilled_n = sum(!is.na(TS_3_gapfilled)),
    
    # Calculate gap-fill percentage
    gapfill_percent = (TS_3_gapfilled_n - TS_3_n) / TS_3_gapfilled_n * 100
  )

# Calculate seasonal means for soil temperature
seasonal_soil_temp_summary <- df_avg %>%
  filter(year %in% 2017:2022) %>%
  group_by(year, season) %>%
  summarise(
    # Observed soil temp
    TS_3_mean = mean(TS_3_1_1, na.rm = TRUE),
    TS_3_se = sd(TS_3_1_1, na.rm = TRUE) / sqrt(sum(!is.na(TS_3_1_1))),
    TS_3_n = sum(!is.na(TS_3_1_1)),
    
    # Gap-filled soil temp
    TS_3_gapfilled_mean = mean(TS_3_gapfilled, na.rm = TRUE),
    TS_3_gapfilled_se = sd(TS_3_gapfilled, na.rm = TRUE) / sqrt(sum(!is.na(TS_3_gapfilled))),
    TS_3_gapfilled_n = sum(!is.na(TS_3_gapfilled)),
    
    # Calculate gap-fill percentage
    gapfill_percent = (TS_3_gapfilled_n - TS_3_n) / TS_3_gapfilled_n * 100,
    .groups = 'drop'
  )

# Plot 3: Annual soil temperature trends
p3 <- ggplot(annual_soil_temp_summary) +
  # Gap-filled data (open circles, transparent)
  geom_point(aes(x = year, y = TS_3_gapfilled_mean), 
             shape = 1, size = 3, color = "darkgreen", alpha = 0.7) +
  geom_errorbar(aes(x = year, ymin = TS_3_gapfilled_mean - TS_3_gapfilled_se, 
                    ymax = TS_3_gapfilled_mean + TS_3_gapfilled_se),
                width = 0.1, color = "darkgreen", alpha = 0.7) +
  
  # Observed data (solid circles)
  geom_point(aes(x = year, y = TS_3_mean), 
             shape = 16, size = 3, color = "orange") +
  geom_errorbar(aes(x = year, ymin = TS_3_mean - TS_3_se, 
                    ymax = TS_3_mean + TS_3_se),
                width = 0.1, color = "orange") +
  
  # Add trend lines
  geom_smooth(aes(x = year, y = TS_3_gapfilled_mean), 
              method = "lm", se = TRUE, color = "darkgreen", alpha = 0.3) +
  geom_smooth(aes(x = year, y = TS_3_mean), 
              method = "lm", se = TRUE, color = "orange", alpha = 0.3) +
  
  labs(title = "Annual Soil Temperature Trends (2017-2022)",
       subtitle = "Orange = Observed data, Green = Gap-filled data",
       x = "Year", 
       y = "Soil Temperature (°C)") +
  theme_bw() +
  scale_x_continuous(breaks = 2017:2022)

# Plot 4: Seasonal soil temperature trends (faceted)
p4 <- ggplot(seasonal_soil_temp_summary) +
  # Gap-filled data (open circles)
  geom_point(aes(x = year, y = TS_3_gapfilled_mean), 
             shape = 1, size = 2.5, color = "darkgreen", alpha = 0.7) +
  geom_errorbar(aes(x = year, ymin = TS_3_gapfilled_mean - TS_3_gapfilled_se, 
                    ymax = TS_3_gapfilled_mean + TS_3_gapfilled_se),
                width = 0.1, color = "darkgreen", alpha = 0.7) +
  
  # Observed data (solid circles)
  geom_point(aes(x = year, y = TS_3_mean), 
             shape = 16, size = 2.5, color = "orange") +
  geom_errorbar(aes(x = year, ymin = TS_3_mean - TS_3_se, 
                    ymax = TS_3_mean + TS_3_se),
                width = 0.1, color = "orange") +
  
  # Add trend lines by season
  geom_smooth(aes(x = year, y = TS_3_gapfilled_mean), 
              method = "lm", se = FALSE, color = "darkgreen", alpha = 0.7, size = 0.8) +
  geom_smooth(aes(x = year, y = TS_3_mean), 
              method = "lm", se = FALSE, color = "orange", alpha = 0.7, size = 0.8) +
  
  facet_wrap(~ season, scales = "free_y", ncol = 3) +
  
  labs(title = "Seasonal Soil Temperature Trends by Season (2017-2022)",
       subtitle = "Orange = Observed data, Green = Gap-filled data",
       x = "Year", 
       y = "Soil Temperature (°C)") +
  theme_bw() +
  scale_x_continuous(breaks = c(2017, 2019, 2021)) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# ============================================================================
# SOIL MOISTURE AND VPD
# ============================================================================

# Calculate annual means for soil moisture and VPD
annual_other_summary <- df_avg %>%
  filter(year %in% 2017:2022) %>%
  group_by(year) %>%
  summarise(
    # Soil moisture (SWC_3_1_1)
    SWC_3_mean = mean(SWC_3_1_1, na.rm = TRUE),
    SWC_3_se = sd(SWC_3_1_1, na.rm = TRUE) / sqrt(sum(!is.na(SWC_3_1_1))),
    SWC_3_n = sum(!is.na(SWC_3_1_1)),
    
    # VPD
    VPD_mean = mean(VPD, na.rm = TRUE),
    VPD_se = sd(VPD, na.rm = TRUE) / sqrt(sum(!is.na(VPD))),
    VPD_n = sum(!is.na(VPD))
  )

# Calculate seasonal means
seasonal_other_summary <- df_avg %>%
  filter(year %in% 2017:2022) %>%
  group_by(year, season) %>%
  summarise(
    # Soil moisture
    SWC_3_mean = mean(SWC_3_1_1, na.rm = TRUE),
    SWC_3_se = sd(SWC_3_1_1, na.rm = TRUE) / sqrt(sum(!is.na(SWC_3_1_1))),
    SWC_3_n = sum(!is.na(SWC_3_1_1)),
    
    # VPD
    VPD_mean = mean(VPD, na.rm = TRUE),
    VPD_se = sd(VPD, na.rm = TRUE) / sqrt(sum(!is.na(VPD))),
    VPD_n = sum(!is.na(VPD)),
    .groups = 'drop'
  )

# Plot 5: Annual soil moisture trends
p5 <- ggplot(annual_other_summary) +
  geom_point(aes(x = year, y = SWC_3_mean), 
             shape = 16, size = 3, color = "brown") +
  geom_errorbar(aes(x = year, ymin = SWC_3_mean - SWC_3_se, 
                    ymax = SWC_3_mean + SWC_3_se),
                width = 0.1, color = "brown") +
  
  # Add trend line
  geom_smooth(aes(x = year, y = SWC_3_mean), 
              method = "lm", se = TRUE, color = "brown", alpha = 0.3) +
  
  labs(title = "Annual Soil Moisture Trends (2017-2022)",
       x = "Year", 
       y = "Soil Water Content (%)") +
  theme_bw() +
  scale_x_continuous(breaks = 2017:2022)

# Plot 6: Seasonal soil moisture trends
p6 <- ggplot(seasonal_other_summary) +
  geom_point(aes(x = year, y = SWC_3_mean), 
             shape = 16, size = 2.5, color = "brown") +
  geom_errorbar(aes(x = year, ymin = SWC_3_mean - SWC_3_se, 
                    ymax = SWC_3_mean + SWC_3_se),
                width = 0.1, color = "brown") +
  
  # Add trend lines by season
  geom_smooth(aes(x = year, y = SWC_3_mean), 
              method = "lm", se = FALSE, color = "brown", alpha = 0.7, size = 0.8) +
  
  facet_wrap(~ season, scales = "free_y", ncol = 3) +
  
  labs(title = "Seasonal Soil Moisture Trends by Season (2017-2022)",
       x = "Year", 
       y = "Soil Water Content (%)") +
  theme_bw() +
  scale_x_continuous(breaks = c(2017, 2019, 2021)) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# Plot 7: Annual VPD trends
p7 <- ggplot(annual_other_summary) +
  geom_point(aes(x = year, y = VPD_mean), 
             shape = 16, size = 3, color = "purple") +
  geom_errorbar(aes(x = year, ymin = VPD_mean - VPD_se, 
                    ymax = VPD_mean + VPD_se),
                width = 0.1, color = "purple") +
  
  # Add trend line
  geom_smooth(aes(x = year, y = VPD_mean), 
              method = "lm", se = TRUE, color = "purple", alpha = 0.3) +
  
  labs(title = "Annual Vapor Pressure Deficit Trends (2017-2022)",
       x = "Year", 
       y = "VPD (hPa)") +
  theme_bw() +
  scale_x_continuous(breaks = 2017:2022)

# Plot 8: Seasonal VPD trends
p8 <- ggplot(seasonal_other_summary) +
  geom_point(aes(x = year, y = VPD_mean), 
             shape = 16, size = 2.5, color = "purple") +
  geom_errorbar(aes(x = year, ymin = VPD_mean - VPD_se, 
                    ymax = VPD_mean + VPD_se),
                width = 0.1, color = "purple") +
  
  # Add trend lines by season
  geom_smooth(aes(x = year, y = VPD_mean), 
              method = "lm", se = FALSE, color = "purple", alpha = 0.7, size = 0.8) +
  
  facet_wrap(~ season, scales = "free_y", ncol = 3) +
  
  labs(title = "Seasonal VPD Trends by Season (2017-2022)",
       x = "Year", 
       y = "VPD (hPa)") +
  theme_bw() +
  scale_x_continuous(breaks = c(2017, 2019, 2021)) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# ============================================================================
# DISPLAY ALL PLOTS
# ============================================================================

# Display plots
print(p1)  # Annual air temp
print(p2)  # Seasonal air temp
print(p3)  # Annual soil temp
print(p4)  # Seasonal soil temp
print(p5)  # Annual soil moisture
print(p6)  # Seasonal soil moisture
print(p7)  # Annual VPD
print(p8)  # Seasonal VPD

# ============================================================================
# PRINT SUMMARY STATISTICS
# ============================================================================

cat("\n=== AIR TEMPERATURE SUMMARY ===\n")
cat("\nAnnual Air Temperature:\n")
print(annual_temp_summary)
cat("\nSeasonal Air Temperature:\n")
print(seasonal_temp_summary)

cat("\n=== SOIL TEMPERATURE SUMMARY ===\n")
cat("\nAnnual Soil Temperature:\n")
print(annual_soil_temp_summary)
cat("\nSeasonal Soil Temperature:\n")
print(seasonal_soil_temp_summary)

cat("\n=== SOIL MOISTURE AND VPD SUMMARY ===\n")
cat("\nAnnual Summary:\n")
print(annual_other_summary)
cat("\nSeasonal Summary:\n")
print(seasonal_other_summary)

  
```
 

#Seasonal averages for each year, facetwrapped by season 

##prepare seasonal summary dataset by year, set color for each year for consistency across figures 
```{r}
# Seasonal Trends Faceted by Season - All Variables

library(ggplot2)
library(dplyr)

# Prepare seasonal summaries for all variables (2017-2022)
seasonal_summary_all <- df_avg %>%
 # filter(winter_year >= 2017 & winter_year <= 2022) %>%
group_by(winter_year, season) %>%
  summarise(
    # ERA5 GF Air temperature (gap-filled)
    TA_gapfilled_mean = mean(TA_gapfilled, na.rm = TRUE),
    TA_gapfilled_se = sd(TA_gapfilled, na.rm = TRUE) / sqrt(sum(!is.na(TA_gapfilled))),
    
    # measured Air temperature 
    TA_mean = mean(TA, na.rm = TRUE),
    TA_se = sd(TA, na.rm = TRUE) / sqrt(sum(!is.na(TA))),
    
    # ERA5 GF Soil temperature (gap-filled only)
    TS_3_gapfilled_mean = mean(TS_3_gapfilled, na.rm = TRUE),
    TS_3_gapfilled_se = sd(TS_3_gapfilled, na.rm = TRUE) / sqrt(sum(!is.na(TS_3_gapfilled))),
    
    # Measured Soil temperature 
    TS_3_mean = mean(TS_3_1_1, na.rm = TRUE),
    TS_3_se = sd(TS_3_1_1, na.rm = TRUE) / sqrt(sum(!is.na(TS_3_1_1))),
    
    # Soil moisture
    # SWC_3_mean = mean(SWC_3_1_1, na.rm = TRUE),
    # SWC_3_se = sd(SWC_3_1_1, na.rm = TRUE) / sqrt(sum(!is.na(SWC_3_1_1))),
    
    # Soil moisture - unfrozen, excluding winter and when soil temp is <= 2 deg
    SWC_3_nf_mean = mean(SWC_3_nf, na.rm = TRUE),
    SWC_3_nf_se = sd(SWC_3_nf, na.rm = TRUE) / sqrt(sum(!is.na(SWC_3_nf))),
    
    # VPD
    VPD_mean = mean(VPD, na.rm = TRUE),
    VPD_se = sd(VPD, na.rm = TRUE) / sqrt(sum(!is.na(VPD))),
    
    # RH - relative humidity 
    RH_mean = mean(RH, na.rm = TRUE),
    RH_se = sd(RH, na.rm = TRUE) / sqrt(sum(!is.na(RH))),
    
    # Sensible heat
    H_mean = mean(H, na.rm = TRUE),
    H_se = sd(H, na.rm = TRUE) / sqrt(sum(!is.na(H))),
    
    # Latent heat
    LE_mean = mean(LE, na.rm = TRUE),
    LE_se = sd(LE, na.rm = TRUE) / sqrt(sum(!is.na(LE))),
    
    # Ground heat
    G_mean = mean(G_1_1_1, na.rm = TRUE),
    G_se = sd(G_1_1_1, na.rm = TRUE) / sqrt(sum(!is.na(G_1_1_1))),
    
    
    
    .groups = 'drop'
  )

# Define consistent year colors
winteryear_colors <- c("2017" = "#E41A1C",  # Red
                 "2018" = "#377EB8",  # Blue
                 "2019" = "#4DAF4A",  # Green
                 "2020" = "#984EA3",  # Purple
                 "2021" = "#FF7F00",  # Orange
                 "2022" = "#A65628")  # Brown

# Convert year to factor for consistent color mapping
seasonal_summary_all$winteryear_factor <- as.factor(seasonal_summary_all$winter_year)
```

# %gapfill of other met variables 
```{r}
gapfill_summary <- df_avg %>%
  # Just group directly by winter_year (which already exists!)
  group_by(winter_year, season) %>%
  summarise(
    # Total days 
    total_days = n(),
    
  #SWC_nf (SWC above 2degC)
    SWC_nf_measured = sum(!is.na(SWC_3_nf)),
    SWC_nf_missing = sum(is.na(SWC_3_nf)),
    SWC_nf_pct_missing = round((SWC_nf_missing / total_days) * 100, 1),
    SWC_nf_pct_coverage = round((SWC_nf_measured / total_days) * 100, 1),
  
    #VPD
    VPD_measured = sum(!is.na(VPD)),
    VPD_missing = sum(is.na(VPD)),
    VPD_pct_missing = round((VPD_missing / total_days) * 100, 1),
    VPD_pct_coverage = round((VPD_measured / total_days) * 100, 1),
  
      #RH
    RH_measured = sum(!is.na(RH)),
    RH_missing = sum(is.na(RH)),
    RH_pct_missing = round((RH_missing / total_days) * 100, 1),
    RH_pct_coverage = round((RH_measured / total_days) * 100, 1),
  
     #H
    H_measured = sum(!is.na(H)),
    H_missing = sum(is.na(H)),
    H_pct_missing = round((H_missing / total_days) * 100, 1),
    H_pct_coverage = round((H_measured / total_days) * 100, 1),
  
     #LE
    LE_measured = sum(!is.na(LE)),
    LE_missing = sum(is.na(LE)),
    LE_pct_missing = round((LE_missing / total_days) * 100, 1),
    LE_pct_coverage = round((LE_measured / total_days) * 100, 1),
  
      #G
    G_1_1_1_measured = sum(!is.na(G_1_1_1)),
    G_1_1_1_missing = sum(is.na(G_1_1_1)),
    G_1_1_1_pct_missing = round((G_1_1_1_missing / total_days) * 100, 1),
    G_1_1_1_pct_coverage = round((G_1_1_1_measured / total_days) * 100, 1),
    
    
    
    .groups = "drop"
  ) 


# Display summary
print(gapfill_summary)

#only % coverage / % missing 
gapfill_summary2 <- gapfill_summary %>%
  select(
    winter_year,
         season,
         total_days,
        # ends_with("pct_missing"), 
         ends_with("pct_coverage")
  )

gapfill_summary2


#full summary  
write_xlsx(gapfill_summary, "C:/Users/kkent/Documents/Github Flux Network/Council_Flux_Analysis_Paper/Council Figures/winteryear_met_vars_data_coverage.xlsx")

#full summary  
write_xlsx(gapfill_summary2, "C:/Users/kkent/Documents/Github Flux Network/Council_Flux_Analysis_Paper/Council Figures/winteryear_met_vars_gapfill_pct.xlsx")

```


#Make formatted table of seasonal means and % coverage of other met variables 
```{r}
library(tidyverse)
library(knitr)
library(kableExtra)

# ============================================================================
# COMBINE SEASONAL MEANS WITH DATA COVERAGE
# ============================================================================

# Join the two datasets
combined_table <- seasonal_summary_all %>%
  select(-starts_with("TA"), -starts_with("TS_3")) %>%
  filter(winter_year != "2016") %>%
  left_join(gapfill_summary2, by = c("winter_year", "season")) %>%
  # Create formatted columns: "mean ± SE (coverage%)"
  mutate(

    # Soil Moisture (non-frozen)
    `SWC_3_nf` = sprintf("%.2f ± %.2f (%.1f%%)", 
                         SWC_3_nf_mean, SWC_3_nf_se, SWC_nf_pct_coverage),
    
    # VPD
    `VPD` = sprintf("%.2f ± %.2f (%.1f%%)", 
                    VPD_mean, VPD_se, VPD_pct_coverage),
    
    # Relative Humidity
    `RH` = sprintf("%.2f ± %.2f (%.1f%%)", 
                   RH_mean, RH_se, RH_pct_coverage),
    
    # Sensible Heat
    `H` = sprintf("%.2f ± %.2f (%.1f%%)", 
                  H_mean, H_se, H_pct_coverage),
    
    # Latent Heat
    `LE` = sprintf("%.2f ± %.2f (%.1f%%)", 
                   LE_mean, LE_se, LE_pct_coverage),
    
    # Ground Heat Flux
    `G` = sprintf("%.2f ± %.2f (%.1f%%)", 
                  G_mean, G_se, G_1_1_1_pct_coverage)
  ) %>%
  # Select only the formatted columns
  select(winter_year, season, total_days,
                  `SWC_3_nf`, `VPD`, `RH`, `H`, `LE`, `G`)

# View the table
print(combined_table)


# Rename columns for publication
# pub_table <- combined_table %>%
#   rename(
#     `Year` = winter_year,
#     `Season` = season,
#     `Days` = total_days,
#     `Air Temp GF (°C)` = TA_gapfilled,
#     `Air Temp Meas (°C)` = TA,
#     `Soil Temp GF (°C)` = TS_3_gapfilled,
#     `Soil Temp Meas (°C)` = TS_3,
#     `Soil Moisture (%)` = SWC_3_nf,
#     `VPD (hPa)` = VPD,
#     `RH (%)` = RH,
#     `H (W/m²)` = H,
#     `LE (W/m²)` = LE,
#     `G (W/m²)` = G
#   )


```

#save table of mean met vars with % data coverage
```{r}
# Save to Excel
write_xlsx(combined_table, "C:/Users/kkent/Documents/Github Flux Network/Council_Flux_Analysis_Paper/Council Figures/winteryear_met_var_means_pct_coverage_formatted.xlsx")
```




#Plots

#### has orig SWC 
```{r}
# ============================================================================
# Plot 1: Air Temperature by Season (Gap-filled only)
# ============================================================================

p_TA <- ggplot(seasonal_summary_all %>%
                 filter(winter_year >= 2017 & winter_year <= 2022)) +
  geom_hline(yintercept = 0, color = "black", linewidth = 0.5) +
  
  geom_point(aes(x = winter_year, y = TA_gapfilled_mean, color = winteryear_factor, group = winter_year), 
             size = 3) +
  geom_errorbar(aes(x = winter_year, ymin = TA_gapfilled_mean - TA_gapfilled_se, 
                    ymax = TA_gapfilled_mean + TA_gapfilled_se, color = winteryear_factor),
                width = 0.2) +
  
  geom_smooth(aes(x = winter_year, y = TA_gapfilled_mean), 
              method = "lm", se = TRUE, color = "black", alpha = 0.2, linewidth = 0.8) +
  
  facet_wrap(~ season, ncol = 3) +
  
  scale_color_manual(values = winteryear_colors) +
  #scale_x_continuous(breaks = 2017:2022) +

  
  labs(title = "Mean Seasonal Air Temperature Trends by Season (2017-2022)",
       x = "Year", 
       y = "Air Temperature (°C)") +
  theme_bw() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    axis.title.x = element_text(face = "bold", size = 12),
    axis.title.y = element_text(face = "bold", size = 12),
    axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"),
    axis.text.y = element_text(face = "bold"),
    strip.text = element_text(face = "bold", size = 11),
    legend.position = "none"
  )

p_TA
# ============================================================================
# Plot 2: Soil Temperature by Season (Gap-filled only)
# ============================================================================

p_TS <- ggplot(seasonal_summary_all %>%
                   filter(winter_year >= 2017 & winter_year <= 2022)) +
  geom_hline(yintercept = 0, color = "black", linewidth = 0.5) +
  
  geom_point(aes(x = winter_year, y = TS_3_gapfilled_mean, color = winteryear_factor, group = winter_year), 
             size = 3) +
  geom_errorbar(aes(x = winter_year, ymin = TS_3_gapfilled_mean - TS_3_gapfilled_se, 
                    ymax = TS_3_gapfilled_mean + TS_3_gapfilled_se, color = winteryear_factor),
                width = 0.2) +
  
  geom_smooth(aes(x = winter_year, y = TS_3_gapfilled_mean), 
              method = "lm", se = TRUE, color = "black", alpha = 0.2, linewidth = 0.8) +
  
  facet_wrap(~ season, ncol = 3) +
  
  scale_color_manual(values =  winteryear_colors) +
  scale_x_continuous(breaks = 2017:2022) +
  
  labs(title = "Mean Seasonal Soil Temperature Trends by Season (2017-2022)",
       x = "Year", 
       y = "Soil Temperature (°C)") +
  theme_bw() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    axis.title.x = element_text(face = "bold", size = 12),
    axis.title.y = element_text(face = "bold", size = 12),
    axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"),
    axis.text.y = element_text(face = "bold"),
    strip.text = element_text(face = "bold", size = 11),
    legend.position = "none"
  )

# ============================================================================
# Plot 3: Soil Moisture by Season
# ============================================================================

p_SWC <- ggplot(seasonal_summary_all %>%
                    filter(winter_year >= 2017 & winter_year <= 2022)) +
  geom_hline(yintercept = 0, color = "black", linewidth = 0.5) +
  
  geom_point(aes(x = winter_year, y = SWC_3_mean, color = winteryear_factor, group = winter_year), 
             size = 3) +
  geom_errorbar(aes(x = winter_year, ymin = SWC_3_mean - SWC_3_se, 
                    ymax = SWC_3_mean + SWC_3_se, color = winteryear_factor),
                width = 0.2) +
  
  geom_smooth(aes(x = winter_year, y = SWC_3_mean), 
              method = "lm", se = TRUE, color = "black", alpha = 0.2, linewidth = 0.8) +
  
  facet_wrap(~ season, ncol = 3) +
  
  scale_color_manual(values =  winteryear_colors) +
  scale_x_continuous(breaks = 2017:2022) +
  
  labs(title = "Mean Seasonal Soil Moisture Trends by Season (2017-2022)",
       x = "Year", 
       y = "Soil Water Content (%)") +
  theme_bw() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    axis.title.x = element_text(face = "bold", size = 12),
    axis.title.y = element_text(face = "bold", size = 12),
    axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"),
    axis.text.y = element_text(face = "bold"),
    strip.text = element_text(face = "bold", size = 11),
    legend.position = "none"
  )

# ============================================================================
# Plot 4: VPD by Season
# ============================================================================

p_VPD <- ggplot(seasonal_summary_all %>%
                   filter(winter_year >= 2017 & winter_year <= 2022)) +
  geom_hline(yintercept = 0, color = "black", linewidth = 0.5) +
  
  geom_point(aes(x = winter_year, y = VPD_mean, color = winteryear_factor, group = winter_year), 
             size = 3) +
  geom_errorbar(aes(x = winter_year, ymin = VPD_mean - VPD_se, 
                    ymax = VPD_mean + VPD_se, color = winteryear_factor),
                width = 0.2) +
  
  geom_smooth(aes(x = winter_year, y = VPD_mean), 
              method = "lm", se = TRUE, color = "black", alpha = 0.2, linewidth = 0.8) +
  
  facet_wrap(~ season, ncol = 3) +
  
  scale_color_manual(values =  winteryear_colors) +
  scale_x_continuous(breaks = 2017:2022) +
  
  labs(title = "Mean Seasonal VPD Trends by Season (2017-2022)",
       x = "Year", 
       y = "VPD (hPa)") +
  theme_bw() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    axis.title.x = element_text(face = "bold", size = 12),
    axis.title.y = element_text(face = "bold", size = 12),
    axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"),
    axis.text.y = element_text(face = "bold"),
    strip.text = element_text(face = "bold", size = 11),
    legend.position = "none"
  )


# ============================================================================
# Plot 5: RH by Season
# ============================================================================

p_RH <- ggplot(seasonal_summary_all %>%
                  filter(winter_year >= 2017 & winter_year <= 2022)) +
  geom_hline(yintercept = 0, color = "black", linewidth = 0.5) +
  
  geom_point(aes(x = winter_year, y = RH_mean, color = winteryear_factor, group = winter_year), 
             size = 3) +
  geom_errorbar(aes(x = winter_year, ymin = RH_mean - RH_se, 
                    ymax = RH_mean + RH_se, color = winteryear_factor),
                width = 0.2) +
  
  geom_smooth(aes(x = winter_year, y = RH_mean), 
              method = "lm", se = TRUE, color = "black", alpha = 0.2, linewidth = 0.8) +
  
  facet_wrap(~ season, ncol = 3) +
  
  scale_color_manual(values =  winteryear_colors) +
  scale_x_continuous(breaks = 2017:2022) +
  
  labs(title = "Mean Seasonal RH Trends by Season (2017-2022)",
       x = "Year", 
       y = "RH (%)") +
  theme_bw() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    axis.title.x = element_text(face = "bold", size = 12),
    axis.title.y = element_text(face = "bold", size = 12),
    axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"),
    axis.text.y = element_text(face = "bold"),
    strip.text = element_text(face = "bold", size = 11),
    legend.position = "none"
  )

# ============================================================================
# Plot 6: Sensible Heat (H) by Season
# ============================================================================

p_H <- ggplot(seasonal_summary_all %>%
                 filter(winter_year >= 2017 & winter_year <= 2022)) +
  geom_hline(yintercept = 0, color = "black", linewidth = 0.5) +
  
  geom_point(aes(x = winter_year, y = H_mean, color = winteryear_factor, group = winter_year), 
             size = 3) +
  geom_errorbar(aes(x = winter_year, ymin = H_mean - H_se, 
                    ymax = H_mean + H_se, color = winteryear_factor),
                width = 0.2) +
  
  geom_smooth(aes(x = winter_year, y = H_mean), 
              method = "lm", se = TRUE, color = "black", alpha = 0.2, linewidth = 0.8) +
  
  facet_wrap(~ season, ncol = 3) +
  
  scale_color_manual(values =  winteryear_colors) +
  scale_x_continuous(breaks = 2017:2022) +
  
  labs(title = "Mean Seasonal Sensible Heat Flux Trends by Season (2017-2022)",
       x = "Year", 
       y = "H (W/m²)") +
  theme_bw() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    axis.title.x = element_text(face = "bold", size = 12),
    axis.title.y = element_text(face = "bold", size = 12),
    axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"),
    axis.text.y = element_text(face = "bold"),
    strip.text = element_text(face = "bold", size = 11),
    legend.position = "none"
  )

# ============================================================================
# Plot 7: Latent Heat (LE) by Season
# ============================================================================

p_LE <- ggplot(seasonal_summary_all %>%
                  filter(winter_year >= 2017 & winter_year <= 2022)) +
  geom_hline(yintercept = 0, color = "black", linewidth = 0.5) +
  
  geom_point(aes(x = winter_year, y = LE_mean, color = winteryear_factor, group = winter_year), 
             size = 3) +
  geom_errorbar(aes(x = winter_year, ymin = LE_mean - LE_se, 
                    ymax = LE_mean + LE_se, color = winteryear_factor),
                width = 0.2) +
  
  geom_smooth(aes(x = winter_year, y = LE_mean), 
              method = "lm", se = TRUE, color = "black", alpha = 0.2, linewidth = 0.8) +
  
  facet_wrap(~ season, ncol = 3) +
  
  scale_color_manual(values =  winteryear_colors) +
  scale_x_continuous(breaks = 2017:2022) +
  
  labs(title = "Mean Seasonal Latent Heat Flux Trends by Season (2017-2022)",
       x = "Year", 
       y = "LE (W/m²)") +
  theme_bw() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    axis.title.x = element_text(face = "bold", size = 12),
    axis.title.y = element_text(face = "bold", size = 12),
    axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"),
    axis.text.y = element_text(face = "bold"),
    strip.text = element_text(face = "bold", size = 11),
    legend.position = "none"
  )


# ============================================================================
# Plot 8: Ground Heat Flux (G) by Season
# ============================================================================

p_G <- ggplot(seasonal_summary_all %>%
                 filter(winter_year >= 2017 & winter_year <= 2022)) +
  geom_hline(yintercept = 0, color = "black", linewidth = 0.5) +
  
  geom_point(aes(x = winter_year, y = G_mean, color = winteryear_factor, group = winter_year), 
             size = 3) +
  geom_errorbar(aes(x = winter_year, ymin = G_mean - G_se, 
                    ymax = G_mean + G_se, color = winteryear_factor),
                width = 0.2) +
  
  geom_smooth(aes(x = winter_year, y = G_mean), 
              method = "lm", se = TRUE, color = "black", alpha = 0.2, linewidth = 0.8) +
  
  facet_wrap(~ season, ncol = 3) +
  
  scale_color_manual(values =  winteryear_colors) +
  scale_x_continuous(breaks = 2017:2022) +
  
  labs(title = "Mean Seasonal Ground Heat Flux Trends by Season (2017-2022)",
       x = "Year", 
       y = "G (W/m²)") +
  theme_bw() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    axis.title.x = element_text(face = "bold", size = 12),
    axis.title.y = element_text(face = "bold", size = 12),
    axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"),
    axis.text.y = element_text(face = "bold"),
    strip.text = element_text(face = "bold", size = 11),
    legend.position = "none"
  )
# ============================================================================
# DISPLAY ALL PLOTS
# ============================================================================

print(p_TA)
print(p_TS)
print(p_SWC)
print(p_VPD)
print(p_RH)
print(p_H)
print(p_LE)
print(p_G)
```


#Adj figure to take out the trendline and trendline SE-shading 

```{r}
# First, set the factor levels for season to control facet order for all the plots
seasonal_summary_all <- seasonal_summary_all %>%
  mutate(season = factor(season, levels = c("Growing Season", "Fall Senescence", "Winter")))

# Create custom labels for Winter
winter_labels <- c("2017-2018", "2018-2019", "2019-2020", "2020-2021", "2021-2022", "2022-2023")

#Have to build the different labels into the dataset for facet_wrapping 
# For Winter: show year ranges, for others: show just the year
# seasonal_summary_plot <- seasonal_summary_all %>%
#   filter(winter_year >= 2017 & winter_year <= 2022) %>%
#   mutate(
#     x_label = case_when(
#       season == "Winter" ~ paste0(winter_year, "-", winter_year + 1),
#       TRUE ~ as.character(winter_year)
#     )
#   )



#allows you to apply custom axis labels to different panels within the facet wrap directly within ggplot --> need to set scales = "free_x" in facet_wrap for this to work 
library(ggh4x) 


```


#### with SWC_3_nf 
```{r}
# Seasonal Trends Faceted by Season - All Variables

# ============================================================================
# Plot 1: Air Temperature by Season (ERA5 Gap-filled)
# ============================================================================

p_TA <- ggplot(seasonal_summary_all %>%
                 filter(winter_year >= 2017 & winter_year <= 2022)) +
  geom_hline(yintercept = 0, color = "black", linewidth = 0.5) +
  
  geom_point(aes(x = winter_year, y = TA_gapfilled_mean, color = winteryear_factor, group = winter_year), 
             size = 3) +
  geom_errorbar(aes(x = winter_year, ymin = TA_gapfilled_mean - TA_gapfilled_se, 
                    ymax = TA_gapfilled_mean + TA_gapfilled_se, color = "black"), # color = winteryear_factor),
                width = 0.3, linewidth = 0.7, alpha = 1 ) +
  
facet_wrap(~ season, ncol = 3, scales = "free_x") +  #free_x needed to allow different axis labels among the panels, otherwise they will all be the same for each panel 
  
  scale_color_manual(values = winteryear_colors) +
  #scale_x_continuous(breaks = 2017:2022) +  #same axis labels for all panels 
  
  #custom axis labels that are different among the panels 
  facetted_pos_scales( 
    x = list(
      season == "Growing Season" ~ scale_x_continuous(breaks = 2017:2022),
      season == "Fall Senescence" ~ scale_x_continuous(breaks = 2017:2022),
      season == "Winter" ~ scale_x_continuous(breaks = 2017:2022, 
                                               labels = c("2017 - 2018", "2018 - 2019", 
                                                         "2019 - 2020", "2020 - 2021", 
                                                         "2021 - 2022", "2022 - 2023"))
    )
  ) +
  
  labs(title = "Mean Seasonal Air Temperature Trends by Season (2017-2022)",
       x = "Year", 
       y = "Air Temperature (°C)") +
  theme_bw() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    axis.title.x = element_text(face = "bold", size = 12),
    axis.title.y = element_text(face = "bold", size = 12),
    axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"),
    axis.text.y = element_text(face = "bold"),
    strip.text = element_text(face = "bold", size = 11),
    legend.position = "none"
  )

p_TA

# ============================================================================
# Plot 2: Soil Temperature by Season (ERA5 Gap-filled)
# ============================================================================

p_TS <- ggplot(seasonal_summary_all %>%
                 filter(winter_year >= 2017 & winter_year <= 2022)) +
  geom_hline(yintercept = 0, color = "black", linewidth = 0.5) +
  
  geom_point(aes(x = winter_year, y = TS_3_gapfilled_mean, color = winteryear_factor, group = winter_year), 
             size = 3) +
  geom_errorbar(aes(x = winter_year, ymin = TS_3_gapfilled_mean - TS_3_gapfilled_se, 
                    ymax = TS_3_gapfilled_mean + TS_3_gapfilled_se, color = "black"), # color = winteryear_factor),
                 width = 0.3, linewidth = 0.7, alpha = 1 ) +
  
  # geom_smooth(aes(x = winter_year, y = TS_3_gapfilled_mean), 
  #             method = "auto", se = TRUE, color = "black", alpha = 0.2, linewidth = 0.8) +
  
 facet_wrap(~ season, ncol = 3, scales = "free_x") +  #free_x needed to allow different axis labels among the panels, otherwise they will all be the same for each panel 
  
  scale_color_manual(values = winteryear_colors) +
  #scale_x_continuous(breaks = 2017:2022) +  #same axis labels for all panels 
  
  #custom axis labels that are different among the panels 
  facetted_pos_scales( 
    x = list(
      season == "Growing Season" ~ scale_x_continuous(breaks = 2017:2022),
      season == "Fall Senescence" ~ scale_x_continuous(breaks = 2017:2022),
      season == "Winter" ~ scale_x_continuous(breaks = 2017:2022, 
                                               labels = c("2017 - 2018", "2018 - 2019", 
                                                         "2019 - 2020", "2020 - 2021", 
                                                         "2021 - 2022", "2022 - 2023"))
    )
  ) +
  
  labs(title = "Mean Seasonal Soil Temperature Trends by Season (2017-2022)",
       x = "Year", 
       y = "Soil Temperature (°C)") +
  theme_bw() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    axis.title.x = element_text(face = "bold", size = 12),
    axis.title.y = element_text(face = "bold", size = 12),
    axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"),
    axis.text.y = element_text(face = "bold"),
    strip.text = element_text(face = "bold", size = 11),
    legend.position = "none"
  )

# ============================================================================
# Plot 3: Soil Moisture by Season
# ============================================================================

p_SWC_nf <- ggplot(seasonal_summary_all %>%
                 filter(winter_year >= 2017 & winter_year <= 2022) %>%
                   filter(season != "Winter")) +
  geom_hline(yintercept = 0, color = "black", linewidth = 0.5) +
  
  geom_point(aes(x = winter_year, y = SWC_3_nf_mean, color = winteryear_factor, group = winter_year), 
             size = 3) +
  geom_errorbar(aes(x = winter_year, ymin = SWC_3_nf_mean - SWC_3_nf_se, 
                    ymax = SWC_3_nf_mean + SWC_3_nf_se, color = "black"), # color = winteryear_factor),
                width = 0.3, linewidth = 0.7, alpha = 1 ) +
  
  # geom_smooth(aes(x = winter_year, y = SWC_3_mean), 
  #             method = "auto", se = TRUE, color = "black", alpha = 0.2, linewidth = 0.8) +
  
  facet_wrap(~ season, ncol = 3, scales = "free_x") +  #free_x needed to allow different axis labels among the panels, otherwise they will all be the same for each panel 
  
  scale_color_manual(values = winteryear_colors) +
  #scale_x_continuous(breaks = 2017:2022) +  #same axis labels for all panels 
  
  #custom axis labels that are different among the panels 
  facetted_pos_scales( 
    x = list(
      season == "Growing Season" ~ scale_x_continuous(breaks = 2017:2022),
      season == "Fall Senescence" ~ scale_x_continuous(breaks = 2017:2022),
      season == "Winter" ~ scale_x_continuous(breaks = 2017:2022, 
                                               labels = c("2017 - 2018", "2018 - 2019", 
                                                         "2019 - 2020", "2020 - 2021", 
                                                         "2021 - 2022", "2022 - 2023"))
    )
  ) +
  
  labs(title = "Mean Seasonal Soil Moisture Trends by Season (2017-2022)",
       x = "Year", 
       y = "Soil Water Content (%)") +
  theme_bw() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    axis.title.x = element_text(face = "bold", size = 12),
    axis.title.y = element_text(face = "bold", size = 12),
    axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"),
    axis.text.y = element_text(face = "bold"),
    strip.text = element_text(face = "bold", size = 11),
    legend.position = "none"
  )

p_SWC_nf
# ============================================================================
# Plot 4: RH by Season
# ============================================================================

p_RH <- ggplot(seasonal_summary_all %>%
                 filter(winter_year >= 2017 & winter_year <= 2022)) +
  geom_hline(yintercept = 0, color = "black", linewidth = 0.5) +
  
  geom_point(aes(x = winter_year, y = RH_mean, color = winteryear_factor, group = winter_year), 
             size = 3) +
  geom_errorbar(aes(x = winter_year, ymin = RH_mean - RH_se, 
                    ymax = RH_mean + RH_se, color = "black"), # color = winteryear_factor),
                width = 0.3, linewidth = 0.7, alpha = 1 ) +
  
  # geom_smooth(aes(x = winter_year, y = RH_mean), 
  #             method = "auto", se = TRUE, color = "black", alpha = 0.2, linewidth = 0.8) +
  
 facet_wrap(~ season, ncol = 3, scales = "free_x") +  #free_x needed to allow different axis labels among the panels, otherwise they will all be the same for each panel 
  
  scale_color_manual(values = winteryear_colors) +
  #scale_x_continuous(breaks = 2017:2022) +  #same axis labels for all panels 
  
  #custom axis labels that are different among the panels 
  facetted_pos_scales( 
    x = list(
      season == "Growing Season" ~ scale_x_continuous(breaks = 2017:2022),
      season == "Fall Senescence" ~ scale_x_continuous(breaks = 2017:2022),
      season == "Winter" ~ scale_x_continuous(breaks = 2017:2022, 
                                               labels = c("2017 - 2018", "2018 - 2019", 
                                                         "2019 - 2020", "2020 - 2021", 
                                                         "2021 - 2022", "2022 - 2023"))
    )
  ) +
  
  labs(title = "Mean Seasonal RH Trends by Season (2017-2022)",
       x = "Year", 
       y = "RH (%)") +
  theme_bw() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    axis.title.x = element_text(face = "bold", size = 12),
    axis.title.y = element_text(face = "bold", size = 12),
    axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"),
    axis.text.y = element_text(face = "bold"),
    strip.text = element_text(face = "bold", size = 11),
    legend.position = "none"
  )

# ============================================================================
# Plot 5: VPD by Season
# ============================================================================

p_VPD <- ggplot(seasonal_summary_all %>%
                 filter(winter_year >= 2017 & winter_year <= 2022)) +
  geom_hline(yintercept = 0, color = "black", linewidth = 0.5) +
  
  geom_point(aes(x = winter_year, y = VPD_mean, color = winteryear_factor, group = winter_year), 
             size = 3) +
  geom_errorbar(aes(x = winter_year, ymin = VPD_mean - VPD_se, 
                    ymax = VPD_mean + VPD_se, color = "black"), # color = winteryear_factor),
                 width = 0.3, linewidth = 0.7, alpha = 1 ) +
  
  # geom_smooth(aes(x = winter_year, y = VPD_mean), 
  #             method = "auto", se = TRUE, color = "black", alpha = 0.2, linewidth = 0.8) +
  
  facet_wrap(~ season, ncol = 3, scales = "free_x") +  #free_x needed to allow different axis labels among the panels, otherwise they will all be the same for each panel 
  
  scale_color_manual(values = winteryear_colors) +
  #scale_x_continuous(breaks = 2017:2022) +  #same axis labels for all panels 
  
  #custom axis labels that are different among the panels 
  facetted_pos_scales( 
    x = list(
      season == "Growing Season" ~ scale_x_continuous(breaks = 2017:2022),
      season == "Fall Senescence" ~ scale_x_continuous(breaks = 2017:2022),
      season == "Winter" ~ scale_x_continuous(breaks = 2017:2022, 
                                               labels = c("2017 - 2018", "2018 - 2019", 
                                                         "2019 - 2020", "2020 - 2021", 
                                                         "2021 - 2022", "2022 - 2023"))
    )
  ) +
  
  labs(title = "Mean Seasonal VPD Trends by Season (2017-2022)",
       x = "Year", 
       y = "VPD (hPa)") +
  theme_bw() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    axis.title.x = element_text(face = "bold", size = 12),
    axis.title.y = element_text(face = "bold", size = 12),
    axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"),
    axis.text.y = element_text(face = "bold"),
    strip.text = element_text(face = "bold", size = 11),
    legend.position = "none"
  )

# ============================================================================
# Plot 6: Sensible Heat (H) by Season
# ============================================================================

p_H <- ggplot(seasonal_summary_all %>%
                 filter(winter_year >= 2017 & winter_year <= 2022)) +
  geom_hline(yintercept = 0, color = "black", linewidth = 0.5) +
  
  geom_point(aes(x = winter_year, y = H_mean, color = winteryear_factor, group = winter_year), 
             size = 3) +
  geom_errorbar(aes(x = winter_year, ymin = H_mean - H_se, 
                    ymax = H_mean + H_se, color = "black"), # color = winteryear_factor),
                 width = 0.3, linewidth = 0.7, alpha = 1 ) +
  
  #geom_smooth(aes(x = winter_year, y = H_mean), 
             # method = "auto", se = TRUE, color = "black", alpha = 0.2, linewidth = 0.8) +
  
  facet_wrap(~ season, ncol = 3, scales = "free_x") +  #free_x needed to allow different axis labels among the panels, otherwise they will all be the same for each panel 
  
  scale_color_manual(values = winteryear_colors) +
  #scale_x_continuous(breaks = 2017:2022) +  #same axis labels for all panels 
  
  #custom axis labels that are different among the panels 
  facetted_pos_scales( 
    x = list(
      season == "Growing Season" ~ scale_x_continuous(breaks = 2017:2022),
      season == "Fall Senescence" ~ scale_x_continuous(breaks = 2017:2022),
      season == "Winter" ~ scale_x_continuous(breaks = 2017:2022, 
                                               labels = c("2017 - 2018", "2018 - 2019", 
                                                         "2019 - 2020", "2020 - 2021", 
                                                         "2021 - 2022", "2022 - 2023"))
    )
  ) +
  
  labs(title = "Mean Seasonal Sensible Heat Flux Trends by Season (2017-2022)",
       x = "Year", 
       y = "H (W/m²)") +
  theme_bw() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    axis.title.x = element_text(face = "bold", size = 12),
    axis.title.y = element_text(face = "bold", size = 12),
    axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"),
    axis.text.y = element_text(face = "bold"),
    strip.text = element_text(face = "bold", size = 11),
    legend.position = "none"
  )

# ============================================================================
# Plot 7: Latent Heat (LE) by Season
# ============================================================================

p_LE <- ggplot(seasonal_summary_all %>%
                 filter(winter_year >= 2017 & winter_year <= 2022)) +
  geom_hline(yintercept = 0, color = "black", linewidth = 0.5) +
  
  geom_point(aes(x = winter_year, y = LE_mean, color = winteryear_factor, group = winter_year), 
             size = 3) +
  geom_errorbar(aes(x = winter_year, ymin = LE_mean - LE_se, 
                    ymax = LE_mean + LE_se, color = "black"), #color = winteryear_factor),
                 width = 0.3, linewidth = 0.7, alpha = 1 ) +
  
  #geom_smooth(aes(x = winter_year, y = LE_mean), 
             # method = "auto", se = TRUE, color = "black", alpha = 0.2, linewidth = 0.8) +
  facet_wrap(~ season, ncol = 3, scales = "free_x") +  #free_x needed to allow different axis labels among the panels, otherwise they will all be the same for each panel 
  
  scale_color_manual(values = winteryear_colors) +
  #scale_x_continuous(breaks = 2017:2022) +  #same axis labels for all panels 
  
  #custom axis labels that are different among the panels 
  facetted_pos_scales( 
    x = list(
      season == "Growing Season" ~ scale_x_continuous(breaks = 2017:2022),
      season == "Fall Senescence" ~ scale_x_continuous(breaks = 2017:2022),
      season == "Winter" ~ scale_x_continuous(breaks = 2017:2022, 
                                               labels = c("2017 - 2018", "2018 - 2019", 
                                                         "2019 - 2020", "2020 - 2021", 
                                                         "2021 - 2022", "2022 - 2023"))
    )
  ) +
  
  labs(title = "Mean Seasonal Latent Heat Flux Trends by Season (2017-2022)",
       x = "Year", 
       y = "LE (W/m²)") +
  theme_bw() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    axis.title.x = element_text(face = "bold", size = 12),
    axis.title.y = element_text(face = "bold", size = 12),
    axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"),
    axis.text.y = element_text(face = "bold"),
    strip.text = element_text(face = "bold", size = 11),
    legend.position = "none"
  )

# ============================================================================
# Plot 8: Ground Heat Flux (G) by Season
# ============================================================================

p_G <- ggplot(seasonal_summary_all %>%
                 filter(winter_year >= 2017 & winter_year <= 2022)) +
  geom_hline(yintercept = 0, color = "black", linewidth = 0.5) +
  
  geom_point(aes(x = winter_year, y = G_mean, color = winteryear_factor, group = winter_year), 
             size = 3) +
  geom_errorbar(aes(x = winter_year, ymin = G_mean - G_se, 
                    ymax = G_mean + G_se, color = "black"),
                 width = 0.3, linewidth = 0.7, alpha = 1 ) +
  
  # geom_smooth(aes(x = winter_year, y = G_mean), 
  #             method = "lm", se = TRUE, color = "black", alpha = 0.2, linewidth = 0.8) +
  
  facet_wrap(~ season, ncol = 3, scales = "free_x") +  #free_x needed to allow different axis labels among the panels, otherwise they will all be the same for each panel 
  
  scale_color_manual(values = winteryear_colors) +
  #scale_x_continuous(breaks = 2017:2022) +  #same axis labels for all panels 
  
  #custom axis labels that are different among the panels 
  facetted_pos_scales( 
    x = list(
      season == "Growing Season" ~ scale_x_continuous(breaks = 2017:2022),
      season == "Fall Senescence" ~ scale_x_continuous(breaks = 2017:2022),
      season == "Winter" ~ scale_x_continuous(breaks = 2017:2022, 
                                               labels = c("2017 - 2018", "2018 - 2019", 
                                                         "2019 - 2020", "2020 - 2021", 
                                                         "2021 - 2022", "2022 - 2023"))
    )
  ) +
  
  labs(title = "Mean Seasonal Ground Heat Flux Trends by Season (2017-2022)",
       x = "Year", 
       y = "G (W/m²)") +
  theme_bw() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    axis.title.x = element_text(face = "bold", size = 12),
    axis.title.y = element_text(face = "bold", size = 12),
    axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"),
    axis.text.y = element_text(face = "bold"),
    strip.text = element_text(face = "bold", size = 11),
    legend.position = "none"
  )

# ============================================================================
# DISPLAY ALL PLOTS  
# ============================================================================

print(p_TA)
print(p_TS)
print(p_SWC_nf)
print(p_RH)
print(p_VPD)
print(p_H)
print(p_LE)
print(p_G)


#note, SE is present but some error bars are so small compared to the scale of the fig they appear as if they're not showing up...but if you change scale = "free", you can see them, this just doesn't maintain consistent axis ranges among seasons
```



#Arrange figures into one 
```{r}
library(gridExtra)
library(grid)
library(ggplot2)

# Remove titles from all plots
p_TA <- p_TA + labs(title = NULL)
p_TS <- p_TS + labs(title = NULL)
p_SWC_nf <- p_SWC_nf + labs(title = NULL)
p_VPD <- p_VPD + labs(title = NULL)
p_RH <- p_RH + labs(title = NULL)
p_H <- p_H + labs(title = NULL)
p_LE <- p_LE + labs(title = NULL)
p_G <- p_G + labs(title = NULL)


# Extract the legend from one of your existing plots
# First, temporarily modify one plot to show the legend
p_with_legend <- p_TA + 
  theme(legend.position = "right") +
  scale_color_manual(values = winteryear_colors, name = "Year")

# Function to extract legend
get_legend <- function(myggplot) {
  tmp <- ggplot_gtable(ggplot_build(myggplot))
  leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
  legend <- tmp$grobs[[leg]]
  return(legend)
}

legend <- get_legend(p_with_legend)

# Arrange all your existing plots with the shared legend
seasonal_MeanMet_by_winteryr <- grid.arrange(
  arrangeGrob(p_TA, p_TS, p_SWC_nf, p_VPD, p_RH, p_H, p_LE, p_G, ncol = 2),
  legend,
  ncol = 2,
  widths = c(10, 1.5),
  top = textGrob("Seasonal Environmental Trends (2017-2022)", 
                 gp = gpar(fontsize = 16, fontface = "bold"))
)
```


#Save figure 
```{r}

ggsave("C:/Users/kkent/Documents/Github Flux Network/Council_Flux_Analysis_Paper/Council Figures/seasonal_MeanMet_vars_by_winteryear_plot.png", seasonal_MeanMet_by_winteryr, 
        width = 15, height = 15, dpi = 600)
```


#Annual - calendar year - visuals to show annual trends of TA, TS3, SWC
```{r}
annual_budgets3 <- annual_budgets2 %>%
  dplyr::select(year, mean_soil_moisture_nf, se_soil_moisture_nf, mean_TA_gapfilled, se_TA_gapfilled, mean_TS_3_gapfilled, se_TS_3_gapfilled)

#SWC no freeze (no winter, only when TS3 was above 2)
ggplot(annual_budgets3, aes(x = year, y = mean_soil_moisture_nf)) +
  geom_point()

#TA_gf
ggplot(annual_budgets3, aes(x = year, y = mean_TA_gapfilled)) +
  geom_point()

#TS_gf
ggplot(annual_budgets3, aes(x = year, y = mean_TS_3_gapfilled)) +
  geom_point()

# Convert year to factor for consistent color mapping
annual_budgets3$year_factor <- as.factor(annual_budgets3$year)

# # Reshape data for plotting
# annual_budgets3_long <- annual_budgets3 %>%
#   pivot_longer(cols = c(mean_soil_moisture_nf, se_soil_moisture_nf, mean_TA_gapfilled, se_TA_gapfilled, mean_TS_3_gapfilled, se_TS_3_gapfilled),
#                names_to = "met_var",
#                values_to = "values")



# Define consistent year colors
year_colors <- c("2017" = "#E41A1C",  # Red
                 "2018" = "#377EB8",  # Blue
                 "2019" = "#4DAF4A",  # Green
                 "2020" = "#984EA3",  # Purple
                 "2021" = "#FF7F00",  # Orange
                 "2022" = "#A65628")  # Brown


```

#Annual figs  - annual means across years, facet-wrapped by met var 
```{r}

# Reshape data to long format
annual_budgets3_long <- annual_budgets3 %>%
  pivot_longer(
    cols = c(mean_TA_gapfilled, mean_TS_3_gapfilled, mean_soil_moisture_nf),
    names_to = "variable",
    values_to = "mean_value",
    names_prefix = "mean_"
  ) %>%
  # Also pivot the SE columns
  pivot_longer(
    cols = c(se_TA_gapfilled, se_TS_3_gapfilled, se_soil_moisture_nf),
    names_to = "se_variable",
    values_to = "se_value",
    names_prefix = "se_"
  ) %>%
  # Keep only matching pairs (TA mean with TA se, etc.)
  filter(variable == se_variable) %>%
  select(-se_variable) %>%
  # Create nice labels for facets
  mutate(
    variable_label = case_when(
      variable == "TA_gapfilled" ~ "Air Temperature (°C)",
      variable == "TS_3_gapfilled" ~ "Soil Temperature (°C)",
      variable == "soil_moisture_nf" ~ "Soil Moisture (%)"
    ),
    variable_label = factor(variable_label, 
                           levels = c("Air Temperature (°C)", 
                                     "Soil Temperature (°C)", 
                                     "Soil Moisture (%)"))
  )



#Figure
p_met <- ggplot(annual_budgets3_long, 
                aes(x = year, y = mean_value, color = as.factor(year))) +
  geom_hline(yintercept = 0)+
  
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = mean_value - se_value, 
                    ymax = mean_value + se_value),
                width = 0.3, linewidth = 0.7, color = "black") +
  
  facet_wrap(~ variable_label, ncol = 3, scales = "free_y") +
  
  scale_color_manual(values = year_colors) +
  scale_x_continuous(breaks = function(x) seq(floor(min(x)), ceiling(max(x)), by = 1)) +
  #could also simply use:
  #scale_x_continuous(breaks = 2017:2022)
  
  labs(title = "Annual Mean Meteorological Variables (2017-2022)",
       x = "Year", 
       y = "Mean Value") +
  theme_bw() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    axis.title.x = element_text(face = "bold", size = 12),
    axis.title.y = element_text(face = "bold", size = 12),
    axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"),
    axis.text.y = element_text(face = "bold"),
    strip.text = element_text(face = "bold", size = 11),
    legend.position = "none"
  )

p_met


```
#---------------------------------------------------

#******* STATS ******************************

#Met variables timeseries analysis 


####Annual - Timeseries of annual TA, TA_3, SWC_nf - using mann-kendall timeseries test of only TA, TS, SWC
```{r}
library(Kendall)

# Run Mann-Kendall test for each variable
mk_TA <- MannKendall(annual_budgets3$mean_TA_gapfilled)
mk_TS <- MannKendall(annual_budgets3$mean_TS_3_gapfilled)
mk_SWC <- MannKendall(annual_budgets3$mean_soil_moisture_nf)


# Create summary table
mk_results <- data.frame(
  Variable = c("Air Temperature (°C)", 
               "Soil Temperature (°C)", 
               "Soil Moisture (%)"),
  Tau = c(mk_TA$tau, mk_TS$tau, mk_SWC$tau),
  P_value = c(mk_TA$sl, mk_TS$sl, mk_SWC$sl),
  Trend = c(
    ifelse(mk_TA$sl < 0.05, ifelse(mk_TA$tau > 0, "Increasing*", "Decreasing*"), "No trend"),
    ifelse(mk_TS$sl < 0.05, ifelse(mk_TS$tau > 0, "Increasing*", "Decreasing*"), "No trend"),
    ifelse(mk_SWC$sl < 0.05, ifelse(mk_SWC$tau > 0, "Increasing*", "Decreasing*"), "No trend")
  )
)

print(mk_results)

# Save results
# write_csv(mk_results, "mann_kendall_results.csv")

#Results:

#var                     Tau          p-val      Trend 
# Air Temperature (°C)	-0.3333333	0.45237035	No trend	
# Soil Temperature (°C)	0.2000000	0.70711422	No trend	
# Soil Moisture (%)	-0.7333333	0.06028918	No trend / borderline potential trend 

```

#Seasonal - timeseries of met vars by season among years 

#### Autocorrelation check 

Autocorr test - just in case, though since these are seasonal averages among years, autocorr should not be an issue

 * Want to test autocorr among years, but WITHIN each season* 

#Autocorr
```{r}

# For each season separately:

#Growing season 
growing_data <- seasonal_summary_all %>% 
  filter(season == "Growing Season", na.rm = TRUE) %>%
  arrange(winter_year) #%>%
  #pull(TS_3_gapfilled_mean)  # or can change to whatever whatever variable

#Fall
fall_data <- seasonal_summary_all %>% 
  filter(season == "Fall Senescence", na.rm = TRUE) %>%
  arrange(winter_year) #%>%

#Winter-year
winter_data <- seasonal_summary_all %>% 
  filter(season == "Winter", na.rm = TRUE) %>%
  filter(winter_year != "2016") %>%
  arrange(winter_year) 

# Check autocorrelation
acf(na.omit(growing_data$SWC_3_nf_mean, lag.max = 2, plot = TRUE))


# Or get the lag-1 autocorrelation value
lag1_autocorr <- acf(na.omit(growing_data$RH_mean, lag.max = 1, plot = FALSE))$acf[2]

#Ljung-Box test for timeseries models / data -- if p<0.05, there is autocorr and residuals are not independent - not working here, not sure why
#Box.test(growing_data$TS_3_gapfilled_mean, lag = 20, type = "Ljung-Box") #p<0.001


#Durbin watson test for when a model has been fitted - checks if residuals are autocorrelated - DW = 2 = no autocorr, DW < 2 = pos autocorr, DW > 2 = neg autocorr

#install.packages("lmtest")   
library(lmtest)

lm_test<- lm(TA_gapfilled_mean ~ winter_year, data = winter_data)
dwtest(lm_test)
acf(residuals(lm_test), main = "ACF of model residuals")

#swap out met vars and seasonal data 

#growing season
#SWC: ok 
#Air temp GF: ok
#soil temp GF: ok 
#LE: ok 
#H: ok 
#G: ok 
#RH: p 0.08 - ok 


#fall
#SWC: ok 
#Air temp GF: ok 
#soil temp GF: ok 
#LE: ok 
#H: ok 
#G: ok 
#RH: ok 


#winter
#SWC: ok
#Air temp GF: ok
#soil temp GF: ok 
#LE:  ok 
#H: p 0.07, ok 
#G: ok 
#RH: ok 


```
#### Timeseries - among years, within season 

###### Reduced met var table 
```{r}
# Prepare seasonal summaries reduced to variables you plan to test 

seasonal_summary_all2 <- df_avg %>%
  filter(winter_year %in% 2017:2022) %>%
  group_by(winter_year, season) %>%
  summarise(
    TA_gapfilled_mean = mean(TA_gapfilled, na.rm = TRUE),
    TS_3_gapfilled_mean = mean(TS_3_gapfilled, na.rm = TRUE),
    SWC_3_nf_mean = mean(SWC_3_nf, na.rm = TRUE),
    VPD_mean = mean(VPD, na.rm = TRUE),
    RH_mean = mean(RH, na.rm = TRUE),
    H_mean = mean(H, na.rm = TRUE),
    LE_mean = mean(LE, na.rm = TRUE),
    G_mean = mean(G_1_1_1, na.rm = TRUE),
    H_mean = mean(H, na.rm = TRUE),
    .groups = 'drop'
  )

seasonal_summary_all2

```


#### Mann-Kendall timeseries
```{r}
#load package for sens.slope
library(trend)

# Create summary table with all results
seasonal_mk_summary <- seasonal_summary_all2 %>%
  group_by(season) %>% #split data by season 
  summarise(
    # Air Temperature
    TA_tau = MannKendall(TA_gapfilled_mean)$tau, #kendall tau stat
    TA_pval = MannKendall(TA_gapfilled_mean)$sl, #sl = sig level, p-val
    TA_slope = sens.slope(TA_gapfilled_mean)$estimates, #sens_slope, kendall equivalent of a slope
    
    # Soil Temperature
    TS_tau = MannKendall(TS_3_gapfilled_mean)$tau,
    TS_pval = MannKendall(TS_3_gapfilled_mean)$sl,
    TS_slope = sens.slope(TS_3_gapfilled_mean)$estimates, 
    
    # Soil Moisture
    SWC_tau = MannKendall(SWC_3_nf_mean)$tau,
    SWC_pval = MannKendall(SWC_3_nf_mean)$sl,
    #SWC_slope = sens.slope(SWC_3_nf_mean, na.action = na.omit)$estimates, #need to explicitly remove NAs - but na.omit not accepted by sens.slope
     #add check - sens.slope needs at least 2 values to try to calc a slope and SWC has no winter
   SWC_slope = ifelse(sum(!is.na(SWC_3_nf_mean)) >= 3,
                       sens.slope(na.omit(SWC_3_nf_mean))$estimates,
                       NA),
    
    # VPD
    VPD_tau = MannKendall(VPD_mean)$tau,
    VPD_pval = MannKendall(VPD_mean)$sl,
    VPD_slope = sens.slope(VPD_mean)$estimate,
   
       # RH
    RH_tau = MannKendall(RH_mean)$tau,
    RH_pval = MannKendall(RH_mean)$sl,
    RH_slope = sens.slope(RH_mean)$estimate,
    
    # Sensible Heat
    H_tau = MannKendall(H_mean)$tau,
    H_pval = MannKendall(H_mean)$sl,
    H_slope = sens.slope(H_mean)$estimate,
    
    # Latent Heat
    LE_tau = MannKendall(LE_mean)$tau,
    LE_pval = MannKendall(LE_mean)$sl,
    LE_slope = sens.slope(LE_mean)$estimate,
    
    # Ground Heat Flux
    G_tau = MannKendall(G_mean)$tau,
    G_pval = MannKendall(G_mean)$sl,
    #G_slope = sens.slope(G_mean, na.action = na.omit)$estimate, #need to remove NAs - na.omit not accepted by sens.slope
    #add check - sens.slope needs at least 2 values to try to calc a slope and G has none for 2017
     G_slope = ifelse(sum(!is.na(G_mean)) >= 3,
                     sens.slope(na.omit(G_mean))$estimates,
                     NA),

    
    .groups = "drop"
  )

print(seasonal_mk_summary)

# Save results
#write_csv(seasonal_mk_summary, "seasonal_mann_kendall_results.csv")

```



#### Automated loop to perform the above in neat output, created by Claude 
```{r}
library(Kendall)
library(tidyverse)

# Create empty list to store results
mk_seasonal_results <- list()

# Get list of seasons
seasons <- unique(seasonal_summary_all2$season)

# Get list of variables to test
variables <- c("TA_gapfilled_mean", "TS_3_gapfilled_mean", "SWC_3_nf_mean", 
               "VPD_mean", "RH_mean", "H_mean", "LE_mean", "G_mean")

# Loop through each season
for(s in seasons) {
  
  cat("\n========================================\n")
  cat("SEASON:", s, "\n")
  cat("========================================\n\n")
  
  # Filter data for this season
  season_data <- seasonal_summary_all2 %>%
    filter(season == s) %>%
    arrange(winter_year)  # Ensure chronological order
  
  # Test each variable
  for(v in variables) {
    
    # Extract the variable values
    values <- season_data[[v]]
    
    # Run Mann-Kendall test
    mk_test <- MannKendall(values)
    
   # Calculate Sen's slope (with check for enough data points)
    # Check if there are at least 3 non-NA values
    if(sum(!is.na(values)) >= 3) {
      # If yes, calculate Sen's slope
      slope_result <- sens.slope(na.omit(values))
      slope_estimate <- slope_result$estimates
     # slope_lower <- slope_result$conf.int[1] #to calc confidence interval of slope 
     # slope_upper <- slope_result$conf.int[2]
    } else {
      # If not enough data, set to NA
      slope_estimate <- NA
      # slope_lower <- NA
      # slope_upper <- NA
    }
    
    # Store results
    result_name <- paste0(s, "_", v)
    mk_seasonal_results[[result_name]] <- list( # mk_test <-use simply this to only print mk results
      tau = mk_test$tau,
      p_value = mk_test$sl,
      sens_slope = slope_estimate )
    
    # Print results
    cat(v, ":\n")
    cat("  Tau =", round(mk_test$tau, 3), "\n")
    cat("  P-value =", round(mk_test$sl, 4), "\n")
    cat("  Trend:", ifelse(mk_test$sl < 0.05, 
                           ifelse(mk_test$tau > 0, "Increasing*", "Decreasing*"), 
                           "Not significant"), "\n\n")
    # Print slope if it was calculated
    if(!is.na(slope_estimate)) {
      cat("  Sen's Slope =", round(slope_estimate, 4), ")\n")
          #"(95% CI:", round(slope_lower, 4), "to", round(slope_upper, 4), ")\n")
    } else {
      cat("  Sen's Slope = Not enough data\n")
    }
    cat("\n")
  }
}
```


#Stats - differences in variables among years within each season 


#Important: this is looking at the normality / heterogeneity of the annual means for each season, for each year (so n = 6) - shapiro-wilkes will have very low power with this low sample size so rely on QQ-plots and histograms 

Streamlined function code from Claude 
```{r}
# Visual Diagnostics for Assumption Testing
# QQ-plots and Histograms for normality assessment

library(ggplot2)
library(dplyr)
library(gridExtra)


# ============================================================================
# FUNCTION: Create diagnostic plots for each met variable
# ============================================================================


#initialize resid_data
  resid_data <- NULL
    shapiro_p <- NA
    normal_status <- "Not tested"
    
    #function to loop through all diagnostics for each met var 
create_diagnostic_plots <- function(data, var_name, var_label) {
  
  seasons <- unique(data$season)
  plot_list <- list()
  
  for (s in seasons) {
    season_data <- data %>% filter(season == s)
    y_vals <- season_data[[var_name]]
    
    # Skip if too many NAs
    if (sum(!is.na(y_vals)) < 4) next
    
    # ========================================================================
    # FIT LINEAR MODEL AND CALCULATE RESIDUALS FIRST
    # ========================================================================
    
    # Remove NAs to ensure consistent lengths
    complete_cases <- complete.cases(y_vals, season_data$winter_year)
    y_complete <- y_vals[complete_cases]
    x_complete <- season_data$winter_year[complete_cases]
    
    # Check if we have enough data for linear model
    if(length(y_complete) >= 3) {
      # Fit linear model
      lm_model <- lm(y_complete ~ x_complete)
      resid_data <- data.frame(
        fitted = fitted(lm_model),
        residuals = residuals(lm_model),
        year = x_complete
      )
      
      # ========================================================================
      # SHAPIRO TEST ON RESIDUALS
      # ========================================================================
      if(length(resid_data$residuals) >= 3 & length(resid_data$residuals) <= 5000) {
        tryCatch({
          shapiro_result <- shapiro.test(resid_data$residuals)
          shapiro_p <- round(shapiro_result$p.value, 4)
          normal_status <- ifelse(shapiro_p > 0.05, "Normal", "Non-normal")
        }, error = function(e) {
          shapiro_p <<- NA
          normal_status <<- "Unable to test"
        })
      } else {
        shapiro_p <- NA
        normal_status <- "Insufficient data"
      }
    } else {
      # Not enough data
      resid_data <- NULL
      shapiro_p <- NA
      normal_status <- "Insufficient data"
    }
    
    # ========================================================================
    # CREATE PLOTS (RESIDUALS)
    # ========================================================================
    
    if(!is.null(resid_data)) {
      # QQ-plot of RESIDUALS
      qq_plot <- ggplot(data.frame(sample = resid_data$residuals), 
                       aes(sample = sample)) +
        stat_qq() +
        stat_qq_line(color = "red", linewidth = 1) +
        labs(title = paste(s, "- QQ Plot (Residuals)"),
             subtitle = paste("Shapiro p =", shapiro_p, "-", normal_status),
             x = "Theoretical Quantiles",
             y = "Sample Quantiles") +
        theme_bw() +
        theme(
          plot.title = element_text(face = "bold", size = 10),
          plot.subtitle = element_text(size = 9),
          axis.title = element_text(face = "bold", size = 9),
          axis.text = element_text(face = "bold", size = 8)
        )
      
      # Histogram of RESIDUALS
      hist_plot <- ggplot(data.frame(value = resid_data$residuals), 
                         aes(x = value)) +
        geom_histogram(bins = 5, fill = "steelblue", color = "black", alpha = 0.7) +
        geom_density(aes(y = after_stat(count)), color = "red", linewidth = 1) +
        labs(title = paste(s, "- Histogram (Residuals)"),
             x = "Residuals",
             y = "Count") +
        theme_bw() +
        theme(
          plot.title = element_text(face = "bold", size = 10),
          axis.title = element_text(face = "bold", size = 9),
          axis.text = element_text(face = "bold", size = 8)
        )
      
      # Residuals vs Fitted plot
      resid_plot <- ggplot(resid_data, aes(x = fitted, y = residuals)) +
        geom_point(size = 3, color = "steelblue") +
        geom_hline(yintercept = 0, linetype = "dashed", color = "red", linewidth = 1) +
        geom_smooth(method = "loess", se = FALSE, color = "black", linewidth = 0.8) +
        labs(title = paste(s, "- Residuals vs Fitted"),
             subtitle = paste("Should show random scatter around zero"),
             x = "Fitted Values",
             y = "Residuals") +
        theme_bw() +
        theme(
          plot.title = element_text(face = "bold", size = 10),
          plot.subtitle = element_text(size = 9),
          axis.title = element_text(face = "bold", size = 9),
          axis.text = element_text(face = "bold", size = 8)
        )
      
    } else {
      # Create placeholder plots if not enough data
      qq_plot <- ggplot() +
        annotate("text", x = 0.5, y = 0.5, 
                label = "Insufficient data for diagnostic plots", 
                size = 5, fontface = "bold") +
        theme_void()
      
      hist_plot <- qq_plot
      resid_plot <- qq_plot
    }
    
    # Store plots
    plot_list[[s]] <- list(qq = qq_plot, hist = hist_plot, resid = resid_plot)
  }
  
  return(plot_list)
}

# ============================================================================
# CREATE DIAGNOSTIC PLOTS FOR ALL VARIABLES
# ============================================================================


cat("Creating diagnostic plots for assumption testing...\n\n")

# ERA5-GF Air Temperature
cat("--- AIR TEMPERATURE (Gap-filled) ---\n")
GF_ta_diag <- create_diagnostic_plots(seasonal_summary_all2, 
                                    "TA_gapfilled_mean", 
                                    "GF Air Temperature (°C)")

# Arrange plots in a grid for each season
for (season in names(GF_ta_diag)) {
  grid.arrange(GF_ta_diag[[season]]$qq, 
               GF_ta_diag[[season]]$hist, 
               GF_ta_diag[[season]]$resid,
               ncol = 3,
               top = paste("GF Air Temperature -", season))
}

# # Air Temperature - measured 
# cat("--- AIR TEMPERATURE (measured) ---\n")
# ta_diag <- create_diagnostic_plots(seasonal_summary_all, 
#                                     "TA_mean", 
#                                     "Air Temperature (°C)")
# 
# # Arrange plots in a grid for each season
# for (season in names(ta_diag)) {
#   grid.arrange(ta_diag[[season]]$qq, 
#                ta_diag[[season]]$hist, 
#                ta_diag[[season]]$resid,
#                ncol = 3,
#                top = paste("Air Temperature -", season))
# }

# ERA5-GF Soil Temperature
cat("\n--- SOIL TEMPERATURE (Gap-filled) ---\n")
GF_ts_diag <- create_diagnostic_plots(seasonal_summary_all2, 
                                    "TS_3_gapfilled_mean", 
                                    "GF Soil Temperature (°C)")

for (season in names(GF_ts_diag)) {
  grid.arrange(GF_ts_diag[[season]]$qq, 
               GF_ts_diag[[season]]$hist, 
               GF_ts_diag[[season]]$resid,
               ncol = 3,
               top = paste("GF Soil Temperature -", season))
}

# # Measured Soil Temperature
# cat("\n--- SOIL TEMPERATURE (measured) ---\n")
# ts_diag <- create_diagnostic_plots(seasonal_summary_all, 
#                                     "TS_3_mean", 
#                                     "Soil Temperature (°C)")
# 
# for (season in names(ts_diag)) {
#   grid.arrange(ts_diag[[season]]$qq, 
#                ts_diag[[season]]$hist, 
#                ts_diag[[season]]$resid,
#                ncol = 3,
#                top = paste("Soil Temperature -", season))
# }

# # Soil Moisture - all
# cat("\n--- SOIL MOISTURE ---\n")
# swc_diag <- create_diagnostic_plots(seasonal_summary_all, 
#                                      "SWC_3_mean", 
#                                      "Soil Moisture (%)")
# 
# for (season in names(swc_diag)) {
#   grid.arrange(swc_diag[[season]]$qq, 
#                swc_diag[[season]]$hist, 
#                swc_diag[[season]]$resid,
#                ncol = 3,
#                top = paste("Soil Moisture -", season))
# }

# Soil Moisture - non-frozen, only when TS_3 is > 2 degC
cat("\n--- SOIL MOISTURE NF ---\n")
swc_diag <- create_diagnostic_plots(seasonal_summary_all2, 
                                     "SWC_3_mean_nf", 
                                     "Soil Moisture NF (%)")

for (season in names(swc_diag)) {
  grid.arrange(swc_diag[[season]]$qq, 
               swc_diag[[season]]$hist, 
               swc_diag[[season]]$resid,
               ncol = 3,
               top = paste("Soil Moisture NF -", season))
}

# RH
cat("\n--- RH ---\n")
rh_diag <- create_diagnostic_plots(seasonal_summary_all2, 
                                     "RH_mean", 
                                     "SRH (%)")

for (season in names(rh_diag)) {
  grid.arrange(rh_diag[[season]]$qq, 
               rh_diag[[season]]$hist, 
               rh_diag[[season]]$resid,
               ncol = 3,
               top = paste("RH -", season))
}

# VPD
cat("\n--- VAPOR PRESSURE DEFICIT ---\n")
vpd_diag <- create_diagnostic_plots(seasonal_summary_all2, 
                                     "VPD_mean", 
                                     "VPD (hPa)")

for (season in names(vpd_diag)) {
  grid.arrange(vpd_diag[[season]]$qq, 
               vpd_diag[[season]]$hist, 
               vpd_diag[[season]]$resid,
               ncol = 3,
               top = paste("VPD -", season))
}

# Sensible Heat
cat("\n--- SENSIBLE HEAT FLUX ---\n")
h_diag <- create_diagnostic_plots(seasonal_summary_all2, 
                                   "H_mean", 
                                   "Sensible Heat (W/m²)")

for (season in names(h_diag)) {
  grid.arrange(h_diag[[season]]$qq, 
               h_diag[[season]]$hist, 
               h_diag[[season]]$resid,
               ncol = 3,
               top = paste("Sensible Heat -", season))
}

# Latent Heat
cat("\n--- LATENT HEAT FLUX ---\n")
le_diag <- create_diagnostic_plots(seasonal_summary_all2, 
                                    "LE_mean", 
                                    "Latent Heat (W/m²)")

for (season in names(le_diag)) {
  grid.arrange(le_diag[[season]]$qq, 
               le_diag[[season]]$hist, 
               le_diag[[season]]$resid,
               ncol = 3,
               top = paste("Latent Heat -", season))
}

# Ground heat flux 
cat("\n--- Ground HEAT FLUX ---\n")
g_diag <- create_diagnostic_plots(seasonal_summary_all2, 
                                    "G_mean", 
                                    "Ground Heat Flux (W/m²)")

for (season in names(g_diag)) {
  grid.arrange(g_diag[[season]]$qq, 
               g_diag[[season]]$hist, 
               g_diag[[season]]$resid,
               ncol = 3,
               top = paste("Ground Heat -", season))
}


#Residuals Plot: Should show random scatter around 0 line\n")
#--Pattern/curve = non-linear relationship\n")
#--Funnel shape = heteroscedasticity (non-constant variance)\n\n")
#Shapiro-Wilk p-value: > 0.05 suggests normality\n") #but important to note that with n=6, shapiro wilkes has VERY low power, so rely on QQ-plot & histogram & use your judgement 


#Results notes:
#QQ plots don't look terrible, but the histograms don't look like normal distributions most times; all shapiro tests are normal but there's low power on such a small n 


```

#Timeseries of each met var across years within season 

Function written by Claude for Mann-Kendall timeseries test for each variable, as well as ensure there's enough values to run an analysis 
```{r}
library(Kendall)
library(trend)
library(tidyverse)

# ============================================================================
# MANN-KENDALL TIMESERIES ANALYSIS BY SEASON
# ============================================================================


# Get list of seasons
seasons <- unique(seasonal_summary_all2$season)

# Get list of variables to test
variables <- c("TA_gapfilled_mean", "TS_3_gapfilled_mean", "SWC_3_nf_mean", 
               "VPD_mean", "RH_mean", "H_mean", "LE_mean", "G_mean")

# Variable labels for nice output
var_labels <- c(
  "TA_gapfilled_mean" = "Air Temperature (°C)",
  "TS_3_gapfilled_mean" = "Soil Temperature (°C)",
  "SWC_3_nf_mean" = "Soil Moisture NF (%)",
  "VPD_mean" = "VPD (hPa)",
  "RH_mean" = "Relative Humidity (%)",
  "H_mean" = "Sensible Heat (W/m²)",
  "LE_mean" = "Latent Heat (W/m²)",
  "G_mean" = "Ground Heat Flux (W/m²)"
)

# Create empty list to store results
mk_results_by_season <- list()

# Loop through each season
for(s in seasons) {
  
  cat("\n========================================\n")
  cat("SEASON:", s, "\n")
  cat("========================================\n\n")
  
  # Filter data for this season
  season_data <- seasonal_summary_all2 %>%
    filter(season == s) %>%
    arrange(winter_year)
  
  # Test each variable
  for(v in variables) {
    
    # Extract the variable values
    values <- season_data[[v]]
    
    # Skip if all values are NA (e.g., SWC in winter)
    if(all(is.na(values))) {
      cat(var_labels[v], ": No data available\n\n")
      next
    }
    
    # Check if we have enough non-NA values
    n_valid <- sum(!is.na(values))
    
    if(n_valid < 3) {
      cat(var_labels[v], ": Insufficient data (n =", n_valid, ")\n\n")
      next
    }
    
    # Run Mann-Kendall test
    mk_test <- MannKendall(values)
    
    # Calculate Sen's slope if possible
    if(n_valid >= 3) {
      tryCatch({
        slope_result <- sens.slope(na.omit(values))
        slope_estimate <- slope_result$estimates
        slope_lower <- slope_result$conf.int[1]
        slope_upper <- slope_result$conf.int[2]
      }, error = function(e) {
        slope_estimate <<- NA
        slope_lower <<- NA
        slope_upper <<- NA
      })
    } else {
      slope_estimate <- NA
      slope_lower <- NA
      slope_upper <- NA
    }
    
    # Store results
    result_name <- paste0(s, "_", v)
    mk_results_by_season[[result_name]] <- list(
      season = s,
      variable = v,
      variable_label = var_labels[v],
      n = n_valid,
      tau = mk_test$tau,
      p_value = mk_test$sl,
      slope = slope_estimate,
      slope_CI_lower = slope_lower,
      slope_CI_upper = slope_upper
    )
    
    # Determine significance
    sig_symbol <- case_when(
       mk_test$sl < 0.001 ~ "***",
      mk_test$sl < 0.01 ~ "**",
      mk_test$sl < 0.05 ~ "*",
      TRUE ~ "ns"
    )
    
    trend_direction <- ifelse(mk_test$sl < 0.05,
                             ifelse(mk_test$tau > 0, "Increasing", "Decreasing"),
                             "No significant trend")
    
    # Print results
    cat(var_labels[v], ":\n")
    cat("  n =", n_valid, "\n")
    cat("  Tau =", round(mk_test$tau, 3), sig_symbol, "\n")
    cat("  P-value =", round(mk_test$sl, 4), "\n")
    cat("  Trend:", trend_direction, "\n")
    
    if(!is.na(slope_estimate)) {
      cat("  Sen's Slope =", round(slope_estimate, 4), 
          "(95% CI:", round(slope_lower, 4), "to", round(slope_upper, 4), ")\n")
    }
    cat("\n")
  }
}

# ============================================================================
# CONVERT RESULTS TO DATA FRAME
# ============================================================================

results_df <- do.call(rbind, lapply(mk_results_by_season, function(x) {
  data.frame(
    season = x$season,
    variable = x$variable,
    variable_label = x$variable_label,
    n = x$n,
    tau = x$tau,
    p_value = x$p_value,
    slope = x$slope,
    #slope_CI_lower = x$slope_CI_lower,
    #slope_CI_upper = x$slope_CI_upper,
    significance = case_when(
      x$p_value < 0.01 ~ "**",
      x$p_value < 0.05 ~ "*",
      x$p_value < 0.10 ~ "†",
      TRUE ~ "ns"
    ),
    trend = case_when(
      x$p_value < 0.05 & x$tau > 0 ~ "Increasing",
      x$p_value < 0.05 & x$tau < 0 ~ "Decreasing",
      TRUE ~ "No trend"
    ),
    stringsAsFactors = FALSE
  )
}))

# Add row names
rownames(results_df) <- NULL


print(results_df)

# Save results
# write_csv(results_df, "mann_kendall_by_season_results.csv")


# ============================================================================
# CREATE VISUAL SUMMARY
# ============================================================================

# Heatmap of tau values
ggplot(results_df, aes(x = season, y = variable_label, fill = tau)) +
  geom_tile(color = "white", linewidth = 1) +
  geom_text(aes(label = sprintf("τ=%.2f\n%s", tau, significance)), 
            fontface = "bold", size = 3) +
  scale_fill_gradient2(low = "steelblue", mid = "white", high = "red", 
                       midpoint = 0, limits = c(-1, 1),
                       na.value = "grey90") +
  labs(title = "Mann-Kendall Trend Analysis by Season (2017-2022)",
       subtitle = "**: p<0.01, *: p<0.05, †: p<0.10, ns: not significant",
       x = "Season", 
       y = "Variable", 
       fill = "Kendall's τ") +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    plot.subtitle = element_text(size = 10),
    axis.text.x = element_text(angle = 45, hjust = 1, face = "bold", size = 10),
    axis.text.y = element_text(face = "bold", size = 10),
    axis.title = element_text(face = "bold", size = 12),
    legend.title = element_text(face = "bold")
  )


```
#Save table
```{r}
# Export to CSV
write.csv(results_df, "C:/Users/kkent/Documents/Github Flux Network/Council_Flux_Analysis_Paper/Council Figures/winteryear_seasonal_mann_kendall_results", row.names = FALSE)
```


# LM, Kendall-tau, spearman corr comparisons for met vars across years within seasons 

##### starts with testing lm assumptions, pivots to non-parametric if assumptions are violated, uses spearman's corr & kendall's tau (similar to spearman corr but supposedly better for small sample sizes and here we only have 6 yrs so n = 6) - streamlined function code by Claude 

*See code chunk at end of script with this same process but with Mann-Kendall timeseries tests* 
```{r}

# Tests for significant trends in environmental variables by season (2017-2022)

library(dplyr)
library(broom)

# ============================================================================
# FUNCTION: Test trends for a variable within each season
# ============================================================================

test_seasonal_trends <- function(data, var_name, var_label, units) {
  
  results_list <- list()
  seasons <- unique(data$season)
  
  for (s in seasons) {
    season_data <- data %>% filter(season == s)
    
    # Extract variable values
    y_vals <- season_data[[var_name]]
    x_vals <- season_data$winter_year
    
    # Skip if too many NAs
    if (sum(!is.na(y_vals)) < 4) {
      next
    }
    
    # Test normality (Shapiro-Wilk) - tests normality of raw data, but for this we want residuals 
    
    # Linear regression
    lm_model <- lm(y_vals ~ x_vals)
    lm_summary <- summary(lm_model)
    
    #Test normality of RESIDUALS (not raw data)
    residuals_vals <- residuals(lm_model)
    shapiro_p <- shapiro.test(residuals_vals)$p.value
    
    # Extract key statistics
    slope <- coef(lm_model)[2]
    slope_se <- summary(lm_model)$coefficients[2, 2]
    slope_p <- summary(lm_model)$coefficients[2, 4]
    r_squared <- lm_summary$r.squared
    adj_r_squared <- lm_summary$adj.r.squared
    
    # Mann-Kendall test (non-parametric trend test) - run on the raw/observed data 
    # Kendall's tau correlation - similar to mann-kendall timeseries analysis but not exactly the        same 
    kendall_test <- cor.test(x_vals, y_vals, method = "kendall")
    kendall_tau <- kendall_test$estimate
    kendall_p <- kendall_test$p.value
    
    # Spearman correlation (another non-parametric option) - run on the raw/observed data 
    spearman_test <- cor.test(x_vals, y_vals, method = "spearman")
    spearman_rho <- spearman_test$estimate
    spearman_p <- spearman_test$p.value
    
    # # Calculate percent change over period - not sure this is working properly...
    # first_val <- y_vals[1]
    # last_val <- y_vals[length(y_vals)]
    # total_change <- last_val - first_val
    # pct_change <- (total_change / abs(first_val)) * 100
    
    # Calculate change per year
   # change_per_year <- slope
    
    # Store results
    results_list[[s]] <- data.frame(
      season = s,
      variable = var_label,
      units = units,
      n_years = length(y_vals),
      mean_value = mean(y_vals, na.rm = TRUE),
      
      # Normality test
      shapiro_p = shapiro_p,
      normal = ifelse(shapiro_p > 0.05, "Yes", "No"),
      
      # Linear model
      slope = slope,
      slope_se = slope_se,
      slope_p = slope_p,
      r_squared = r_squared,
      adj_r_squared = adj_r_squared,
      
      # Non-parametric tests
      kendall_tau = kendall_tau,
      kendall_p = kendall_p,
      spearman_rho = spearman_rho,
      spearman_p = spearman_p,
      
      # # Trend magnitude
      # change_per_year = change_per_year,
      # total_change_2017_2022 = total_change,
      # percent_change_2017_2022 = pct_change,
      
      # Significance (using appropriate test)
      significant = ifelse(shapiro_p > 0.05, 
                          ifelse(slope_p < 0.05, "Yes*", "No"),
                          ifelse(kendall_p < 0.05, "Yes**", "No")),
      
      stringsAsFactors = FALSE
    )
  }
  
  # Combine all seasons
  do.call(rbind, results_list)
}

# ============================================================================
# RUN TESTS FOR ALL VARIABLES
# ============================================================================

cat("============================================================\n")
cat("ANNUAL TREND ANALYSIS BY SEASON (2017-2022)\n")
cat("============================================================\n\n")

cat("Significance codes:\n")
cat("* = Linear regression (data normal)\n")
cat("** = Kendall's tau (data non-normal)\n")
cat("p < 0.05 = significant trend\n\n")

# GF Air Temperature
cat("\n--- AIR TEMPERATURE (Gap-filled) ---\n")
gf_ta_results <- test_seasonal_trends(seasonal_summary_all2, 
                                    "TA_gapfilled_mean", 
                                    "GF Air Temperature", 
                                    "°C")
print(gf_ta_results[, c("season", "mean_value", "normal", "slope", "slope_p", 
                     "kendall_tau", "kendall_p", #"change_per_year", #"percent_change_2017_2022"
                     "spearman_rho", "spearman_p", "significant")])

# # Air Temperature (measured)
# cat("\n--- AIR TEMPERATURE (measured) ---\n")
# ta_results <- test_seasonal_trends(seasonal_summary_all2, 
#                                     "TA_mean", 
#                                     "Air Temperature", 
#                                     "°C")
# print(ta_results[, c("season", "mean_value", "normal", "slope", "slope_p", 
#                      "kendall_tau", "kendall_p", #"change_per_year", 
#                      "spearman_rho", "spearman_p", "significant")])


# GF Soil Temperature
cat("\n--- SOIL TEMPERATURE (Gap-filled) ---\n")
gf_ts_results <- test_seasonal_trends(seasonal_summary_all2, 
                                    "TS_3_gapfilled_mean", 
                                    "GF Soil Temperature", 
                                    "°C")
print(gf_ts_results[, c("season", "mean_value", "normal", "slope", "slope_p", 
                     "kendall_tau", "kendall_p", #"change_per_year", 
                     "spearman_rho", "spearman_p", "significant")])

# # Soil Temperature (measured)
# cat("\n--- SOIL TEMPERATURE ---\n")
# ts_results <- test_seasonal_trends(seasonal_summary_all2, 
#                                     "TS_3_mean", 
#                                     "Soil Temperature", 
#                                     "°C")
# print(ts_results[, c("season", "mean_value", "normal", "slope", "slope_p", 
#                      "kendall_tau", "kendall_p", #"change_per_year", 
#                      "spearman_rho", "spearman_p", "significant")])


# Soil Moisture - all 
# cat("\n--- SOIL MOISTURE ---\n")
# swc_results <- test_seasonal_trends(seasonal_summary_all2, 
#                                      "SWC_3_mean", 
#                                      "Soil Moisture", 
#                                      "%")
# print(swc_results[, c("season", "mean_value", "normal", "slope", "slope_p", 
#                       "kendall_tau", "kendall_p", #"change_per_year", 
#                       "spearman_rho", "spearman_p", "significant")])

# Soil Moisture - no winter, TS3 > 2 
cat("\n--- SOIL MOISTURE ---\n")
swc_results <- test_seasonal_trends(seasonal_summary_all2, 
                                     "SWC_3_nf_mean", 
                                     "Soil Moisture", 
                                     "%")
print(swc_results[, c("season", "mean_value", "normal", "slope", "slope_p", 
                      "kendall_tau", "kendall_p", #"change_per_year", 
                      "spearman_rho", "spearman_p", "significant")])


# VPD
cat("\n--- VAPOR PRESSURE DEFICIT ---\n")
vpd_results <- test_seasonal_trends(seasonal_summary_all2, 
                                     "VPD_mean", 
                                     "VPD", 
                                     "hPa")
print(vpd_results[, c("season", "mean_value", "normal", "slope", "slope_p", 
                      "kendall_tau", "kendall_p", #"change_per_year", 
                      "spearman_rho", "spearman_p", "significant")])

# RH
cat("\n--- RH ---\n")
rh_results <- test_seasonal_trends(seasonal_summary_all2, 
                                     "RH_mean", 
                                     "RH", 
                                     "%")
print(rh_results[, c("season", "mean_value", "normal", "slope", "slope_p", 
                      "kendall_tau", "kendall_p", #"change_per_year", 
                      "spearman_rho", "spearman_p", "significant")])

# Sensible Heat
cat("\n--- SENSIBLE HEAT FLUX ---\n")
h_results <- test_seasonal_trends(seasonal_summary_all2, 
                                   "H_mean", 
                                   "Sensible Heat", 
                                   "W/m²")
print(h_results[, c("season", "mean_value", "normal", "slope", "slope_p", 
                    "kendall_tau", "kendall_p", #"change_per_year", 
                    "spearman_rho", "spearman_p", "significant")])

# Latent Heat
cat("\n--- LATENT HEAT FLUX ---\n")
le_results <- test_seasonal_trends(seasonal_summary_all2, 
                                    "LE_mean", 
                                    "Latent Heat", 
                                    "W/m²")
print(le_results[, c("season", "mean_value", "normal", "slope", "slope_p", 
                     "kendall_tau", "kendall_p", #"change_per_year", 
                     "spearman_rho", "spearman_p", "significant")])

# Ground Heat
cat("\n--- Ground HEAT FLUX ---\n")
g_results <- test_seasonal_trends(seasonal_summary_all2, 
                                    "G_mean", 
                                    "Ground Heat Flux", 
                                    "W/m²")
print(g_results[, c("season", "mean_value", "normal", "slope", "slope_p", 
                     "kendall_tau", "kendall_p", #"change_per_year", 
                     "spearman_rho", "spearman_p","significant")])

# ============================================================================
# COMBINE ALL RESULTS INTO ONE TABLE
# ============================================================================

all_results <- rbind(gf_ta_results, gf_ts_results,swc_results, 
                     vpd_results, rh_results, h_results, le_results, g_results) 
# ta_results, ts_results, 

all_results 


#Significant trends only summarized
significant_trends <- all_results %>%
  filter(significant %in% c("Yes*", "Yes**")) %>%
  select(variable, season, mean_value, units, #change_per_year, #percent_change_2017_2022
         slope, slope_p, kendall_tau, kendall_p, spearman_rho, spearman_p, significant)

if (nrow(significant_trends) > 0) {
  print(significant_trends)
} else {
  cat("No statistically significant trends detected at p < 0.05\n")
}


```


#Make table of all stats results 
```{r}
# Combine all results
all_results <- rbind(gf_ta_results, gf_ts_results, 
                     swc_results, vpd_results, rh_results, h_results, 
                     le_results, g_results)

# View the complete table
print(all_results)

# Select specific columns for cleaner presentation
supp_table <- all_results %>%
  select(variable, season, n_years, mean_value, units,
         slope, slope_se, slope_p, 
         adj_r_squared,
         kendall_tau, kendall_p,
         spearman_rho, spearman_p,
         shapiro_p, normal, significant) %>%
  arrange(variable, season)

supp_table

# Export to CSV
write.csv(supp_table, "C:/Users/kkent/Documents/Github Flux Network/Council_Flux_Analysis_Paper/Council Figures/winteryear_seasonal_met_trends_statistics", row.names = FALSE)

```


#Checking linear trends of variables that showed sig slopes per lm and/or kendall's tau (which is VPD, RH, possibly SWC)

#### note that here it's using an intercept based off of year = 0, when our first year is 2017...so the b/y-intercept here is wrong - use "year_c" to re-center onto 2017 as starting reference point


#******** TO DO: clean this code up, add the new stats to VPD/RH monotonic relationship figs * 


### LM - VPD
```{r}
#coding suggestion from claude: set year 2017 as the first year so the intercept is interpretable - called "Centering" so that the intercept is within the range of your data's range 
seasonal_summary_all2 <- seasonal_summary_all2 %>%
  mutate(winter_year_c = winter_year - 2017) #sets 2017 at year 0, aka starting point - if the intercept is important, use the variable year_c instead of year in the lm formula 

#VPD

#Across all seasons and years 
#want to use "year" (numeric) here, not year_factor 
vpd_lm = lm(formula = seasonal_summary_all2$VPD_mean ~ seasonal_summary_all2$winter_year, na.rm = TRUE)
summary(vpd_lm) 
#Results: slope = 0.7724, adj R2=0.4973, p = 0.000649

#Growing season 
vpd_lm_summer <- lm(VPD_mean ~ winter_year,
                data = seasonal_summary_all2,
                subset = season == "Growing Season")

summary(vpd_lm_summer)
#Results: slope = 0.81, adj R2 = 0.84, p = 0.00655 *SIG

#Fall
vpd_lm_fall <- lm(VPD_mean ~ winter_year,
                data = seasonal_summary_all2,
                subset = season == "Fall Senescence")

summary(vpd_lm_fall) #slope = 0.6255, adjR2 = 0.9466, p = 0.000694 *SIG

#Winter  
vpd_lm_winter <- lm(VPD_mean ~ winter_year,
                data = seasonal_summary_all2,
                subset = season == "Winter")

summary(vpd_lm_winter) # slope = 0.88, adjR2 = 0.412, p = 0.1009 not sig 
```

#LM - RH 
```{r}
#========== RH ==================

#Across all seasons and years 
rh_lm = lm(formula = seasonal_summary_all2$RH_mean ~ seasonal_summary_all2$winter_year, na.rm = TRUE)
summary(rh_lm) 
#Results: slope = -7.938, adj R2 = 0.5902 , p = 0.0001187 *SIG

#Growing season 
rh_lm_summer <- lm(RH_mean ~ winter_year,
                data = seasonal_summary_all2,
                subset = season == "Growing Season")

summary(rh_lm_summer)
#Results: slope = -6.59, adj R2 = 0.959, p = 0.00039 *SIG

#Fall
rh_lm_fall <- lm(RH_mean ~ winter_year,
                data = seasonal_summary_all2,
                subset = season == "Fall Senescence")

summary(rh_lm_fall) #slope = -7.52, adj R2 = 0.97, p = 0.000204 *SIG

#Winter
rh_lm_winter <- lm(RH_mean ~ winter_year,
                data = seasonal_summary_all2,
                subset = season == "Winter", na.rm = TRUE)

summary(rh_lm_winter) # slope = -9.702, adj R2 = 0.856, p = 0.00518 *SIG 
```

#LM - SWC (NF)
```{r}

#========== SWC (potentially borderline) ==================

#Across all seasons and years - SWC non-frozen
SWC_lm = lm(formula = seasonal_summary_all2$SWC_3_nf_mean ~ seasonal_summary_all2$winter_year)
summary(SWC_lm) 
#Results: slope = -1.3119, adj R2 = 0.1179, p = 0.141 - not sig 

#Growing season 
SWC_lm_summer <- lm(SWC_3_nf_mean ~ winter_year,
                data = seasonal_summary_all2,
                subset = season == "Growing Season")

summary(SWC_lm_summer)
#Results: slope = -1.903, adj R2 = 0.5417, p = 0.05825 *borderline sig*

#Fall
SWC_lm_fall <- lm(SWC_3_nf_mean ~ winter_year,
                data = seasonal_summary_all2,
                subset = season == "Fall Senescence")

summary(SWC_lm_fall) #slope = -0.7203, adjR2 = -0.056 (???), p = 0.4378  - not sig 

#Winter - NA for SWC nf because it excludes winter 
# SWC_lm_winter <- lm(SWC_3_nf_mean ~ winter_year,
#                 data = seasonal_summary_all2,
#                 subset = season == "Winter")
# 
# summary(SWC_lm_winter) # slope = -7.218, R2 = 0.572, p = 0.050 - not sig 
```

#LM - Air T

```{r}

#========== Air temp  ==================

#Across all seasons and years 
TA_lm = lm(formula = seasonal_summary_all2$TA_gapfilled_mean ~ seasonal_summary_all2$winter_year)
summary(TA_lm) 
#Results: slope = -0.3346, R2 = -0.05783, p = 0.79 - not sig 

#Growing season 
TA_lm_summer <- lm(TA_gapfilled_mean ~ winter_year,
                data = seasonal_summary_all2,
                subset = season == "Growing Season")

summary(TA_lm_summer)
#Results: slope = -0.1170, R2 = -0.1842, p = 0.66 - not sig 

#Fall
TA_lm_fall <- lm(TA_gapfilled_mean ~ winter_year,
                data = seasonal_summary_all2,
                subset = season == "Fall Senescence")

summary(TA_lm_fall) #slope = -0.1311, adj R2= -0.2256, p = 0.7919 - not sig  

#Winter
TA_lm_winter <- lm(TA_gapfilled_mean ~ winter_year,
                data = seasonal_summary_all2,
                subset = season == "Winter")

summary(TA_lm_winter) # slope = -0.7556, adj R2 = 0.3448, p = 0.129 - not sig 
```

# LM - TS_3

```{r}

#========== TS_3 ==================

#Across all seasons and years 
TS_lm = lm(formula = seasonal_summary_all2$TS_3_gapfilled_mean ~ seasonal_summary_all2$winter_year)
summary(TS_lm) 
#Results: slope = 0.01875, R2 = -0.062, p = 0.974 - not sig 

#Growing season 
TS_lm_summer <- lm(TS_3_gapfilled_mean ~ winter_year,
                data = seasonal_summary_all2,
                subset = season == "Growing Season")

summary(TS_lm_summer)
#Results: slope = 0.1829, R2 = -0.1354, p = 0.5597 - not sig 

#Fall
TS_lm_fall <- lm(TS_3_gapfilled_mean ~ winter_year,
                data = seasonal_summary_all2,
                subset = season == "Fall Senescence")

summary(TS_lm_fall) #slope = 0.0228 R2 = -0.2489, p = 0.9553 - not sig 

#Winter
TS_lm_winter <- lm(TS_3_gapfilled_mean ~ winter_year,
                data = seasonal_summary_all2,
                subset = season == "Winter")

summary(TS_lm_winter) # slope = -0.149, R2 = -0.0798, p = 0.4717  not sig 

```
#Checking normality / homogeneity again of the lm models that showed sig p 


#### RH - all seasons  
```{r}
library(car)
library(nlme)
library(lme4)

#Winter - some NA's in RH, 2021 winter missing 

rh_lm_winter2 <- lm(RH_mean ~ winter_year,
                   data = seasonal_summary_all2,
                   subset = season == "Winter",
                   na.action = na.exclude)

# Extract fitted values and residuals
fitted_values <- fitted(rh_lm_winter2)
residuals <- residuals(rh_lm_winter2)


# Graphical assessment
par(mfrow = c(1, 2))
# Histogram of residuals
hist(residuals, main = "Histogram of Standardized Residuals", 
     xlab = "Standardized Residuals", freq = FALSE)
curve(dnorm, add = TRUE, col = "red")

# QQ plot
qqnorm(residuals, main = "Normal Q-Q Plot")
qqline(residuals, col = "red")

# Formal test
shapiro_test <- shapiro.test(residuals)
print(shapiro_test) #p=0.07 - ok 


# Plot residuals vs. predictor

ggplot(seasonal_summary_all2 %>% filter(season == "Winter"), 
       aes(x = RH_mean, y = residuals)) +
  geom_point() +
  geom_hline(yintercept = 0, linetype = "dashed") +
  labs(x = "Cont. Pred. Var",
       y = "Residuals",
       title = "Residuals vs. Predictor Var") +
  theme_bw()

# Create a scale-location plot --> should be randomly scattered with a relatively flat trend line (red) for homogeneity of variance 
plot(rh_lm_winter, which = 3)


#Breusch-Pagan test - specifically tests if variance of residuals is constant - want a p > 0.05 for homogeneity of var
library(lmtest)
bptest(rh_lm_winter) #p=0.0.619 -ok 


#================================================================================
#Growing Season 
#=================================================================================

# Extract fitted values and residuals
fitted_values <- fitted(rh_lm_summer)
residuals <- residuals(rh_lm_summer)


# Graphical assessment
par(mfrow = c(1, 2))
# Histogram of residuals
hist(residuals, main = "Histogram of Standardized Residuals", 
     xlab = "Standardized Residuals", freq = FALSE)
curve(dnorm, add = TRUE, col = "red")

# QQ plot
qqnorm(residuals, main = "Normal Q-Q Plot")
qqline(residuals, col = "red")

# Formal test
shapiro_test <- shapiro.test(residuals)
print(shapiro_test) #p=0.837 - ok


# Plot residuals vs. predictor

ggplot(seasonal_summary_all2 %>% filter(season == "Growing Season"), 
       aes(x = RH_mean, y = residuals)) +
  geom_point() +
  geom_hline(yintercept = 0, linetype = "dashed") +
  labs(x = "Cont. Pred. Var",
       y = "Residuals",
       title = "Residuals vs. Predictor Var") +
  theme_bw()

# Create a scale-location plot --> should be randomly scattered with a relatively flat trend line (red) for homogeneity of variance 
plot(rh_lm_summer , which = 3)


#Breusch-Pagan test - specifically tests if variance of residuals is constant - want a p > 0.05 for homogeneity of var
library(lmtest)
bptest(rh_lm_summer ) #p=0.047 - NOT OK ** 


#================================================================================
# FALL
#=================================================================================

# Extract fitted values and residuals
fitted_values <- fitted(rh_lm_fall)
residuals <- residuals(rh_lm_fall)


# Graphical assessment
par(mfrow = c(1, 2))
# Histogram of residuals
hist(residuals, main = "Histogram of Standardized Residuals", 
     xlab = "Standardized Residuals", freq = FALSE)
curve(dnorm, add = TRUE, col = "red")

# QQ plot
qqnorm(residuals, main = "Normal Q-Q Plot")
qqline(residuals, col = "red")

# Formal test
shapiro_test <- shapiro.test(residuals)
print(shapiro_test) #p=0.88 - ok but QQ plot does NOT look ok


# Plot residuals vs. predictor

ggplot(seasonal_summary_all %>% filter(season == "Fall Senescence"), 
       aes(x = RH_mean, y = residuals)) +
  geom_point() +
  geom_hline(yintercept = 0, linetype = "dashed") +
  labs(x = "Cont. Pred. Var",
       y = "Residuals",
       title = "Residuals vs. Predictor Var") +
  theme_bw()

# Create a scale-location plot --> should be randomly scattered with a relatively flat trend line (red) for homogeneity of variance 
plot(rh_lm_fall, which = 3)


#Breusch-Pagan test - specifically tests if variance of residuals is constant - want a p > 0.05 for homogeneity of var
library(lmtest)
bptest(rh_lm_fall ) #p=0.068, ok, but the visuals don't look very good 

```
#VPD - growing and fall seasons 
```{r}

#================================================================================
#Growing Season 
#=================================================================================

# Extract fitted values and residuals
fitted_values <- fitted(vpd_lm_summer)
residuals <- residuals(vpd_lm_summer)


# Graphical assessment
par(mfrow = c(1, 2))
# Histogram of residuals
hist(residuals, main = "Histogram of Standardized Residuals", 
     xlab = "Standardized Residuals", freq = FALSE)
curve(dnorm, add = TRUE, col = "red")

# QQ plot
qqnorm(residuals, main = "Normal Q-Q Plot")
qqline(residuals, col = "red")

# Formal test
shapiro_test <- shapiro.test(residuals)
print(shapiro_test) #p=0.72 - ok


# Plot residuals vs. predictor

ggplot(seasonal_summary_all2 %>% filter(season == "Growing Season"), 
       aes(x = VPD_mean, y = residuals)) +
  geom_point() +
  geom_hline(yintercept = 0, linetype = "dashed") +
  labs(x = "Cont. Pred. Var",
       y = "Residuals",
       title = "Residuals vs. Predictor Var") +
  theme_bw()

# Create a scale-location plot --> should be randomly scattered with a relatively flat trend line (red) for homogeneity of variance 
plot(vpd_lm_summer , which = 3)


#Breusch-Pagan test - specifically tests if variance of residuals is constant - want a p > 0.05 for homogeneity of var
library(lmtest)
bptest(vpd_lm_summer ) #p=0.63 - ok 


#================================================================================
# FALL
#=================================================================================

# Extract fitted values and residuals
fitted_values <- fitted(vpd_lm_fall)
residuals <- residuals(vpd_lm_fall)


# Graphical assessment
par(mfrow = c(1, 2))
# Histogram of residuals
hist(residuals, main = "Histogram of Standardized Residuals", 
     xlab = "Standardized Residuals", freq = FALSE)
curve(dnorm, add = TRUE, col = "red")

# QQ plot
qqnorm(residuals, main = "Normal Q-Q Plot")
qqline(residuals, col = "red")

# Formal test
shapiro_test <- shapiro.test(residuals)
print(shapiro_test) #p=0.92 - ok


# Plot residuals vs. predictor

ggplot(seasonal_summary_all2 %>% filter(season == "Fall Senescence"), 
       aes(x = VPD_mean, y = residuals)) +
  geom_point() +
  geom_hline(yintercept = 0, linetype = "dashed") +
  labs(x = "Cont. Pred. Var",
       y = "Residuals",
       title = "Residuals vs. Predictor Var") +
  theme_bw()

# Create a scale-location plot --> should be randomly scattered with a relatively flat trend line (red) for homogeneity of variance 
plot(vpd_lm_fall, which = 3)


#Breusch-Pagan test - specifically tests if variance of residuals is constant - want a p > 0.05 for homogeneity of var
library(lmtest)
bptest(vpd_lm_fall ) #p = 0.75, ok 

```


#### SWC nf - growing season, borderline sig 
```{r}

#growing season 

# Extract fitted values and residuals
fitted_values <- fitted(SWC_lm_summer)
residuals <- residuals(SWC_lm_summer)


# Graphical assessment
par(mfrow = c(1, 2))
# Histogram of residuals
hist(residuals, main = "Histogram of Standardized Residuals", 
     xlab = "Standardized Residuals", freq = FALSE)
curve(dnorm, add = TRUE, col = "red")

# QQ plot
qqnorm(residuals, main = "Normal Q-Q Plot")
qqline(residuals, col = "red")

# Formal test
shapiro_test <- shapiro.test(residuals)
print(shapiro_test) #p=0.72 - ok


# Plot residuals vs. predictor

ggplot(seasonal_summary_all2 %>% filter(season == "Growing Season"), 
       aes(x = SWC_3_nf_mean, y = residuals)) +
  geom_point() +
  geom_hline(yintercept = 0, linetype = "dashed") +
  labs(x = "Cont. Pred. Var",
       y = "Residuals",
       title = "Residuals vs. Predictor Var") +
  theme_bw()

# Create a scale-location plot --> should be randomly scattered with a relatively flat trend line (red) for homogeneity of variance 
plot(SWC_lm_summer, which = 3)


#Breusch-Pagan test - specifically tests if variance of residuals is constant - want a p > 0.05 for homogeneity of var
library(lmtest)
bptest(SWC_lm_summer) #p=0.3532 ok 

```




#VPD with stats 
```{r}

library(ggpmisc)  # For adding equation and stats to plots


# VPD - Shows trends in all seasons 
p_VPD_with_stats <- ggplot(seasonal_summary_all %>%
                             filter(winter_year != "2016"), 
                           aes(x = winter_year, y = VPD_mean, color = winteryear_factor)) +
  geom_hline(yintercept = 0, color = "black", linewidth = 0.5) +
  geom_point(size = 2.5) +
  geom_errorbar(aes(ymin = VPD_mean - VPD_se, 
                    ymax = VPD_mean + VPD_se),
                width = 0.2, linewidth = 0.8) +
  
  # Add trend line
  geom_smooth(aes(group = season), method = "lm", se = TRUE, 
              color = "black", linewidth = 0.8, alpha = 0.2) +
  
  # Add R² and p-value
  # stat_poly_eq(aes(label = paste(after_stat(eq.label),
  #                                  after_stat(rr.label),
  #                                  after_stat(p.value.label),
  #                                  sep = "~~~")),
  stat_poly_eq(aes(label = after_stat(paste("atop(", 
                                           eq.label, ",", 
                                           "atop(", adj.rr.label, ",", 
                                           p.value.label, "))"))),
               formula = y ~ x,
               parse = TRUE,
               size = 4,
               color = "black") +
  
  facet_wrap(~ season, ncol = 3) +
  
  scale_color_manual(
    values = c("2017" = "#1f77b4", "2018" = "#ff7f0e", "2019" = "#2ca02c", 
               "2020" = "#d62728", "2021" = "#9467bd", "2022" = "#8c564b"),
    name = "Year"
  ) +
  
  scale_x_continuous(breaks = 2017:2022) +
  
  labs(x = "Year", y = "VPD (hPa)") +
  theme_bw() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"),
    axis.text.y = element_text(face = "bold"),
    axis.title = element_text(face = "bold"),
    strip.text = element_text(face = "bold"),
    legend.position = "none"
  )


p_VPD_with_stats
```





#RH with stats 

```{r}
# VPD - Shows trends in all seasons 
p_RH_with_stats <- ggplot(seasonal_summary_all, aes(x = year_c, y = RH_mean, color = year_factor)) +
  geom_hline(yintercept = 0, color = "black", linewidth = 0.5) +
  geom_point(size = 2.5) +
  geom_errorbar(aes(ymin = RH_mean - RH_se, 
                    ymax = RH_mean + RH_se),
                width = 0.2, linewidth = 0.8) +
  
  # Add trend line
  geom_smooth(aes(group = season), method = "lm", se = TRUE, 
              color = "black", linewidth = 0.8, alpha = 0.2) +
  
  # Add R² and p-value
  # stat_poly_eq(aes(label = paste(after_stat(eq.label),
  #                                  after_stat(rr.label),
  #                                  after_stat(p.value.label),
  #                                  sep = "~~~")),
  stat_poly_eq(aes(label = after_stat(paste("atop(", 
                                           eq.label, ",", 
                                           "atop(", adj.rr.label, ",", 
                                           p.value.label, "))"))),
               formula = y ~ x,
               parse = TRUE,
               size = 4,
               color = "black") +
  
  facet_wrap(~ season, ncol = 3) +
  
  scale_color_manual(
    values = c("2017" = "#1f77b4", "2018" = "#ff7f0e", "2019" = "#2ca02c", 
               "2020" = "#d62728", "2021" = "#9467bd", "2022" = "#8c564b"),
    name = "Year"
  ) +
  
  scale_x_continuous(breaks = 2017:2022) +
  
  labs(x = "Year", y = "RH (%)") +
  theme_bw() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"),
    axis.text.y = element_text(face = "bold"),
    axis.title = element_text(face = "bold"),
    strip.text = element_text(face = "bold"),
    legend.position = "none"
  )


p_RH_with_stats
```










#Manual annotations of stats for each panel 


#VPD - Annotating each panel - code from Claude - fixed with corrected Mann-Kendall test 10.14.2025
```{r}
#Best way to add unique text to each panel in the facet_wrapped figure is to create a dataframe with the info you want to add to each panel 

library(ggh4x) #allow customizing facet panel axis labels 

# Create a dataframe with statistics for each season
vpd_stats <- data.frame(
  season = c("Growing Season", "Fall Senescence"), #order of labels for panels in facetwrap
  r2 = c(0.84, 0.95),  # Replace with your actual adj R² values - Fall, Growing, Winter 
  slope = c(0.81, 0.63),  # Replace with your actual slopes - Fall, Growing, Winter 
  p_value = c(0.0066, 0.0007),  # Replace with your actual p-values - Fall, Growing, Winter 
  #mann_kendall_p = c(0.027, 0.024),
  #mann_kendall_tau = c(1.00, 0.87),
  x = c(2017, 2017),  # x position for text
  y = c(10, 10)  # y position for text - adjust based on your data range
)

# Create labels
vpd_stats <- vpd_stats %>%
  mutate(season_ordered = factor(season,
                                levels = c("Growing Season", "Fall Senescence")),
    label = paste0("adj R² = ", round(r2, 2), "\n",
                    "Slope = ", round(slope, 2), "\n",
                    "p = ", ifelse(p_value < 0.001, "< 0.001", sprintf("%.3f", p_value))
                        #"LM_p = ", format.pval(p_value, digits = 3), "\n",
                        #"Mann-Kendall_tau =", round(mann_kendall_tau, 2), "\n",
                        #"Mann-Kendall_p =", format.pval(mann_kendall_p, digits = 3)))
  )) 

# Add to plot
p_VPD_lm <- ggplot(seasonal_summary_all %>%
                     filter(winter_year != "2016", winter_year != "2023", season != "Winter") %>%
                     mutate(season_ordered = factor(season,
                                                    levels = c("Growing Season", "Fall Senescence"))),
                   aes(x = winter_year, y = VPD_mean, color = winteryear_factor)) +
  geom_hline(yintercept = 0, color = "black", linewidth = 0.5) +
  geom_point(size = 2.5) +
  geom_errorbar(aes(ymin = VPD_mean - VPD_se, 
                    ymax = VPD_mean + VPD_se),
                width = 0.2, linewidth = 0.8, color = "black") +
  
  # Add trend line
  geom_smooth(aes(group = season), method = "lm", se = TRUE, 
              color = "black", linewidth = 0.8, alpha = 0.2) +
  
  # Add manual annotations
  geom_text(data = vpd_stats , 
            aes(x = x, y = y, label = label),
            color = "black", size = 4, hjust = 0, vjust = 1,
            inherit.aes = FALSE) +
#facet_wrap(~factor(season, levels = c("Growing Season", "Fall Senescence", "Winter")), ncol = 3, scales = "free_x") + #sets order of panels, opens x-axis to being customizable 
  facet_wrap(~season_ordered, ncol = 2, scales = "free_x") + 
  
   #custom axis labels that are different among the panels 
  facetted_pos_scales( 
    x = list(
      season_ordered == "Growing Season" ~ scale_x_continuous(breaks = 2017:2022),
      season_ordered == "Fall Senescence" ~ scale_x_continuous(breaks = 2017:2022)
      # season_ordered == "Winter" ~ scale_x_continuous(breaks = 2017:2022, 
      #                                          labels = c("2017 - 2018", "2018 - 2019", 
      #                                                    "2019 - 2020", "2020 - 2021", 
      #                                                    "2021 - 2022", "2022 - 2023"))
    )
  ) +
  
  scale_color_manual(
    values = c("2017" = "#1f77b4", "2018" = "#ff7f0e", "2019" = "#2ca02c", 
               "2020" = "#d62728", "2021" = "#9467bd", "2022" = "#8c564b"),
    name = "Year"
  ) +
  

  labs(x = "Year", y = "VPD (hPa)") +
  theme_bw() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    axis.title.x = element_text(face = "bold", size = 12),
    axis.title.y = element_text(face = "bold", size = 12),
    axis.text.x = element_text(angle = 45, hjust = 1, face = "bold", size = 12),
    axis.text.y = element_text(face = "bold", size = 12),
    strip.text = element_text(face = "bold", size = 12), #titles for panels 
    legend.position = "none"
  )

p_VPD_lm
```

#Save figure 
```{r}

ggsave("C:/Users/kkent/Documents/Github Flux Network/Council_Flux_Analysis_Paper/Council Figures/winteryear_VPD_trends_stats.png", p_VPD_lm, 
        width = 7, height = 5, dpi = 600)
```

#RH - Annotating each panel - code from Claude - updated with corrected Mann-Kendall test for timeseries 
```{r}
#Best way to add unique text to each panel in the facet_wrapped figure is to create a dataframe with the info you want to add to each panel 

# Create a dataframe with statistics for each season
rh_stats <- data.frame(
  season = c("Growing Season", "Fall Senescence", "Winter"),
  r2 = c(0.96, 0.97, 0.86),  # Replace with your actual adj R² values - Fall, Growing, Winter 
  slope = c(-6.59, -7.52, -9.70),  # Replace with your actual slopes - Fall, Growing, Winter 
  p_value = c(0.0004, 0.0002, 0.005),  # Replace with your actual p-values - Fall, Growing, Winter 
 # mann_kendall_p = c(0.01, 0.01, 0.01),
 # mann_kendall_tau = c(-1.00, -1.00, -1.00),
  x = c(2018, 2018, 2018),  # x position for text
  y = c(100, 100, 100)  # y position for text - adjust based on your data range
)

# Create labels
rh_stats <- rh_stats %>%
  mutate(season_ordered = factor(season,
                          levels = c("Growing Season", "Fall Senescence", "Winter")),
    label = paste0(#"adj R² = ", round(r2, 2), "\n",
                        #"Slope = ", round(slope, 2), "\n",
                        "adj R² = ", r2, "\n",
                        "Slope = ", slope, "\n",
                         "p = ", ifelse(p_value < 0.001, "< 0.001", sprintf("%.3f", p_value))
                       # "p = ", format.pval(p_value, digits = 1, eps = 0.001)
                       # "LM_p = ", format.pval(p_value, digits = 4, scientific = FALSE) #, "\n", 
                       # "Mann-Kendall_tau =", round(mann_kendall_tau, 2), "\n",
                       # "Mann-Kendall_p =", format.pval(mann_kendall_p, digits = 4)
                       ))

# Add to plot
p_rh_lm <- ggplot(seasonal_summary_all %>%
                    filter(winter_year != "2016", winter_year != "2023") %>%
                     mutate(season_ordered = factor(season,
                                                    levels = c("Growing Season", "Fall Senescence", "Winter"))),
                  aes(x = winter_year, y = RH_mean, color = winteryear_factor)) +
  geom_hline(yintercept = 0, color = "black", linewidth = 0.5) +
  geom_point(size = 2.5) +
  geom_errorbar(aes(ymin = RH_mean - RH_se, 
                    ymax = RH_mean + RH_se),
                width = 0.2, linewidth = 0.8, color = "black") +
  
  # Add trend line
  geom_smooth(aes(group = season), method = "lm", se = TRUE, 
              color = "black", linewidth = 0.8, alpha = 0.2) +
  
  # Add manual annotations
  geom_text(data = rh_stats, 
            aes(x = x, y = y, label = label),
            color = "black", size = 4, hjust = 0, vjust = 1,
            inherit.aes = FALSE) +
  
#facet_wrap(~factor(season, levels = c("Winter", "Growing Season", "Fall Senescence")), ncol = 3)+
  facet_wrap(~season_ordered, ncol = 3, scales = "free_x") + 

   #custom axis labels that are different among the panels 
  facetted_pos_scales( 
    x = list(
      season_ordered == "Growing Season" ~ scale_x_continuous(breaks = 2017:2022),
      season_ordered == "Fall Senescence" ~ scale_x_continuous(breaks = 2017:2022),
      season_ordered == "Winter" ~ scale_x_continuous(breaks = 2017:2022, 
                                               labels = c("2017 - 2018", "2018 - 2019", 
                                                         "2019 - 2020", "2020 - 2021", 
                                                         "2021 - 2022", "2022 - 2023"))
    )
  ) +
  
  scale_color_manual(
    values = c("2017" = "#1f77b4", "2018" = "#ff7f0e", "2019" = "#2ca02c", 
               "2020" = "#d62728", "2021" = "#9467bd", "2022" = "#8c564b"),
    name = "Year"
  ) +
  
  #scale_x_continuous(breaks = 2017:2022) +
  
  labs(x = "Year", y = "RH (%)") +
  theme_bw() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    axis.title.x = element_text(face = "bold", size = 12),
    axis.title.y = element_text(face = "bold", size = 12),
    axis.text.x = element_text(angle = 45, hjust = 1, face = "bold", size = 12),
    axis.text.y = element_text(face = "bold", size = 12),
    strip.text = element_text(face = "bold", size = 12), #titles for panels 
    legend.position = "none"
  )

p_rh_lm
```


#Save figure 

```{r}

ggsave("C:/Users/kkent/Documents/Github Flux Network/Council_Flux_Analysis_Paper/Council Figures/winteryear_RH_trends_stats.png", p_rh_lm, 
        width = 7, height = 5, dpi = 600) 
```

#* TO DO SWC in growing with borderline sig 

#SWC-NF borderline sig  
```{r}
#Best way to add unique text to each panel in the facet_wrapped figure is to create a dataframe with the info you want to add to each panel 

# Create a dataframe with statistics for each season
swc_nf_stats <- data.frame(
  season = c("Growing Season"),
  r2 = c(0.54),  # Replace with your actual adj R² values - Fall, Growing, Winter 
  slope = c(-1.90),  # Replace with your actual slopes - Fall, Growing, Winter 
  p_value = c(0.06),  # Replace with your actual p-values - Fall, Growing, Winter 
 # mann_kendall_p = c(0.13),
 # mann_kendall_tau = c(-0.60),
  x = c(2017),  # x position for text
  y = c(100)  # y position for text - adjust based on your data range
)

# Create labels
swc_nf_stats <- swc_nf_stats %>%
    mutate(label = paste0(#"adj R² = ", round(r2, 2), "\n",
                        #"Slope = ", round(slope, 2), "\n",
                        "adj R² = ", r2, "\n",
                        "Slope = ", slope, "\n",
                         "p = ", ifelse(p_value < 0.001, "< 0.001", sprintf("%.2f", p_value))))
                       # "p = ", format.pval(p_value, digits = 1, eps = 0.001)
                       # "LM_p = ", format.pval(p_value, digits = 4, scientific = FALSE) #, "\n", 
                       # "Mann-Kendall_tau =", round(mann_kendall_tau, 2), "\n",
                       # "Mann-Kendall_p =", format.pval(mann_kendall_p, digits = 4)
                       

# Add to plot
p_swc_nf_lm <- ggplot(seasonal_summary_all %>%
                    filter(winter_year != "2016", winter_year != "2023",
                           season == "Growing Season"), #add filter to only plot growing season 
                     aes(x = winter_year, y = SWC_3_nf_mean, color = winteryear_factor)) +
  geom_hline(yintercept = 0, color = "black", linewidth = 0.5) +
  geom_point(size = 2.5) +
  geom_errorbar(aes(ymin = SWC_3_nf_mean - SWC_3_nf_se, 
                    ymax = SWC_3_nf_mean + SWC_3_nf_se),
                width = 0.2, linewidth = 0.8, color = "black") +
  
  # Add trend line
  geom_smooth(method = "lm", se = TRUE, 
              color = "black", linewidth = 0.8, alpha = 0.2) +
  
  # Add manual annotations
  geom_text(data = swc_nf_stats, 
            aes(x = x, y = y, label = label),
            color = "black", size = 4, hjust = 0, vjust = 1,
            inherit.aes = FALSE) +
  

  scale_color_manual(
    values = c("2017" = "#1f77b4", "2018" = "#ff7f0e", "2019" = "#2ca02c", 
               "2020" = "#d62728", "2021" = "#9467bd", "2022" = "#8c564b"),
    name = "Year"
  ) +
  
  scale_x_continuous(breaks = 2017:2022) +
  
  labs(x = "Year", y = "SWC (%)") +
  theme_bw() +
  labs(title = "Growing Season") +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    axis.title.x = element_text(face = "bold", size = 12),
    axis.title.y = element_text(face = "bold", size = 12),
    axis.text.x = element_text(angle = 45, hjust = 1, face = "bold", size = 12),
    axis.text.y = element_text(face = "bold", size = 12),
    strip.text = element_text(face = "bold", size = 12), #titles for panels 
    legend.position = "none"
  )

p_swc_nf_lm
```

#Save figure 

```{r}

ggsave("C:/Users/kkent/Documents/Github Flux Network/Council_Flux_Analysis_Paper/Council Figures/winteryear_SWC.nf_trends_stats.png", p_swc_nf_lm, 
        width = 7, height = 5, dpi = 600) 
```



#Mann-Kendall timeseries analysis - streamlined function code from Claude with lm, mann-kendall, & spearman corr checks for cross-referencing and comparisons 


####Correcting the kendall's rank corr to mann-kendall test for timeseries data 

```{r}
# Tests for significant trends in environmental variables by season (2017-2022)
#
install.packages("trend")

library(dplyr)
library(broom)
library(Kendall)  # For proper Mann-Kendall timeseries test
library(trend)    # for sens.slope, the non-parametric version of a slope from lm  (zyp package is an alternative)

seasonal_summary_all <- seasonal_summary_all %>%
  filter(winter_year != "2023", winter_year != "2016")


# ============================================================================
# FUNCTION: Test trends for a variable within each season
# ============================================================================

test_seasonal_trends <- function(data, var_name, var_label, units) {
  
  results_list <- list()
  seasons <- unique(data$season)
  
  for (s in seasons) {
    season_data <- data %>% filter(season == s) %>% arrange(winter_year)  # Ensure temporal order!
    
    # Extract variable values
    y_vals <- season_data[[var_name]]
    x_vals <- season_data$winter_year
    
    # Skip if too many NAs
    if (sum(!is.na(y_vals)) < 4) {
      next
    }
    
    # Linear regression
    lm_model <- lm(y_vals ~ x_vals)
    lm_summary <- summary(lm_model)
    
    # Test normality of RESIDUALS (not raw data)
    residuals_vals <- residuals(lm_model)
    shapiro_p <- shapiro.test(residuals_vals)$p.value
    
    # Extract key statistics from linear model
    slope <- coef(lm_model)[2]
    slope_se <- summary(lm_model)$coefficients[2, 2]
    slope_p <- summary(lm_model)$coefficients[2, 4]
    r_squared <- lm_summary$r.squared
    adj_r_squared <- lm_summary$adj.r.squared
    
    # PROPER Mann-Kendall test for temporal trends
    mk_test <- MannKendall(y_vals)
    mk_tau <- as.numeric(mk_test$tau)
    mk_p <- as.numeric(mk_test$sl)  # significance level (p-value)
    
    # Spearman correlation (alternative non-parametric option)
    spearman_test <- cor.test(x_vals, y_vals, method = "spearman")
    spearman_rho <- spearman_test$estimate
    spearman_p <- spearman_test$p.value
    
    # # Sen's slope (robust trend estimator, pairs well with Mann-Kendall)
    # sens_slope <- NA
    # tryCatch({
    #   sens_test <- sens.slope(y_vals)
    #   sens_slope <- as.numeric(sens_test$estimates)
    # }, error = function(e) {
    #   sens_slope <- NA
    # })
    
    # Sen's slope adjustment for if there may be NAs in dataset 
    sens_slope <- NA
    tryCatch({
      # Remove NAs before calculating Sen's slope
      y_clean <- y_vals[!is.na(y_vals)]
      if(length(y_clean) >= 3) {  # Need at least 3 observations
        sens_test <- sens.slope(y_clean)
        sens_slope <- as.numeric(sens_test$estimates)
      }
    }, error = function(e) {
      # If trend package doesn't work, try zyp package as alternative
      tryCatch({
        if(requireNamespace("zyp", quietly = TRUE)) {
          y_clean <- y_vals[!is.na(y_vals)]
          sens_result <- zyp::zyp.sen(y_clean ~ seq_along(y_clean))
          sens_slope <- as.numeric(coef(sens_result)[2])
        }
      }, error = function(e2) {
        cat("Warning: Sen's slope failed for", var_label, "in", s, "\n")
      })
    })
    
    # Store results
    results_list[[s]] <- data.frame(
      season = s,
      variable = var_label,
      units = units,
      n_years = length(y_vals),
      mean_value = mean(y_vals, na.rm = TRUE),
      
      # Normality test
      shapiro_p = shapiro_p,
      normal = ifelse(shapiro_p > 0.05, "Yes", "No"),
      
      # Linear model (parametric)
      slope = slope,
      slope_se = slope_se,
      slope_p = slope_p,
      r_squared = r_squared,
      adj_r_squared = adj_r_squared,
      
      # Non-parametric tests
      mann_kendall_tau = mk_tau,
      mann_kendall_p = mk_p,
      sens_slope = sens_slope,
      spearman_rho = spearman_rho,
      spearman_p = spearman_p,
      
      # Significance (using appropriate test)
      significant = ifelse(shapiro_p > 0.05, 
                          ifelse(slope_p < 0.05, "Yes*", "No"),
                          ifelse(mk_p < 0.05, "Yes**", "No")),
      recommended_test = ifelse(shapiro_p > 0.05, 
                               "Linear Regression", 
                               "Mann-Kendall"),
      
      stringsAsFactors = FALSE
    )
  }
  
  # Combine all seasons
  do.call(rbind, results_list)
}

# ============================================================================
# RUN TESTS FOR ALL VARIABLES
# ============================================================================

cat("============================================================\n")
cat("ANNUAL TREND ANALYSIS BY SEASON (2017-2022)\n")
cat("============================================================\n\n")

cat("Significance codes:\n")
cat("* = Linear regression (residuals normal)\n")
cat("** = Mann-Kendall test (residuals non-normal)\n")
cat("p < 0.05 = significant trend\n\n")

# GF Air Temperature
cat("\n--- AIR TEMPERATURE (Gap-filled) ---\n")
gf_ta_results <- test_seasonal_trends(seasonal_summary_all, 
                                    "TA_gapfilled_mean", 
                                    "GF Air Temperature", 
                                    "°C")
print(gf_ta_results[, c("season", "mean_value", "normal", "slope", "slope_p", 
                     "mann_kendall_tau", "mann_kendall_p", "sens_slope", "spearman_rho",                                "spearman_p", "recommended_test", "significant")])



# Air Temperature (measured)
cat("\n--- AIR TEMPERATURE (measured) ---\n")
ta_results <- test_seasonal_trends(seasonal_summary_all, 
                                    "TA_mean", 
                                    "Air Temperature", 
                                    "°C")
print(ta_results[, c("season", "mean_value", "normal", "slope", "slope_p", 
                     "mann_kendall_tau", "mann_kendall_p", "sens_slope", "spearman_rho",                                "spearman_p", "recommended_test", "significant")])

# GF Soil Temperature
cat("\n--- SOIL TEMPERATURE (Gap-filled) ---\n")
gf_ts_results <- test_seasonal_trends(seasonal_summary_all, 
                                    "TS_3_gapfilled_mean", 
                                    "GF Soil Temperature", 
                                    "°C")
print(gf_ts_results[, c("season", "mean_value", "normal", "slope", "slope_p", 
                     "mann_kendall_tau", "mann_kendall_p", "sens_slope", "spearman_rho",                                "spearman_p", "recommended_test", "significant")])

# Soil Temperature (measured)
cat("\n--- SOIL TEMPERATURE ---\n")
ts_results <- test_seasonal_trends(seasonal_summary_all, 
                                    "TS_3_mean", 
                                    "Soil Temperature", 
                                    "°C")
print(ts_results[, c("season", "mean_value", "normal", "slope", "slope_p", 
                     "mann_kendall_tau", "mann_kendall_p", "sens_slope", "spearman_rho",                                "spearman_p", "recommended_test", "significant")])

# Soil Moisture - all 
cat("\n--- SOIL MOISTURE ---\n")
swc_results <- test_seasonal_trends(seasonal_summary_all, 
                                     "SWC_3_mean", 
                                     "Soil Moisture", 
                                     "%")
print(swc_results[, c("season", "mean_value", "normal", "slope", "slope_p", 
                     "mann_kendall_tau", "mann_kendall_p", "sens_slope", "spearman_rho",                                "spearman_p", "recommended_test", "significant")])

# Soil Moisture - NF
cat("\n--- SOIL MOISTURE ---\n")
swc_nf_results <- test_seasonal_trends(seasonal_summary_all, 
                                     "SWC_3_nf_mean", 
                                     "Soil Moisture (NF)", 
                                     "%")
print(swc_results[, c("season", "mean_value", "normal", "slope", "slope_p", 
                     "mann_kendall_tau", "mann_kendall_p", "sens_slope", "spearman_rho",                                "spearman_p", "recommended_test", "significant")])

# VPD
cat("\n--- VAPOR PRESSURE DEFICIT ---\n")
vpd_results <- test_seasonal_trends(seasonal_summary_all, 
                                     "VPD_mean", 
                                     "VPD", 
                                     "hPa")
print(vpd_results[, c("season", "mean_value", "normal", "slope", "slope_p", 
                     "mann_kendall_tau", "mann_kendall_p", "sens_slope", "spearman_rho",                                "spearman_p", "recommended_test", "significant")])

# RH
cat("\n--- RH ---\n")
rh_results <- test_seasonal_trends(seasonal_summary_all, 
                                     "RH_mean", 
                                     "RH", 
                                     "%")
print(rh_results[, c("season", "mean_value", "normal", "slope", "slope_p", 
                     "mann_kendall_tau", "mann_kendall_p", "sens_slope", "spearman_rho",                                "spearman_p", "recommended_test", "significant")])

# Sensible Heat
cat("\n--- SENSIBLE HEAT FLUX ---\n")
h_results <- test_seasonal_trends(seasonal_summary_all, 
                                   "H_mean", 
                                   "Sensible Heat", 
                                   "W/m²")
print(h_results[, c("season", "mean_value", "normal", "slope", "slope_p", 
                     "mann_kendall_tau", "mann_kendall_p", "sens_slope", "spearman_rho",                                "spearman_p", "recommended_test", "significant")])

# Latent Heat
cat("\n--- LATENT HEAT FLUX ---\n")
le_results <- test_seasonal_trends(seasonal_summary_all, 
                                    "LE_mean", 
                                    "Latent Heat", 
                                    "W/m²")
print(le_results[, c("season", "mean_value", "normal", "slope", "slope_p", 
                     "mann_kendall_tau", "mann_kendall_p", "sens_slope", "spearman_rho",                                "spearman_p", "recommended_test", "significant")])

# Ground Heat
cat("\n--- GROUND HEAT FLUX ---\n")
g_results <- test_seasonal_trends(seasonal_summary_all, 
                                    "G_mean", 
                                    "Ground Heat Flux", 
                                    "W/m²")
print(g_results[, c("season", "mean_value", "normal", "slope", "slope_p", 
                     "mann_kendall_tau", "mann_kendall_p", "sens_slope", "spearman_rho",                                "spearman_p", "recommended_test", "significant")])

# ============================================================================
# COMBINE ALL RESULTS INTO ONE TABLE
# ============================================================================

all_results <- rbind(gf_ta_results, ta_results, gf_ts_results, ts_results, swc_results, 
                     vpd_results, rh_results, h_results, le_results, g_results)

cat("\n\n============================================================\n")
cat("SUMMARY: SIGNIFICANT TRENDS ONLY\n")
cat("============================================================\n")

significant_trends <- all_results %>%
  filter(significant %in% c("Yes*", "Yes**")) %>%
  select(variable, season, mean_value, units, slope, sens_slope,
         mann_kendall_tau, mann_kendall_p, slope_p, recommended_test, significant)

if (nrow(significant_trends) > 0) {
  print(significant_trends)
} else {
  cat("No statistically significant trends detected at p < 0.05\n")
}

cat("\n\nInterpretation:\n")
cat("- Positive slope/tau = increasing trend over time\n")
cat("- Negative slope/tau = decreasing trend over time\n")
cat("- slope = parametric trend estimate (°C/year, W/m²/year, etc.)\n")
cat("- sens_slope = Sen's slope (robust non-parametric trend estimate)\n")
cat("- mann_kendall_tau = strength of monotonic trend (-1 to +1)\n")
cat("- Use recommended_test column to know which result to report\n")
```


#Make table of all stats results 
```{r}
# Combine all results
all_results <- rbind(gf_ta_results, gf_ts_results, 
                     swc_nf_results, vpd_results, rh_results, h_results, 
                     le_results, g_results) #ta_results, ts_results, swc_results 

# View the complete table
print(all_results)

# Select specific columns for cleaner presentation
supp_table <- all_results %>%
  select(variable, season, n_years, mean_value, units,
         slope, slope_se, slope_p, 
         adj_r_squared,
         mann_kendall_tau, mann_kendall_p, sens_slope,
         spearman_rho, spearman_p,
         shapiro_p, normal, recommended_test, significant) %>%
  arrange(variable, season)


supp_table



```
#Save supp table 
```{r}
# Export to CSV
# write.csv(supp_table, "C:/Users/kkent/Documents/Github Flux Network/Council_Flux_Analysis_Paper/Council Figures/seasonal_met_trends_statisticscsv2", row.names = FALSE)

write_xlsx(supp_table, "C:/Users/kkent/Documents/Github Flux Network/Council_Flux_Analysis_Paper/Council Figures/winteryear_seasonal_met_trends_statistics.xlsx")
```




#Trying to automate visuals that use the appropriate test (linear reg for slope, R2, p or mann-kendall for tau, sens-slope, and mk p) - code from Claude 

#this isn't the best diagnostic for this small dataset because n=6, so everything is coming up as normal/homogeneity of var when it may or may not be. Best to use non-parametric here but leaving this code becuase it's a good reference for automation of the residual plotting 

```{r}
# VISUALIZATION: Seasonal Trends Over Time (2017-2022)
# Automatically plots linear regression or Sen's slope based on normality

library(ggplot2)
library(dplyr)
library(trend)
library(gridExtra)

# ============================================================================
# FUNCTION: Create trend plot for a variable within a season
# ============================================================================

plot_seasonal_trend <- function(data, var_name, season_name, 
                                result_row, var_label, units) {
  
  # Filter data for this season and arrange by year
  plot_data <- data %>% 
    filter(season == season_name) %>%
    arrange(winter_year) %>%
    select(winter_year, value = !!sym(var_name)) %>%
    filter(!is.na(value))
  
  # Determine which test to use
  use_parametric <- result_row$normal == "Yes"
  
  # Create base plot
  p <- ggplot(plot_data, aes(x = winter_year, y = value)) +
    geom_point(size = 4, alpha = 0.7, color = "#2166ac") +
    theme_bw() +
    theme(
      plot.title = element_text(face = "bold", size = 13),
      axis.title = element_text(face = "bold", size = 11),
      axis.text = element_text(size = 10),
      panel.grid.minor = element_blank()
    )
  
  # Add appropriate trend line and statistics
  if(use_parametric) {
    # Use linear regression
    p <- p + 
      geom_smooth(method = "lm", se = TRUE, 
                  color = "#d73027", fill = "#d73027", 
                  alpha = 0.2, linewidth = 1.2) +
      labs(
        title = paste0(var_label, " - ", season_name),
        subtitle = "Linear Regression (Normal Residuals)",
        x = "Year",
        y = paste0(var_label, " (", units, ")")
      )
    
    # Create annotation text
    stats_text <- paste0(
      "Slope = ", sprintf("%.4f", result_row$slope), " ", units, "/year",
      "\nR² = ", sprintf("%.3f", result_row$adj_r_squared),
      "\np = ", format.pval(result_row$slope_p, digits = 3),
      "\n", ifelse(result_row$significant == "Yes*", "✓ Significant", "Not significant")
    )
    
  } else {
    # Use Sen's slope
    # Calculate Sen's slope line for plotting
    sens_slope_val <- result_row$sens_slope
    
    if(!is.na(sens_slope_val)) {
      # Calculate intercept for Sen's slope line
      # Use median point as anchor
      median_year <- median(plot_data$year)
      median_value <- median(plot_data$value)
      sens_intercept <- median_value - sens_slope_val * median_year
      
      p <- p + 
        geom_abline(slope = sens_slope_val, 
                    intercept = sens_intercept,
                    color = "#1b7837", linewidth = 1.2) +
        # Add a ribbon for uncertainty (optional - using IQR as rough estimate)
        stat_smooth(method = "lm", formula = y ~ x, 
                   se = TRUE, alpha = 0.1, 
                   color = NA, fill = "#1b7837")
    }
    
    p <- p + 
      labs(
        title = paste0(var_label, " - ", season_name),
        subtitle = "Mann-Kendall Trend Test (Non-Normal Residuals)",
        x = "Year",
        y = paste0(var_label, " (", units, ")")
      )
    
    # Create annotation text
    stats_text <- paste0(
      "Sen's Slope = ", sprintf("%.4f", result_row$sens_slope), " ", units, "/year",
      "\nτ = ", sprintf("%.3f", result_row$mann_kendall_tau),
      "\np = ", format.pval(result_row$mann_kendall_p, digits = 3),
      "\n", ifelse(result_row$significant == "Yes**", "✓ Significant", "Not significant")
    )
  }
  
  # Add statistics annotation
  p <- p + 
    annotate("text", 
             x = min(plot_data$year), 
             y = max(plot_data$value), 
             label = stats_text,
             hjust = 0, vjust = 1, 
             size = 3.5, 
             fontface = "bold",
             color = ifelse(use_parametric, "#d73027", "#1b7837"))
  
  return(p)
}

# ============================================================================
# FUNCTION: Create plots for all seasons of a variable
# ============================================================================

plot_all_seasons <- function(data, var_name, results_df, var_label, units, 
                             save_file = TRUE) {
  
  plot_list <- list()
  seasons <- unique(results_df$season)
  
  for(s in seasons) {
    result_row <- results_df %>% filter(season == s)
    
    if(nrow(result_row) == 0) next
    
    p <- plot_seasonal_trend(data, var_name, s, result_row, var_label, units)
    plot_list[[s]] <- p
  }
  
  # Combine plots
  if(length(plot_list) > 0) {
    combined <- grid.arrange(grobs = plot_list, ncol = 2)
    
    # Save if requested
    # if(save_file) {
    #   filename <- paste0(gsub(" ", "_", var_label), "_seasonal_trends.png")
    #   ggsave(filename, combined, width = 12, height = 8, dpi = 300)
    #   cat("Saved:", filename, "\n")
    #}
    
    return(combined)
  }
}

# ============================================================================
# CREATE PLOTS FOR SIGNIFICANT TRENDS
# ============================================================================

cat("============================================================\n")
cat("CREATING SEASONAL TREND VISUALIZATIONS\n")
cat("============================================================\n\n")

cat("Red lines = Linear Regression (normal residuals)\n")
cat("Green lines = Sen's Slope (non-normal residuals)\n\n")

# Example usage - modify based on your variable names in seasonal_summary_all

# Air Temperature (gap-filled)
cat("\n--- Plotting Air Temperature (Gap-filled) ---\n")
if(exists("gf_ta_results")) {
  plot_all_seasons(seasonal_summary_all, "TA_gapfilled_mean", 
                   gf_ta_results, "Air Temperature (GF)", "°C")
}

# Soil Temperature (gap-filled)
cat("\n--- Plotting Soil Temperature (Gap-filled) ---\n")
if(exists("gf_ts_results")) {
  plot_all_seasons(seasonal_summary_all, "TS_3_gapfilled_mean", 
                   gf_ts_results, "Soil Temperature (GF)", "°C")
}

# Soil Moisture
cat("\n--- Plotting Soil Moisture ---\n")
if(exists("swc_results")) {
  plot_all_seasons(seasonal_summary_all, "SWC_3_mean", 
                   swc_results, "Soil Moisture", "%")
}

# VPD
cat("\n--- Plotting VPD ---\n")
if(exists("vpd_results")) {
  plot_all_seasons(seasonal_summary_all, "VPD_mean", 
                   vpd_results, "VPD", "hPa")
}

# RH
cat("\n--- Plotting RH ---\n")
if(exists("rh_results")) {
  plot_all_seasons(seasonal_summary_all, "RH_mean", 
                   rh_results, "Relative Humidity", "%")
}

# Sensible Heat
cat("\n--- Plotting Sensible Heat ---\n")
if(exists("h_results")) {
  plot_all_seasons(seasonal_summary_all, "H_mean", 
                   h_results, "Sensible Heat Flux", "W/m²")
}

# Latent Heat
cat("\n--- Plotting Latent Heat ---\n")
if(exists("le_results")) {
  plot_all_seasons(seasonal_summary_all, "LE_mean", 
                   le_results, "Latent Heat Flux", "W/m²")
}

# Ground Heat
cat("\n--- Plotting Ground Heat ---\n")
if(exists("g_results")) {
  plot_all_seasons(seasonal_summary_all, "G_mean", 
                   g_results, "Ground Heat Flux", "W/m²")
}

# ============================================================================
# CREATE A SUMMARY PLOT OF ONLY SIGNIFICANT TRENDS
# ============================================================================

cat("\n\n--- Creating Summary Plot (Significant Trends Only) ---\n")

# Combine all results
if(exists("all_results")) {
  significant_results <- all_results %>%
    filter(significant %in% c("Yes*", "Yes**"))
  
  if(nrow(significant_results) > 0) {
    sig_plot_list <- list()
    
    for(i in 1:nrow(significant_results)) {
      row <- significant_results[i,]
      
      # Determine the variable name in the dataset
      var_map <- list(
        "GF Air Temperature" = "TA_gapfilled_mean",
        "Air Temperature" = "TA_mean",
        "GF Soil Temperature" = "TS_3_gapfilled_mean",
        "Soil Temperature" = "TS_3_mean",
        "Soil Moisture" = "SWC_3_mean",
        "VPD" = "VPD_mean",
        "RH" = "RH_mean",
        "Sensible Heat" = "H_mean",
        "Latent Heat" = "LE_mean",
        "Ground Heat Flux" = "G_mean"
      )
      
      var_name <- var_map[[row$variable]]
      if(!is.null(var_name)) {
        p <- plot_seasonal_trend(seasonal_summary_all, var_name, 
                                row$season, row, row$variable, row$units)
        sig_plot_list[[paste(row$variable, row$season)]] <- p
      }
    }
    
    if(length(sig_plot_list) > 0) {
      n_plots <- length(sig_plot_list)
      ncol_sig <- ifelse(n_plots <= 2, 2, 3)
      nrow_sig <- ceiling(n_plots / ncol_sig)
      
      sig_combined <- grid.arrange(
        grobs = sig_plot_list, 
        ncol = ncol_sig,
        top = grid::textGrob("Significant Seasonal Trends (2017-2022)", 
                            gp = grid::gpar(fontsize = 16, fontface = "bold"))
      )
      
      # ggsave("Significant_seasonal_trends_combined.png", sig_combined,
      #        width = 6 * ncol_sig, height = 5 * nrow_sig, dpi = 300)

    }
  } else {
    cat("No significant trends to plot.\n")
  }
}

cat("\n\nVisualization complete!\n")
cat("- Individual seasonal trend plots saved for each variable\n")
cat("- Red lines = Linear regression (normal residuals)\n")
cat("- Green lines = Sen's slope (non-normal residuals)\n")
cat("- Statistics shown match the recommended test\n")
```





#end 
